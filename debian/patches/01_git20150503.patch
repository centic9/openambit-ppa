diff -Nur -x debian -x .git -x .gitignore -x .pc ./build.sh ../openambit.git/build.sh
--- ./build.sh	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/build.sh	2015-03-20 20:47:45.908512152 +0100
@@ -1,3 +1,5 @@
+#!/bin/bash
+
 SOURCE_LOCATION="`dirname \"$0\"`"
 SOURCE_LOCATION="`( cd \"$SOURCE_LOCATION\" && pwd )`"
 
@@ -8,7 +10,7 @@
 echo "------building libambit------"
 mkdir -p libambit-build
 cd libambit-build
-cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr ../src/libambit
+cmake "$@" ../src/libambit
 make -j$CORES
 if [ "$DO_INSTALL" == "1" ]; then
     echo "------installing libambit------"
@@ -19,9 +21,25 @@
 echo "------building openambit------"
 mkdir -p openambit-build
 cd openambit-build
-cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr ../src/openambit
+cmake "$@" ../src/openambit
 make -j$CORES
 if [ "$DO_INSTALL" == "1" ]; then
     echo "------installing openambit------"
     sudo make install
 fi
+
+if [ "$BUILD_EXTRAS" == "1" ]; then
+    cd $SOURCE_LOCATION
+    echo "------building example------"
+    mkdir -p example-build
+    cd example-build
+    cmake "$@" ../src/example
+    make -j$CORES
+
+    cd $SOURCE_LOCATION
+    echo "------building wireshark dissector------"
+    mkdir -p dissector-build
+    cd dissector-build
+    cmake "$@" ../wireshark_dissector
+    make -j$CORES
+fi
diff -Nur -x debian -x .git -x .gitignore -x .pc ./Dockerfile ../openambit.git/Dockerfile
--- ./Dockerfile	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/Dockerfile	2015-05-03 10:54:35.522551177 +0200
@@ -0,0 +1,83 @@
+#  Dockerfile -- to build the sources on a well-known platform
+#  Copyright (C) 2014, 2015  Olaf Meeuwissen
+#
+#  This file is part of Openambit.
+#
+#  Openambit is free software: you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published
+#  by the Free Software Foundation, either version 3 of the License,
+#  or (at your option) any later version.
+#
+#    Openambit distributed in the hope that it will be useful, but
+#    WITHOUT ANY WARRANTY --- without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with Openambit.  If not, see https://www.gnu.org/licenses/.
+
+#  Recommended way to build the container this creates (for lack of
+#  an easy way to exclude everything but the Dockerfile):
+#
+#    docker build -t openambit:jessie - < Dockerfile
+#
+#  After that is just a matter of compiling the sources with:
+#
+#    docker run -v $PWD:/code openambit:jessie
+#
+#  once you've removed any existing *-build directories.  In order
+#  to set BUILD_EXTRAS and pass arguments on to `cmake` that becomes
+#  something like:
+#
+#    docker run -v $PWD:/code --env BUILD_EXTRAS=1 openambit:jessie \
+#      ./build.sh -DCMAKE_BUILD_TYPE=Debug
+#
+#  Doing so gives you a basic sanity check of code compilability on a
+#  minimalistic, reproducible development platform.
+
+FROM        debian:jessie
+MAINTAINER  Olaf Meeuwissen <paddy-hack@member.fsf.org>
+
+ENV  APT_OPTS --assume-yes --no-install-recommends
+
+# build system dependencies
+# Note that gcc does *not* depend on any specific C library.  Debian
+# and derivatives ship several ...
+RUN  apt-get update \
+     && apt-get install ${APT_OPTS} \
+                cmake \
+                make \
+                gcc \
+                libc-dev
+
+# libambit and example application build dependencies
+# The HID API support needs at least one of these to be available.  The
+# HIDAPI_DRIVER `cmake` variable controls what is used.
+RUN  apt-get update \
+     && apt-get install ${APT_OPTS} \
+             libudev-dev \
+             libusb-1.0-0-dev \
+             libpcap-dev
+
+# openambit build dependencies
+# Note that libqjson-dev needs to be >= 0.8
+RUN  apt-get update \
+     && apt-get install ${APT_OPTS} \
+             g++ \
+	     libqjson-dev \
+             libqt4-dev \
+             zlib1g-dev
+
+# wireshark dissector build dependencies
+RUN  apt-get update \
+     && apt-get install ${APT_OPTS} \
+             libglib2.0-dev \
+             libwireshark-dev \
+             python
+
+WORKDIR  /code
+CMD      ./build.sh
+
+# Finally, things that really should be fixed in the Openambit code.
+# FIXME add multiarch support to src/libambit/cmake/FindUdev.cmake
+RUN  cd /usr/lib/ && ln -s x86_64-linux-gnu/libudev.so
diff -Nur -x debian -x .git -x .gitignore -x .pc ./README ../openambit.git/README
--- ./README	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-OPENAMBIT
-=========
-
-The openambit source repository consists of several parts.
-Each part is briefly described below.
-Most people would like to use both the device communication
-library (libambit) and the GUI (openambit). The build / install
-scripts described below make your life easier if you are
-like most people.
-You can choose to run the GUI from the build folder or install
-it to your system.
-
-BUILD SCRIPT
-============
-Builds libambit and openambit in one command
-> cd YOUR/git/REPO/location
-> ./build.sh
-
-
-BUILD AND INSTALL SCRIPT
-========================
-Builds and install libambit and openambit in one command.
-Note that the script will try to run sudo to install things.
-> cd YOUR/git/REPO/location
-> ./install.sh
-
-
-DEPENDENCIES
-============
-To be able to build libambit and openambit the following libraries
-(and their header files) need to be available:
- - libudev
- - libusb
- - libqjson
-
-For debian-based systems:
-> sudo apt-get install libudev-dev libusb-1.0-0-dev libqjson-dev
-
-
-src/libambit
-============
-The "driver" library as a shared object. Written in C.
-
-Build instructions:
-> mkdir libambit-build
-> cd libambit-build
-> cmake ../src/libambit
-> make
-Optionally:
-> sudo make install
-
-
-src/openambit
-=============
-The GUI application. Uses the libambit library.
-
-Build instructions:
-First build libambit as instructed above
-> mkdir openambit-build
-> cd openambit-build
-> cmake ../src/openambit
-> make
-Optionally:
-> sudo make install
-
-Run the application without installing:
-> cd openambit-build
-> LD_LIBRARY_PATH=../libambit-build ./openambit
-
-
-tools/movescountXmlDiff.pl
-==========================
-Small Perl-script to compare XML-files generated by
-openambit and Suuntos Moveslink. Basically a diff with
-added floating point round errors ignored.
-
-
-wireshark_dissector
-===================
-To ease the parsing of the protocol a wireshark dissector
-is maintained. This dissector parses pcap-files made with
-usbpcap. The parts of the protocol that is known atm
-should be present in the latest dissector.
-
-Build instructions:
-> mkdir build
-> cd build
-> cmake ..
-> make
-> cp ambit.so ~/.wireshark/plugins
-
diff -Nur -x debian -x .git -x .gitignore -x .pc ./README.rst ../openambit.git/README.rst
--- ./README.rst	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/README.rst	2015-05-03 10:54:35.522551177 +0200
@@ -0,0 +1,148 @@
+Openambit
+=========
+
+Openambit makes your computer the Free (as in Freedom) conduit between
+your Ambit watch and Suunto's `Movescount`_ site (if you want it to go
+that far).  It enables you to get your hard-earned "move" log data off
+*your* watch and onto *your* computer.  And if you really want it to,
+Openambit will pump that data into the cloud where Big Data can crunch
+it to pieces and analyze your moves to shreds.
+
+
+Modules
+-------
+
+Openambit includes the following modules:
+
+src/libambit
+  a library that let's you computer communicate with your Ambit watch
+
+src/openambit
+  a Qt based GUI application to get data off your watch and push it to
+  Suunto's `Movescount`_ site
+
+src/example
+  a very simple command-line application that reports on your watch's
+  support status, and, if your watch is supported, battery charge and
+  a summary of the moves on your watch.
+
+tools
+  contains a few utilities that people thought useful.  One compares
+  Openambit's XML log files with those from `Moveslink2`_ and another
+  converts the XML to `GPX`_
+
+wireshark_dissector
+  a `Wireshark`_ packet dissector to help reverse engineer the Ambit
+  device protocol by picking your packet captures apart.
+
+
+Source Or Binary?
+-----------------
+
+Let's be clear, building from the latest revision in the repository is
+not quite for the faint of heart.  You need a development environment,
+make sure build requirements are met, actually build (doh!) and pray
+things work as intended.  And if worse comes to worst, you might even
+brick your Ambit watch and turn it into a `paperweight`_.
+
+Of course, we try our damnedest (and often put our own Ambits to the
+test) to prevent that absolutely worst-case scenario but there are
+*no* guarantees.
+
+Distribution provided binary packages, such as provided by `Debian`_
+and `Ubuntu`_ are normally built from reasonably well tested sources.
+As in, it probably will not turn your Ambit into a paperweight.  That
+might just meet your needs.  For other distributions, have a look at
+`OSWatershed.org`_, or hit your favourite search engine.
+
+If you cannot find binaries that meet your needs (not that unlikely at
+present), you can compile from one of the source code archives on our
+`release`_ page (or the corresponding ``git tag``).  That would also
+be on the safe side.
+
+As a last resort, or if you're a developer type, go ahead and build
+from the latest, greatest "bleeding edge" version on the repository's
+``master`` branch.
+
+
+Requirements
+------------
+
+In order to build Openambit from source you need a couple of tools and
+libraries.  To begin with, you will need ``cmake``, ``make`` and C and
+C++ compilers.  You will need C and C++ libraries, Qt4, ``libqjson``
+and ``zlib`` as well as one of ``libudev`` and ``libusb-1.0``.  For
+all these libraries you will also need their header files (typically
+provided in ``*-dev`` or ``*-devel`` packages).
+
+
+Build Procedure
+---------------
+
+The simplest way to build from source is by means of the ``build.sh``
+script.  It will build all components needed to use Openambit.  Any
+command-line arguments you specify are passed on to ``cmake``.  That
+means you can set up a "Debug" build with
+
+.. code-block:: sh
+
+   cd /path/to/your/clone/of/openambit
+   ./build.sh -DCMAKE_BUILD_TYPE=Debug
+
+Developer and otherwise inquisitive types may want to build some of
+the extras that are included.  To do so
+
+.. code-block:: sh
+
+   cd /path/to/your/clone/of/openambit
+   BUILD_EXTRAS=1 ./build.sh
+
+You can run the applications you built *without* installing as follows
+
+.. code-block:: sh
+
+   ./run.sh			# runs the GUI application
+   ./run.sh openambit		# runs the GUI application
+   ./run.sh ambitconsole	# runs the example application
+
+If you are only interested in building a selected module, you can just
+use ``cmake`` directly.  For example, if all you really want to build
+is ``libambit`` and nothing else, you could (for example)
+
+.. code-block:: sh
+
+   cd /path/to/your/clone/of/openambit
+   mkdir _build
+   cd _build
+   cmake ../src/libambit
+   make
+
+
+Install Procedure
+-----------------
+
+If you have built from source with ``build.sh``, you can install with
+``install.sh``.  This only installs the ``openambit`` application and
+the ``libambit`` library it needs.  When you have built only selected
+parts, simply install them with
+
+.. code-block:: sh
+
+   cd /path/to/your/build/directory
+   sudo make install
+
+To enable the Wireshark dissector, just copy the ``ambit.so`` file to
+your ``~/.wireshark/plugins/`` directory.  You can also put a symbolic
+link there pointing to the build result so your next ``wireshark`` run
+will use the latest, greatest(?) version.
+
+
+.. _Movescount: http://www.movescount.com/
+.. _Moveslink2: http://www.movescount.com/connect/moveslink/Suunto_Ambit
+.. _GPX: https://en.wikipedia.org/wiki/GPS_Exchange_Format
+.. _Wireshark: https://www.wireshark.org/
+.. _paperweight: https://en.wikipedia.org/wiki/Paperweight
+.. _Debian: https://packages.debian.org/search?keywords=openambit
+.. _Ubuntu: http://packages.ubuntu.com/search?keywords=openambit
+.. _OSWatershed.org: http://oswatershed.org/pkg/openambit
+.. _release: https://github.com/openambitproject/openambit/releases
diff -Nur -x debian -x .git -x .gitignore -x .pc ./run.sh ../openambit.git/run.sh
--- ./run.sh	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/run.sh	2015-05-03 10:54:35.522551177 +0200
@@ -1,8 +1,23 @@
+#!/bin/sh
+
 SOURCE_LOCATION="`dirname \"$0\"`"
 SOURCE_LOCATION="`( cd \"$SOURCE_LOCATION\" && pwd )`"
 
 cd $SOURCE_LOCATION
-echo "------running openambit------"
-LD_LIBRARY_PATH=./libambit-build ./openambit-build/openambit
 
+application=openambit
+if test -n "$1"; then
+     application=$1
+     shift
+fi
+case "$application" in
+    openambit)          builddir=$application-build;;
+    ambitconsole)       builddir=example-build;;
+    *)
+	echo "$application: not supported" >&2
+	exit 1
+	;;
+esac
 
+echo "------running $application------"
+LD_LIBRARY_PATH=./libambit-build ./$builddir/$application
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/example/ambitconsole.c ../openambit.git/src/example/ambitconsole.c
--- ./src/example/ambitconsole.c	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/example/ambitconsole.c	2015-03-20 20:47:45.908512152 +0100
@@ -1,5 +1,6 @@
 #include <stdlib.h>
 #include <stdio.h>
+#include <string.h>
 #include <libambit.h>
 
 static int log_skip_cb(void *ambit_object, ambit_log_header_t *log_header);
@@ -7,18 +8,25 @@
 
 int main(int argc, char *argv[])
 {
+    ambit_device_info_t *info = libambit_enumerate();
     ambit_object_t *ambit_object;
-    ambit_device_info_t info;
     ambit_device_status_t status;
     ambit_personal_settings_t settings;
-    time_t current_time;
-    struct tm *local_time;
 
-    if ((ambit_object = libambit_detect()) != NULL) {
-        libambit_device_info_get(ambit_object, &info);
+    if (info) {
+        printf("Device: %s, serial: %s\n", info->name, info->serial);
+        if (0 == info->access_status) {
+          printf("F/W version: %d.%d.%d\n", info->fw_version[0], info->fw_version[1], (info->fw_version[2] << 0) | (info->fw_version[3] << 8));
+            if (!info->is_supported) {
+                printf("Device is not supported yet!\n");
+            }
+        }
+        else {
+            printf("%s: %s\n", info->path, strerror(info->access_status));
+        }
 
-        if (libambit_device_supported(ambit_object)) {
-            printf("Device: %s, serial: %s, FW version: %d.%d.%d\n", info.name, info.serial, info.fw_version[0], info.fw_version[1], info.fw_version[2] | (info.fw_version[3] << 8));
+        ambit_object = libambit_new(info);
+        if (ambit_object) {
 
             if (libambit_device_status_get(ambit_object, &status) == 0) {
                 printf("Current charge: %d%%\n", status.charge);
@@ -30,28 +38,17 @@
             if (libambit_personal_settings_get(ambit_object, &settings) == 0) {
             }
             else {
-                printf("Failed to read status\n");
+                printf("Failed to read personal settings\n");
             }
 
-            current_time = time(NULL);
-            local_time = localtime(&current_time);
-            //if (libambit_date_time_set(ambit_object, local_time) == 0) {
-            //}
-            //else {
-            //    printf("Failed to set date and time\n");
-            //}
-
             libambit_log_read(ambit_object, log_skip_cb, log_data_cb, NULL, ambit_object);
+            libambit_close(ambit_object);
         }
-        else {
-            printf("Device: %s (fw_version: %d.%d.%d) is not supported yet!\n", info.name, info.fw_version[0], info.fw_version[1], info.fw_version[2] | (info.fw_version[3] << 8));
-        }
-
-        libambit_close(ambit_object);
     }
     else {
         printf("No clock found, exiting\n");
     }
+    libambit_free_enumeration(info);
 
     return 0;
 }
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/example/cmake/Findlibambit.cmake ../openambit.git/src/example/cmake/Findlibambit.cmake
--- ./src/example/cmake/Findlibambit.cmake	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/example/cmake/Findlibambit.cmake	2015-03-20 20:47:45.912512150 +0100
@@ -0,0 +1,26 @@
+# - Find libambit
+# If found, this will define
+#
+# LIBAMBIT_FOUND - system has libambit
+# LIBAMBIT_INCLUDE_DIR - the libambit include directory
+# LIBAMBIT_LIBS - the libambit libraries
+
+find_path(LIBAMBIT_INCLUDE_DIR NAMES libambit.h
+  PATHS ${CMAKE_SOURCE_DIR}/../libambit NO_DEFAULT_PATH
+)
+find_path(LIBAMBIT_INCLUDE_DIR NAMES libambit.h)
+
+find_library(LIBAMBIT_LIBS NAMES ambit
+  PATHS ${CMAKE_BINARY_DIR}/../libambit-build NO_DEFAULT_PATH
+)
+find_library(LIBAMBIT_LIBS NAMES ambit)
+
+if(LIBAMBIT_INCLUDE_DIR AND LIBAMBIT_LIBS)
+  set(LIBAMBIT_FOUND TRUE CACHE INTERNAL "libambit found")
+  message(STATUS "Found libambit: ${LIBAMBIT_INCLUDE_DIR}, ${LIBAMBIT_LIBS}")
+else(LIBAMBIT_INCLUDE_DIR AND LIBAMBIT_LIBS)
+  set(LIBAMBIT_FOUND FALSE CACHE INTERNAL "libambit found")
+  message(STATUS "libambit not found.")
+endif(LIBAMBIT_INCLUDE_DIR AND LIBAMBIT_LIBS)
+
+mark_as_advanced(LIBAMBIT_INCLUDE_DIR LIBAMBIT_LIBS)
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/example/CMakeLists.txt ../openambit.git/src/example/CMakeLists.txt
--- ./src/example/CMakeLists.txt	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/example/CMakeLists.txt	2015-03-20 20:47:45.908512152 +0100
@@ -1,9 +1,19 @@
+cmake_minimum_required(VERSION 2.8.5)
+project (EXAMPLE C)
+
+# Where to lookup modules
+set(CMAKE_MODULE_PATH "${EXAMPLE_SOURCE_DIR}/cmake")
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall")
+
+find_package(libambit REQUIRED)
+
 include_directories(
-  ${OPENAMBIT_SOURCE_DIR}/libambit
+  ${LIBAMBIT_INCLUDE_DIR}
 )
 
 link_directories(
-  ${OPENAMBIT_BINARY_DIR}/libambit
+  ${LIBAMBIT_LIBS_DIR}
 )
 
 add_executable(
@@ -11,5 +21,5 @@
 )
 
 target_link_libraries(
-  ambitconsole ambit
+  ambitconsole ${LIBAMBIT_LIBS}
 )
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/cmake/FindPCAP.cmake ../openambit.git/src/libambit/cmake/FindPCAP.cmake
--- ./src/libambit/cmake/FindPCAP.cmake	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/cmake/FindPCAP.cmake	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,74 @@
+# - Try to find libpcap include dirs and libraries
+#
+# Usage of this module as follows:
+#
+#     find_package(PCAP)
+#
+# Variables used by this module, they can change the default behaviour and need
+# to be set before calling find_package:
+#
+#  PCAP_ROOT_DIR             Set this variable to the root installation of
+#                            libpcap if the module has problems finding the
+#                            proper installation path.
+#
+# Variables defined by this module:
+#
+#  PCAP_FOUND                System has libpcap, include and library dirs found
+#  PCAP_INCLUDE_DIR          The libpcap include directories.
+#  PCAP_LIBRARY              The libpcap library (possibly includes a thread
+#                            library e.g. required by pf_ring's libpcap)
+#  HAVE_PF_RING              If a found version of libpcap supports PF_RING
+
+find_path(PCAP_ROOT_DIR
+    NAMES include/pcap.h
+)
+
+find_path(PCAP_INCLUDE_DIR
+    NAMES pcap.h
+    HINTS ${PCAP_ROOT_DIR}/include
+)
+
+find_library(PCAP_LIBRARY
+    NAMES pcap
+    HINTS ${PCAP_ROOT_DIR}/lib
+)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(PCAP DEFAULT_MSG
+    PCAP_LIBRARY
+    PCAP_INCLUDE_DIR
+)
+
+include(CheckCSourceCompiles)
+set(CMAKE_REQUIRED_LIBRARIES ${PCAP_LIBRARY})
+check_c_source_compiles("int main() { return 0; }" PCAP_LINKS_SOLO)
+set(CMAKE_REQUIRED_LIBRARIES)
+
+# check if linking against libpcap also needs to link against a thread library
+if (NOT PCAP_LINKS_SOLO)
+    find_package(Threads)
+    if (THREADS_FOUND)
+        set(CMAKE_REQUIRED_LIBRARIES ${PCAP_LIBRARY} ${CMAKE_THREAD_LIBS_INIT})
+        check_c_source_compiles("int main() { return 0; }" PCAP_NEEDS_THREADS)
+        set(CMAKE_REQUIRED_LIBRARIES)
+    endif ()
+    if (THREADS_FOUND AND PCAP_NEEDS_THREADS)
+        set(_tmp ${PCAP_LIBRARY} ${CMAKE_THREAD_LIBS_INIT})
+        list(REMOVE_DUPLICATES _tmp)
+        set(PCAP_LIBRARY ${_tmp}
+            CACHE STRING "Libraries needed to link against libpcap" FORCE)
+    else ()
+        message(FATAL_ERROR "Couldn't determine how to link against libpcap")
+    endif ()
+endif ()
+
+include(CheckFunctionExists)
+set(CMAKE_REQUIRED_LIBRARIES ${PCAP_LIBRARY})
+check_function_exists(pcap_get_pfring_id HAVE_PF_RING)
+set(CMAKE_REQUIRED_LIBRARIES)
+
+mark_as_advanced(
+    PCAP_ROOT_DIR
+    PCAP_INCLUDE_DIR
+    PCAP_LIBRARY
+)
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/cmake/HidapiDriver.cmake ../openambit.git/src/libambit/cmake/HidapiDriver.cmake
--- ./src/libambit/cmake/HidapiDriver.cmake	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/cmake/HidapiDriver.cmake	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,30 @@
+# - Resolve what hidapi driver to use
+# This module is affected by the following defines
+#  HIDAPI_DRIVER (possible values: usbraw, libusb, pcapsimulate)
+#
+# This module defines
+#  HIDAPI_INCLUDE_DIR
+#  HIDAPI_SOURCE_FILES
+#  HIDAPI_LIBS
+
+if (NOT HIDAPI_RESOLVED)
+    if (HIDAPI_DRIVER STREQUAL "libusb")
+        find_package(libusb REQUIRED)
+        set (HIDAPI_INCLUDE_DIR "hidapi" ${LIBUSB_INCLUDE_DIR})
+        set (HIDAPI_SOURCE_FILES "hidapi/hid-libusb.c")
+        set (HIDAPI_LIBS ${LIBUSB_LIBRARIES})
+    elseif (HIDAPI_DRIVER STREQUAL "pcapsimulate")
+        find_package(PCAP REQUIRED)
+        set (HIDAPI_INCLUDE_DIR "hidapi" ${PCAP_INCLUDE_DIR})
+        set (HIDAPI_SOURCE_FILES "hidapi/hid-pcapsimulate.c")
+        set (HIDAPI_LIBS ${PCAP_LIBRARY})
+    else (HIDAPI_DRIVER STREQUAL "libusb")
+        find_package(UDev REQUIRED)
+        set (HIDAPI_INCLUDE_DIR "hidapi" ${UDEV_INCLUDE_DIR})
+        set (HIDAPI_SOURCE_FILES "hidapi/hid-linux.c")
+        set (HIDAPI_LIBS ${UDEV_LIBS})
+    endif (HIDAPI_DRIVER STREQUAL "libusb")
+
+    mark_as_advanced(HIDAPI_INCLUDE_DIR HIDAPI_SOURCE_FILES HIDAPI_LIBS)
+    set (HIDAPI_RESOLVED TRUE)
+endif (NOT HIDAPI_RESOLVED)
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/CMakeLists.txt ../openambit.git/src/libambit/CMakeLists.txt
--- ./src/libambit/CMakeLists.txt	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/libambit/CMakeLists.txt	2015-03-20 20:47:45.908512152 +0100
@@ -1,5 +1,5 @@
 cmake_minimum_required (VERSION 2.8.5)
-project (LIBAMBIT)
+project (LIBAMBIT C)
 
 # Where to lookup modules
 set(CMAKE_MODULE_PATH "${LIBAMBIT_SOURCE_DIR}/cmake")
@@ -15,8 +15,7 @@
   set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -DDEBUG_PRINT_FILE_LINE=${DEBUG_PRINT_FILE_LINE}")
 ENDIF()
 
-find_package(libusb REQUIRED)
-find_package(UDev REQUIRED)
+include(HidapiDriver)
 include(GNUInstallDirs)
 
 add_library (
@@ -24,25 +23,39 @@
   SHARED
   crc16.c
   debug.c
-  hid.c
+  device_driver_ambit.c
+  device_driver_ambit3.c
+  device_driver_common.c
+  device_support.c
   libambit.c
   personal.c
   pmem20.c
   protocol.c
+  sbem0102.c
+  sha256.c
+  utils.c
+  ${HIDAPI_SOURCE_FILES}
 )
 
 target_link_libraries(
   ambit
-  ${UDEV_LIBS}
-  ${LIBUSB_LIBRARIES}
+  ${HIDAPI_LIBS}
   m
 )
 
 set_target_properties(ambit PROPERTIES VERSION 0.3.0 SOVERSION 0)
 
 include_directories(
-  hidapi
+  ${HIDAPI_INCLUDE_DIR}
 )
 
 install(TARGETS ambit DESTINATION ${CMAKE_INSTALL_LIBDIR})
 install(FILES libambit.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
+
+set(CMAKE_INSTALL_UDEVRULESDIR /etc/udev/rules.d
+    CACHE PATH "Where to install udev rules")
+mark_as_advanced(CMAKE_INSTALL_UDEVRULESDIR)
+
+install(FILES libambit.rules
+        DESTINATION $ENV{DESTDIR}${CMAKE_INSTALL_UDEVRULESDIR}
+        COMPONENT system)
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/crc16.c ../openambit.git/src/libambit/crc16.c
--- ./src/libambit/crc16.c	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/libambit/crc16.c	2014-11-05 21:53:14.000000000 +0100
@@ -18,7 +18,7 @@
 /*                                                               */
 /*****************************************************************/
 
-#include "libambit_int.h"
+#include "crc16.h"
 
 static uint16_t crctable[256] =
 {
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/crc16.h ../openambit.git/src/libambit/crc16.h
--- ./src/libambit/crc16.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/crc16.h	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __CRC16_H__
+#define __CRC16_H__
+
+#include <stddef.h>
+#include <stdint.h>
+
+uint16_t crc16_ccitt_false(unsigned char *buf, size_t buflen);
+uint16_t crc16_ccitt_false_init(unsigned char *buf, size_t buflen, uint16_t crc);
+
+#endif /* __CRC16_H__ */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/debug.c ../openambit.git/src/libambit/debug.c
--- ./src/libambit/debug.c	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/libambit/debug.c	2014-11-05 21:53:14.000000000 +0100
@@ -19,8 +19,7 @@
  * Contributors:
  *
  */
-#include "libambit.h"
-#include "libambit_int.h"
+#include "debug.h"
 
 #include <stdarg.h>
 #include <stdio.h>
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/debug.h ../openambit.git/src/libambit/debug.h
--- ./src/libambit/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/debug.h	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+#include <stddef.h>
+#include <stdint.h>
+
+typedef enum debug_level_e {
+    debug_level_err,
+    debug_level_warn,
+    debug_level_info
+} debug_level_t;
+
+void debug_printf(debug_level_t level, const char *file, int line, const char *func, const char *fmt, ...);
+
+#ifdef DEBUG_PRINT_ERROR
+#define LOG_ERROR(fmt, ...) debug_printf(debug_level_err, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
+#else
+#define LOG_ERROR(fmt, ...)
+#endif
+#ifdef DEBUG_PRINT_WARNING
+#define LOG_WARNING(fmt, ...) debug_printf(debug_level_warn, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
+#else
+#define LOG_WARNING(fmt, ...)
+#endif
+#ifdef DEBUG_PRINT_INFO
+#define LOG_INFO(fmt, ...) debug_printf(debug_level_info, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
+#else
+#define LOG_INFO(fmt, ...)
+#endif
+
+#endif /* __DEBUG_H__ */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/device_driver_ambit3.c ../openambit.git/src/libambit/device_driver_ambit3.c
--- ./src/libambit/device_driver_ambit3.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_driver_ambit3.c	2015-03-20 20:47:45.908512152 +0100
@@ -0,0 +1,459 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include "device_driver.h"
+#include "device_driver_common.h"
+#include "libambit_int.h"
+#include "protocol.h"
+#include "pmem20.h"
+#include "personal.h"
+#include "sbem0102.h"
+#include "utils.h"
+#include "debug.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+/*
+ * Local definitions
+ */
+typedef struct memory_map_entry_s {
+    uint32_t start;
+    uint32_t size;
+    uint8_t hash[32];
+} memory_map_entry_t;
+
+struct ambit_device_driver_data_s {
+    libambit_pmem20_t pmem20;
+    libambit_sbem0102_t sbem0102;
+    struct {
+        uint8_t initialized;
+        memory_map_entry_t waypoints;
+        memory_map_entry_t routes;
+        memory_map_entry_t rules;
+        memory_map_entry_t gps;
+        memory_map_entry_t custom_modes;
+        memory_map_entry_t training_program;
+        memory_map_entry_t excercise_log;
+        memory_map_entry_t event_log;
+        memory_map_entry_t ble_pairing;
+    } memory_maps;
+};
+
+typedef struct ambit3_log_header_s {
+    ambit_log_header_t header;
+    uint32_t address;
+    uint32_t end_address;
+    uint8_t synced;
+} ambit3_log_header_t;
+
+/*
+ * Static functions
+ */
+static void init(ambit_object_t *object, uint32_t driver_param);
+static void deinit(ambit_object_t *object);
+static int personal_settings_get(ambit_object_t *object, ambit_personal_settings_t *settings);
+static int log_read(ambit_object_t *object, ambit_log_skip_cb skip_cb, ambit_log_push_cb push_cb, ambit_log_progress_cb progress_cb, void *userref);
+static int gps_orbit_header_read(ambit_object_t *object, uint8_t data[8]);
+static int gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen);
+
+static int parse_log_header(const uint8_t *data, ambit3_log_header_t *log_header);
+static int get_memory_maps(ambit_object_t *object);
+
+/*
+ * Global variables
+ */
+ambit_device_driver_t ambit_device_driver_ambit3 = {
+    init,
+    deinit,
+    libambit_device_driver_lock_log,
+    libambit_device_driver_date_time_set,
+    libambit_device_driver_status_get,
+    personal_settings_get,
+    log_read,
+    gps_orbit_header_read,
+    gps_orbit_write
+};
+
+/*
+ * Static functions implementation
+ */
+/**
+ * Init function
+ * \param object to initialize
+ * \param driver_param PMEM20 chunk size
+ */
+static void init(ambit_object_t *object, uint32_t driver_param)
+{
+    struct ambit_device_driver_data_s *data;
+
+    if ((data = calloc(1, sizeof(struct ambit_device_driver_data_s))) != NULL) {
+        object->driver_data = data;
+        libambit_pmem20_init(&object->driver_data->pmem20, object, driver_param);
+        libambit_sbem0102_init(&object->driver_data->sbem0102, object, driver_param);
+    }
+}
+
+static void deinit(ambit_object_t *object)
+{
+    if (object->driver_data != NULL) {
+        libambit_pmem20_deinit(&object->driver_data->pmem20);
+        libambit_sbem0102_deinit(&object->driver_data->sbem0102);
+    }
+}
+
+static int personal_settings_get(ambit_object_t *object, ambit_personal_settings_t *settings)
+{
+    uint8_t send_data[4] = { 0x00, 0x00, 0x00, 0x00 };
+    libambit_sbem0102_data_t reply_data_object;
+
+    LOG_INFO("Reading personal settings");
+
+    libambit_sbem0102_data_init(&reply_data_object);
+    if (libambit_sbem0102_command_request_raw(&object->driver_data->sbem0102, ambit_command_ambit3_settings, send_data, sizeof(send_data), &reply_data_object) != 0) {
+        LOG_WARNING("Failed to read personal settings");
+        return -1;
+    }
+
+    memset(settings, 0, sizeof(ambit_personal_settings_t));
+
+    while (libambit_sbem0102_data_next(&reply_data_object) == 0) {
+        switch (libambit_sbem0102_data_id(&reply_data_object)) {
+          case 0x1a:
+            settings->weight = read16(libambit_sbem0102_data_ptr(&reply_data_object), 0);
+            break;
+          case 0x1f:
+            if (libambit_sbem0102_data_len(&reply_data_object) == 11) {
+                sscanf((const char*)libambit_sbem0102_data_ptr(&reply_data_object), "%04hu-", &settings->birthyear);
+            }
+            break;
+          case 0x1b:
+          case 0x1e:
+            // settings->length = libambit_sbem0102_data_ptr(&reply_data_object)[0];
+            //break;
+          case 0x1c:
+            //settings->backlight_brightness = libambit_sbem0102_data_ptr(&reply_data_object)[0];
+            //break;
+          case 0x1d:
+            //settings->display_brightness = libambit_sbem0102_data_ptr(&reply_data_object)[0];
+            //break;
+          default:
+            /*
+            printf("Got id=%02x: ", libambit_sbem0102_data_id(&reply_data_object));
+            switch(libambit_sbem0102_data_len(&reply_data_object)) {
+              case 1:
+                printf("%d", libambit_sbem0102_data_ptr(&reply_data_object)[0]);
+                break;
+              case 2:
+                printf("%d", read16(libambit_sbem0102_data_ptr(&reply_data_object), 0));
+                break;
+              case 4:
+                printf("%d", read32(libambit_sbem0102_data_ptr(&reply_data_object), 0));
+                break;
+              default:
+                {
+                    int q;
+                for(q=0; q<libambit_sbem0102_data_len(&reply_data_object); q++)
+                    printf("%02x", libambit_sbem0102_data_ptr(&reply_data_object)[q]);
+                }
+                break;
+            }
+            printf("\n");
+            */
+            break;
+        }
+    }
+
+    return 0;
+}
+
+static int log_read(ambit_object_t *object, ambit_log_skip_cb skip_cb, ambit_log_push_cb push_cb, ambit_log_progress_cb progress_cb, void *userref)
+{
+    int entries_read = 0;
+
+    uint16_t log_entries_total = 0;
+    uint16_t log_entries_walked = 0;
+    uint16_t log_entries_notsynced = 0;
+
+    ambit3_log_header_t log_header;
+    ambit_log_entry_t *log_entry;
+
+    libambit_sbem0102_data_t send_data_object, reply_data_object;
+
+    LOG_INFO("Reading log headers");
+    log_header.header.activity_name = NULL;
+    
+    libambit_sbem0102_data_init(&send_data_object);
+    libambit_sbem0102_data_init(&reply_data_object);
+    libambit_sbem0102_data_add(&send_data_object, 0x81, NULL, 0);
+    if (libambit_sbem0102_command_request(&object->driver_data->sbem0102, ambit_command_ambit3_log_headers, &send_data_object, &reply_data_object) != 0) {
+        LOG_WARNING("Failed to read log headers");
+        return -1;
+    }
+
+    if (object->driver_data->memory_maps.initialized == 0) {
+        if (get_memory_maps(object) != 0) {
+            return -1;
+        }
+    }
+
+    // Initialize PMEM20 log before starting to read logs
+    libambit_pmem20_log_init(&object->driver_data->pmem20, object->driver_data->memory_maps.excercise_log.start, object->driver_data->memory_maps.excercise_log.size);
+
+    while (libambit_sbem0102_data_next(&reply_data_object) == 0) {
+        switch (libambit_sbem0102_data_id(&reply_data_object)) {
+          case 0x4e:
+            log_entries_total = read16(libambit_sbem0102_data_ptr(&reply_data_object), 0);
+            LOG_INFO("Number of logs=%d", log_entries_total);
+            break;
+          case 0x4f:
+            log_entries_notsynced = read16(libambit_sbem0102_data_ptr(&reply_data_object), 0);
+            LOG_INFO("Number of logs marked as not syncronized=%d", log_entries_notsynced);
+            break;
+          case 0x7e:
+            if (parse_log_header(libambit_sbem0102_data_ptr(&reply_data_object), &log_header) == 0) {
+                LOG_INFO("Log header parsed successfully");
+                if (skip_cb(userref, &log_header.header) != 0) {
+                    LOG_INFO("Reading data of log %d of %d", log_entries_walked + 1, log_entries_total);
+                    log_entry = libambit_pmem20_log_read_entry_address(&object->driver_data->pmem20, log_header.address, log_header.end_address - log_header.address);
+                    if (log_entry != NULL) {
+                        if (push_cb != NULL) {
+                            push_cb(userref, log_entry);
+                        }
+                        entries_read++;
+                    }
+                }
+                else {
+                    LOG_INFO("Log entry already exists, skipping");
+                }
+            }
+            else {
+                LOG_INFO("Failed to parse log header");
+            }
+            log_entries_walked++;
+            if (progress_cb != NULL) {
+                progress_cb(userref, log_entries_total, log_entries_walked, 100*log_entries_walked/log_entries_total);
+            }
+            break;
+          default:
+            break;
+        }
+    }
+
+    libambit_sbem0102_data_free(&send_data_object);
+    libambit_sbem0102_data_free(&reply_data_object);
+
+    return entries_read;
+}
+
+static int gps_orbit_header_read(ambit_object_t *object, uint8_t data[8])
+{
+    uint8_t *reply_data = NULL;
+    size_t replylen = 0;
+    int ret = -1;
+
+    if (libambit_protocol_command(object, ambit_command_gps_orbit_head, NULL, 0, &reply_data, &replylen, 0) == 0 && replylen >= 9) {
+        memcpy(data, &reply_data[1], 8);
+        libambit_protocol_free(reply_data);
+
+        ret = 0;
+    }
+    else {
+        LOG_WARNING("Failed to read GPS orbit header");
+    }
+
+    return ret;
+}
+
+static int gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen)
+{
+    uint8_t header[8], cmpheader[8];
+    int ret = -1;
+
+    LOG_INFO("Writing GPS orbit data");
+
+    libambit_protocol_command(object, ambit_command_write_start, NULL, 0, NULL, NULL, 0);
+
+    if (object->driver->gps_orbit_header_read(object, header) == 0) {
+        cmpheader[0] = data[7]; // Year, swap bytes
+        cmpheader[1] = data[6];
+        cmpheader[2] = data[8];
+        cmpheader[3] = data[9];
+        cmpheader[4] = data[13]; // 4 byte swap
+        cmpheader[5] = data[12];
+        cmpheader[6] = data[11];
+        cmpheader[7] = data[10];
+
+        // Check if new data differs 
+        if (memcmp(header, cmpheader, 8) != 0) {
+            ret = libambit_pmem20_gps_orbit_write(&object->driver_data->pmem20, data, datalen, true);
+        }
+        else {
+            LOG_INFO("Current GPS orbit data is already up to date, skipping");
+            ret = 0;
+        }
+    }
+
+    return ret;
+}
+
+static int parse_log_header(const uint8_t *data, ambit3_log_header_t *log_header)
+{
+    struct tm tm;
+    char *ptr;
+    size_t offset = 0;
+
+    // Start with parsing the time
+    if ((ptr = libambit_strptime((const char *)data, "%Y-%m-%dT%H:%M:%S", &tm)) == NULL) {
+        return -1;
+    }
+    log_header->header.date_time.year = 1900 + tm.tm_year;
+    log_header->header.date_time.month = tm.tm_mon + 1;
+    log_header->header.date_time.day = tm.tm_mday;
+    log_header->header.date_time.hour = tm.tm_hour;
+    log_header->header.date_time.minute = tm.tm_min;
+    log_header->header.date_time.msec = tm.tm_sec*1000;
+    offset += (size_t)ptr - (size_t)data + 1;
+
+    log_header->synced = read8inc(data, &offset);
+    log_header->address = read32inc(data, &offset);
+    log_header->end_address = read32inc(data, &offset);
+    offset += 8; // Unknown bytes
+    log_header->header.heartrate_min = read8inc(data, &offset);
+    log_header->header.heartrate_avg = read8inc(data, &offset);
+    log_header->header.heartrate_max = read8inc(data, &offset);
+    log_header->header.heartrate_max_time = read32inc(data, &offset);
+    log_header->header.heartrate_min_time = read32inc(data, &offset);
+    // temperature format is messed up, 1 byte is missing, just skip for now
+    log_header->header.temperature_min = 0;
+    log_header->header.temperature_max = 0;
+    offset += 2;
+    log_header->header.temperature_min_time = read32inc(data, &offset);
+    log_header->header.temperature_max_time = read32inc(data, &offset);
+    log_header->header.altitude_min = read16inc(data, &offset);
+    log_header->header.altitude_max = read16inc(data, &offset);
+    log_header->header.altitude_min_time = read32inc(data, &offset);
+    log_header->header.altitude_max_time = read32inc(data, &offset);
+    log_header->header.cadence_avg = read8inc(data, &offset);
+    log_header->header.cadence_max = read8inc(data, &offset);
+    log_header->header.cadence_max_time = read32inc(data, &offset);
+    log_header->header.speed_avg = read16inc(data, &offset); // 10 m/h
+    log_header->header.speed_max = read16inc(data, &offset); // 10 m/h
+    log_header->header.speed_max_time = read32inc(data, &offset);
+    offset += 4; // Unknown bytes
+    log_header->header.duration = read32inc(data, &offset)*100; // seconds 0.1
+    log_header->header.ascent = read16inc(data, &offset);
+    log_header->header.descent = read16inc(data, &offset);
+    log_header->header.ascent_time = read32inc(data, &offset)*1000;
+    log_header->header.descent_time = read32inc(data, &offset)*1000;
+    log_header->header.recovery_time = read16inc(data, &offset)*60*1000;
+    log_header->header.peak_training_effect = read8inc(data, &offset);
+    if (log_header->header.activity_name) {
+        free(log_header->header.activity_name);
+    }
+    log_header->header.activity_name = utf8memconv((const char*)(data + offset), 16, "ISO-8859-15");
+    log_header->header.distance = read32inc(data, &offset);
+    log_header->header.energy_consumption = read16inc(data, &offset);
+
+    return 0;
+}
+
+static int get_memory_maps(ambit_object_t *object)
+{
+    uint8_t *reply_data = NULL;
+    size_t replylen = 0;
+    uint8_t send_data[4] = { 0x00, 0x00, 0x00, 0x00 };
+    libambit_sbem0102_data_t reply_data_object;
+    memory_map_entry_t *mm_entry;
+    const uint8_t *ptr;
+
+    if (libambit_protocol_command(object, ambit_command_unknown2, NULL, 0, &reply_data, &replylen, 2) != 0 || replylen < 4) {
+        libambit_protocol_free(reply_data);
+        LOG_WARNING("Failed to read memory map key");
+        return -1;
+    }
+    libambit_protocol_free(reply_data);
+
+    libambit_sbem0102_data_init(&reply_data_object);
+    if (libambit_sbem0102_command_request_raw(&object->driver_data->sbem0102, ambit_command_ambit3_memory_map, send_data, sizeof(send_data), &reply_data_object) != 0) {
+        LOG_WARNING("Failed to read memory map");
+        return -1;
+    }
+
+    while (libambit_sbem0102_data_next(&reply_data_object) == 0) {
+        if (libambit_sbem0102_data_id(&reply_data_object) == 0x3f) {
+            ptr = libambit_sbem0102_data_ptr(&reply_data_object);
+            mm_entry = NULL;
+            if (strcmp((char*)ptr, "Waypoints") == 0) {
+                mm_entry = &object->driver_data->memory_maps.waypoints;
+            }
+            else if (strcmp((char*)ptr, "Routes") == 0) {
+                mm_entry = &object->driver_data->memory_maps.waypoints;
+            }
+            else if (strcmp((char*)ptr, "Rules") == 0) {
+                mm_entry = &object->driver_data->memory_maps.rules;
+            }
+            else if (strcmp((char*)ptr, "GpsSGEE") == 0) {
+                mm_entry = &object->driver_data->memory_maps.gps;
+            }
+            else if (strcmp((char*)ptr, "CustomModes") == 0) {
+                mm_entry = &object->driver_data->memory_maps.custom_modes;
+            }
+            else if (strcmp((char*)ptr, "TrainingProgram") == 0) {
+                mm_entry = &object->driver_data->memory_maps.training_program;
+            }
+            else if (strcmp((char*)ptr, "ExerciseLog") == 0) {
+                mm_entry = &object->driver_data->memory_maps.excercise_log;
+            }
+            else if (strcmp((char*)ptr, "EventLog") == 0) {
+                mm_entry = &object->driver_data->memory_maps.event_log;
+            }
+            else if (strcmp((char*)ptr, "BlePairingInfo") == 0) {
+                mm_entry = &object->driver_data->memory_maps.ble_pairing;
+            }
+            else {
+                LOG_WARNING("Unknown memory map type \"%s\"", (char*)ptr);
+            }
+
+            if (mm_entry != NULL) {
+                // We have dealed with the name, advance to hash
+                ptr += strlen((char*)ptr) + 1;
+
+                if (libambit_htob((const char*)ptr, mm_entry->hash, sizeof(mm_entry->hash)) < 0) {
+                    LOG_ERROR("Failed to read memory map hash");
+                }
+                ptr += strlen((char*)ptr) + 1;
+
+                mm_entry->start = read32(ptr, 0);
+                ptr += 4;
+                mm_entry->size = read32(ptr, 0);
+            }
+        }
+    }
+
+    object->driver_data->memory_maps.initialized = 1;
+    libambit_sbem0102_data_free(&reply_data_object);
+
+    LOG_INFO("Memory map successfully parsed");
+
+    return 0;
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/device_driver_ambit.c ../openambit.git/src/libambit/device_driver_ambit.c
--- ./src/libambit/device_driver_ambit.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_driver_ambit.c	2015-03-20 20:47:45.908512152 +0100
@@ -0,0 +1,299 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include "device_driver.h"
+#include "device_driver_common.h"
+#include "libambit_int.h"
+#include "protocol.h"
+#include "pmem20.h"
+#include "personal.h"
+#include "debug.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+/*
+ * Local definitions
+ */
+#define PMEM20_LOG_START                  0x000f4240
+#define PMEM20_LOG_SIZE                   0x0029f630 /* 2 750 000 */
+
+struct ambit_device_driver_data_s {
+    libambit_pmem20_t pmem20;
+};
+
+/*
+ * Static functions
+ */
+static void init(ambit_object_t *object, uint32_t driver_param);
+static void deinit(ambit_object_t *object);
+static int personal_settings_get(ambit_object_t *object, ambit_personal_settings_t *settings);
+static int log_read(ambit_object_t *object, ambit_log_skip_cb skip_cb, ambit_log_push_cb push_cb, ambit_log_progress_cb progress_cb, void *userref);
+static int gps_orbit_header_read(ambit_object_t *object, uint8_t data[8]);
+static int gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen);
+
+/*
+ * Global variables
+ */
+ambit_device_driver_t ambit_device_driver_ambit = {
+    init,
+    deinit,
+    libambit_device_driver_lock_log,
+    libambit_device_driver_date_time_set,
+    libambit_device_driver_status_get,
+    personal_settings_get,
+    log_read,
+    gps_orbit_header_read,
+    gps_orbit_write
+};
+
+/*
+ * Static functions implementation
+ */
+/**
+ * Init function
+ * \param object to initialize
+ * \param driver_param PMEM20 chunk size
+ */
+static void init(ambit_object_t *object, uint32_t driver_param)
+{
+    struct ambit_device_driver_data_s *data;
+
+    if ((data = calloc(1, sizeof(struct ambit_device_driver_data_s))) != NULL) {
+        object->driver_data = data;
+        libambit_pmem20_init(&object->driver_data->pmem20, object, driver_param);
+    }
+}
+
+static void deinit(ambit_object_t *object)
+{
+    if (object->driver_data != NULL) {
+        libambit_pmem20_deinit(&object->driver_data->pmem20);
+    }
+}
+
+static int personal_settings_get(ambit_object_t *object, ambit_personal_settings_t *settings)
+{
+    uint8_t *reply_data = NULL;
+    size_t replylen = 0;
+    int ret = -1;
+
+    LOG_INFO("Reading personal settings");
+
+    if (libambit_protocol_command(object, ambit_command_personal_settings, NULL, 0, &reply_data, &replylen, 0) == 0) {
+        ret = libambit_personal_settings_parse(reply_data, replylen, settings);
+        libambit_protocol_free(reply_data);
+    }
+    else {
+        LOG_WARNING("Failed to read personal settings");
+    }
+
+    return ret;
+}
+
+static int log_read(ambit_object_t *object, ambit_log_skip_cb skip_cb, ambit_log_push_cb push_cb, ambit_log_progress_cb progress_cb, void *userref)
+{
+    int entries_read = 0;
+
+    uint8_t *reply_data = NULL;
+    size_t replylen = 0;
+    uint16_t log_entries_total = 0;
+    uint16_t log_entries_walked = 0;
+
+    uint32_t more = 0x00000400;
+
+    bool read_pmem = false;
+
+    ambit_log_header_t log_header;
+    ambit_log_entry_t *log_entry;
+
+    LOG_INFO("Reading number of logs");
+    log_header.activity_name = NULL;
+
+    /*
+     * Read number of log entries
+     */
+    if (libambit_protocol_command(object, ambit_command_log_count, NULL, 0, &reply_data, &replylen, 0) != 0) {
+        LOG_WARNING("Failed to read number of log entries");
+        return -1;
+    }
+    log_entries_total = le16toh(*(uint16_t*)(reply_data + 2));
+    libambit_protocol_free(reply_data);
+
+    LOG_INFO("Number of logs=%d", log_entries_total);
+
+    /*
+     * First part walks through headers to check if there is any point in start
+     * reading the PMEM content. If no skip callback is defined, there is no
+     * point in checking the headers, because no one can tell us to not include
+     * the logs...
+     */
+
+    if (skip_cb != NULL) {
+        LOG_INFO("Look in headers for new logs");
+        // Rewind
+        if (libambit_protocol_command(object, ambit_command_log_head_first, NULL, 0, &reply_data, &replylen, 0) != 0) {
+            LOG_WARNING("Failed to rewind header pointer");
+            return -1;
+        }
+        more = le32toh(*(uint32_t*)reply_data);
+        libambit_protocol_free(reply_data);
+
+        // Loop through logs while more entries exists
+        while (more == 0x00000400) {
+            LOG_INFO("Reading next header");
+            // Go to next entry
+            if (libambit_protocol_command(object, ambit_command_log_head_step, NULL, 0, &reply_data, &replylen, 0) != 0) {
+                LOG_WARNING("Failed to walk to next header");
+                return -1;
+            }
+            libambit_protocol_free(reply_data);
+
+            // Assume every header is composited by 2 parts, where only the
+            // second is of interrest right now
+            if (libambit_protocol_command(object, ambit_command_log_head, NULL, 0, &reply_data, &replylen, 0) != 0) {
+                LOG_WARNING("Failed to read first part of header");
+                return -1;
+            }
+            libambit_protocol_free(reply_data);
+
+            if (libambit_protocol_command(object, ambit_command_log_head, NULL, 0, &reply_data, &replylen, 0) == 0) {
+                if (replylen > 8 && libambit_pmem20_log_parse_header(reply_data + 8, replylen - 8, &log_header) == 0) {
+                    if (skip_cb(userref, &log_header) != 0) {
+                        // Header was NOT skipped, break out!
+                        read_pmem = true;
+                        LOG_INFO("Found new entry, start reading log data");
+                        break;
+                    }
+                }
+                else {
+                    LOG_ERROR("Failed to parse log header");
+                    return -1;
+                }
+                libambit_protocol_free(reply_data);
+            }
+            else {
+                LOG_WARNING("Failed to read second part of header");
+                return -1;
+            }
+
+            // Is there more entries to read?
+            if (libambit_protocol_command(object, ambit_command_log_head_peek, NULL, 0, &reply_data, &replylen, 0) != 0) {
+                LOG_WARNING("Failed to check for more headers");
+                return -1;
+            }
+            more = le32toh(*(uint32_t*)reply_data);
+            libambit_protocol_free(reply_data);
+        }
+    }
+    else {
+        LOG_INFO("No skip callback defined, reading log data");
+        read_pmem = true;
+    }
+
+    if (read_pmem) {
+        if (libambit_pmem20_log_init(&object->driver_data->pmem20, PMEM20_LOG_START, PMEM20_LOG_SIZE) != 0) {
+            return -1;
+        }
+
+        // Loop through all log entries, first check headers
+        while (log_entries_walked < log_entries_total && libambit_pmem20_log_next_header(&object->driver_data->pmem20, &log_header) == 1) {
+            LOG_INFO("Reading header of log %d of %d", log_entries_walked + 1, log_entries_total);
+            if (progress_cb != NULL) {
+                progress_cb(userref, log_entries_total, log_entries_walked+1, 100*log_entries_walked/log_entries_total);
+            }
+            // Check if this entry needs to be read
+            if (skip_cb == NULL || skip_cb(userref, &log_header) != 0) {
+                LOG_INFO("Reading data of log %d of %d", log_entries_walked + 1, log_entries_total);
+                log_entry = libambit_pmem20_log_read_entry(&object->driver_data->pmem20);
+                if (log_entry != NULL) {
+                    if (push_cb != NULL) {
+                        push_cb(userref, log_entry);
+                    }
+                    entries_read++;
+                }
+            }
+            else {
+                LOG_INFO("Log %d of %d already exists, skip reading data", log_entries_walked + 1, log_entries_total);
+            }
+            log_entries_walked++;
+            if (progress_cb != NULL) {
+                progress_cb(userref, log_entries_total, log_entries_walked, 100*log_entries_walked/log_entries_total);
+            }
+        }
+    }
+
+    LOG_INFO("%d entries read", entries_read);
+
+    return entries_read;
+}
+
+static int gps_orbit_header_read(ambit_object_t *object, uint8_t data[8])
+{
+    uint8_t *reply_data = NULL;
+    size_t replylen = 0;
+    int ret = -1;
+
+    if (libambit_protocol_command(object, ambit_command_gps_orbit_head, NULL, 0, &reply_data, &replylen, 0) == 0 && replylen >= 9) {
+        memcpy(data, &reply_data[1], 8);
+        libambit_protocol_free(reply_data);
+
+        ret = 0;
+    }
+    else {
+        LOG_WARNING("Failed to read GPS orbit header");
+    }
+
+    return ret;
+}
+
+static int gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen)
+{
+    uint8_t header[8], cmpheader[8];
+    int ret = -1;
+
+    LOG_INFO("Writing GPS orbit data");
+
+    libambit_protocol_command(object, ambit_command_write_start, NULL, 0, NULL, NULL, 0);
+
+    if (object->driver->gps_orbit_header_read(object, header) == 0) {
+        cmpheader[0] = data[7]; // Year, swap bytes
+        cmpheader[1] = data[6];
+        cmpheader[2] = data[8];
+        cmpheader[3] = data[9];
+        cmpheader[4] = data[13]; // 4 byte swap
+        cmpheader[5] = data[12];
+        cmpheader[6] = data[11];
+        cmpheader[7] = data[10];
+
+        // Check if new data differs 
+        if (memcmp(header, cmpheader, 8) != 0) {
+            ret = libambit_pmem20_gps_orbit_write(&object->driver_data->pmem20, data, datalen, false);
+        }
+        else {
+            LOG_INFO("Current GPS orbit data is already up to date, skipping");
+            ret = 0;
+        }
+    }
+
+    return ret;
+}
+
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/device_driver_common.c ../openambit.git/src/libambit/device_driver_common.c
--- ./src/libambit/device_driver_common.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_driver_common.c	2015-03-20 20:47:45.908512152 +0100
@@ -0,0 +1,127 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include "device_driver_common.h"
+#include "protocol.h"
+#include "debug.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+/*
+ * Local definitions
+ */
+
+/*
+ * Static functions
+ */
+
+/*
+ * Public functions
+ */
+int libambit_device_driver_lock_log(ambit_object_t *object, bool lock)
+{
+    int ret = -1;
+    uint8_t send_data[] = { 0x00, 0x00, 0x00, 0x00 };
+    uint8_t *reply_data = NULL;
+    size_t replylen;
+
+    uint32_t current_lock = 0xffffffff;
+
+    if ((ret = libambit_protocol_command(object, ambit_command_lock_check, NULL, 0, &reply_data, &replylen, 0)) == 0) {
+        current_lock = le32toh(*(uint32_t*)reply_data);
+        libambit_protocol_free(reply_data);
+    }
+
+    if (lock && current_lock == 0) {
+        LOG_INFO("Setting Sync message to device display");
+        send_data[0] = 1;
+        ret = libambit_protocol_command(object, ambit_command_lock_set, send_data, sizeof(send_data), &reply_data, &replylen, 0);
+        libambit_protocol_free(reply_data);
+    }
+    else if (!lock && current_lock == 1) {
+        LOG_INFO("Clearing Sync message to device display");
+        send_data[0] = 0;
+        ret = libambit_protocol_command(object, ambit_command_lock_set, send_data, sizeof(send_data), &reply_data, &replylen, 0);
+        libambit_protocol_free(reply_data);
+    }
+
+    return ret;
+}
+
+int libambit_device_driver_date_time_set(ambit_object_t *object, struct tm *tm)
+{
+    uint8_t date_data[8] = { 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00 };
+    uint8_t time_data[8];
+    uint16_t year = htole16(1900 + tm->tm_year);
+    uint16_t sec = htole16(1000*tm->tm_sec);
+    int ret = -1;
+
+    LOG_INFO("Writing date and time to clock");
+
+    // Set date
+    memcpy(&date_data[0], &year, sizeof(uint16_t));
+    date_data[2] = 1 + tm->tm_mon;
+    date_data[3] = tm->tm_mday;
+    // byte[4-7] unknown (but set to 0x28000000 in moveslink)
+
+    // Set time (+date)
+    memcpy(&time_data[0], &year, sizeof(uint16_t));
+    time_data[2] = 1 + tm->tm_mon;
+    time_data[3] = tm->tm_mday;
+    time_data[4] = tm->tm_hour;
+    time_data[5] = tm->tm_min;
+    memcpy(&time_data[6], &sec, sizeof(uint16_t));
+
+    if (libambit_protocol_command(object, ambit_command_date, date_data, sizeof(date_data), NULL, NULL, 0) == 0 &&
+        libambit_protocol_command(object, ambit_command_time, time_data, sizeof(time_data), NULL, NULL, 0) == 0) {
+
+        ret = 0;
+    }
+    else {
+        LOG_WARNING("Failed to write date and time");
+    }
+
+    return ret;
+}
+
+int libambit_device_driver_status_get(ambit_object_t *object, ambit_device_status_t *status)
+{
+    uint8_t *reply_data = NULL;
+    size_t replylen;
+    int ret = -1;
+
+    LOG_INFO("Reading device status");
+
+    if (libambit_protocol_command(object, ambit_command_status, NULL, 0, &reply_data, &replylen, 0) == 0) {
+        if (status != NULL) {
+            status->charge = reply_data[1];
+        }
+        ret = 0;
+    }
+    else {
+        LOG_WARNING("Failed to read device status");
+    }
+
+    libambit_protocol_free(reply_data);
+
+    return ret;
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/device_driver_common.h ../openambit.git/src/libambit/device_driver_common.h
--- ./src/libambit/device_driver_common.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_driver_common.h	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __DEVICE_DRIVER_COMMON_H__
+#define __DEVICE_DRIVER_COMMON_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <time.h>
+
+#include "libambit.h"
+
+int libambit_device_driver_lock_log(ambit_object_t *object, bool lock);
+int libambit_device_driver_date_time_set(ambit_object_t *object, struct tm *tm);
+int libambit_device_driver_status_get(ambit_object_t *object, ambit_device_status_t *status);
+
+#endif /* DEVICE_DRIVER_COMMON */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/device_driver.h ../openambit.git/src/libambit/device_driver.h
--- ./src/libambit/device_driver.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_driver.h	2015-03-20 20:47:45.908512152 +0100
@@ -0,0 +1,45 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __DEVICE_DRIVER_H__
+#define __DEVICE_DRIVER_H__
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "libambit.h"
+
+typedef struct ambit_device_driver_s {
+    void (*init)(ambit_object_t *object, uint32_t driver_param);
+    void (*deinit)(ambit_object_t *object);
+    int (*lock_log)(ambit_object_t *object, bool lock);
+    int (*date_time_set)(ambit_object_t *object, struct tm *tm);
+    int (*status_get)(ambit_object_t *object, ambit_device_status_t *status);
+    int (*personal_settings_get)(ambit_object_t *object, ambit_personal_settings_t *settings);
+    int (*log_read)(ambit_object_t *object, ambit_log_skip_cb skip_cb, ambit_log_push_cb push_cb, ambit_log_progress_cb progress_cb, void *userref);
+    int (*gps_orbit_header_read)(ambit_object_t *object, uint8_t data[8]);
+    int (*gps_orbit_write)(ambit_object_t *object, uint8_t *data, size_t datalen);
+} ambit_device_driver_t;
+
+extern ambit_device_driver_t ambit_device_driver_ambit;  // Ambit & Ambit2
+extern ambit_device_driver_t ambit_device_driver_ambit3; // Ambit3
+
+#endif /* __DEVICE_DRIVER_H__ */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/device_support.c ../openambit.git/src/libambit/device_support.c
--- ./src/libambit/device_support.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_support.c	2015-03-20 20:47:45.908512152 +0100
@@ -0,0 +1,105 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include "device_support.h"
+#include "device_driver.h"
+
+#include <string.h>
+
+/*
+ * Local definitions
+ */
+#define SUUNTO_USB_VENDOR_ID 0x1493
+
+typedef struct int_known_device_s {
+    uint16_t vid;
+    uint16_t pid;
+    char *model;
+    uint8_t min_sw_version[4];
+    ambit_known_device_t public_info;
+} int_known_device_t;
+
+/*
+ * Static functions
+ */
+static uint32_t version_number(const uint8_t version[4]);
+
+/*
+ * Static variables
+ */
+static int_known_device_t known_devices[] = {
+    { SUUNTO_USB_VENDOR_ID, 0x001c, "Finch", {0x00,0x00,0x00,0x00}, { "Suunto Ambit3 Sport", true, &ambit_device_driver_ambit3, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x001b, "Emu", {0x00,0x00,0x00,0x00}, { "Suunto Ambit3 Peak", true, &ambit_device_driver_ambit3, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x001d, "Greentit", {0x00,0x00,0x00,0x00}, { "Suunto Ambit2 R", true, &ambit_device_driver_ambit, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x01,0x01,0x02,0x00}, { "Suunto Ambit2 S", true, &ambit_device_driver_ambit, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x01,0x01,0x02,0x00}, { "Suunto Ambit2", true, &ambit_device_driver_ambit, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x00,0x02,0x03,0x00}, { "Suunto Ambit2 S", false, NULL, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x00,0x02,0x03,0x00}, { "Suunto Ambit2", false, NULL, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x00,0x02,0x02,0x00}, { "Suunto Ambit2 S (up to 0.2.2)", false, NULL, 0x0200 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x00,0x02,0x02,0x00}, { "Suunto Ambit2 (up to 0.2.2)", false, NULL, 0x0200 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x02,0x01,0x00,0x00}, { "Suunto Ambit", true, &ambit_device_driver_ambit, 0x0200 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x09,0x00,0x00}, { "Suunto Ambit", false, NULL, 0x0200 } }, /* First with PMEM 2.0!? */
+    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x06,0x00,0x00}, { "Suunto Ambit", false, NULL, 0 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x01,0x00,0x00}, { "Suunto Ambit", false, NULL, 0 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x00,0x00,0x00,0x00}, { "Suunto Ambit", false, NULL, 0 } },
+    { 0x0000, 0x0000, NULL, {0x00,0x00,0x00,0x00}, { NULL, false, NULL, 0 } }
+};
+
+bool libambit_device_support_known(uint16_t vendor_id, uint16_t product_id)
+{
+    int i;
+
+    for (i=0; i<sizeof(known_devices)/sizeof(known_devices[0]); i++) {
+        if (vendor_id == known_devices[i].vid && product_id == known_devices[i].pid) {
+            // Found at least one row with the correct device
+            return true;
+        }
+    }
+
+    return false;
+}
+
+const ambit_known_device_t *libambit_device_support_find(uint16_t vendor_id, uint16_t product_id, const char *model, const uint8_t *fw_version)
+{
+    ambit_known_device_t *device = NULL;
+    int i;
+
+    for (i=0; i<sizeof(known_devices)/sizeof(known_devices[0]); i++) {
+        if (vendor_id == known_devices[i].vid &&
+            product_id == known_devices[i].pid &&
+            strcmp(model, known_devices[i].model) == 0 &&
+            (version_number (fw_version) >= version_number (known_devices[i].min_sw_version))) {
+            // Found matching entry, reset to this one!
+            device = &known_devices[i].public_info;
+            break;
+        }
+    }
+
+    return device;
+}
+
+static uint32_t version_number(const uint8_t version[4])
+{
+    return (  (version[0] << 24)
+            | (version[1] << 16)
+            | (version[2] <<  0)
+            | (version[3] <<  8));
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/device_support.h ../openambit.git/src/libambit/device_support.h
--- ./src/libambit/device_support.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_support.h	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,39 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __DEVICE_SUPPORT_H__
+#define __DEVICE_SUPPORT_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+typedef struct ambit_known_device_s {
+    char *name;
+    bool supported;
+    struct ambit_device_driver_s *driver;
+    uint32_t driver_param;
+} ambit_known_device_t;
+
+bool libambit_device_support_known(uint16_t vendor_id, uint16_t product_id);
+const ambit_known_device_t *libambit_device_support_find(uint16_t vendor_id, uint16_t product_id, const char *model, const uint8_t *fw_version);
+
+#endif /* __DEVICE_SUPPORT_H__ */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/hidapi/hid-libusb.c ../openambit.git/src/libambit/hidapi/hid-libusb.c
--- ./src/libambit/hidapi/hid-libusb.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/hidapi/hid-libusb.c	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,1427 @@
+/*******************************************************
+ HIDAPI - Multi-Platform library for
+ communication with HID devices.
+
+ Alan Ott
+ Signal 11 Software
+
+ 8/22/2009
+ Linux Version - 6/2/2010
+ Libusb Version - 8/13/2010
+ FreeBSD Version - 11/1/2011
+
+ Copyright 2009, All Rights Reserved.
+
+ At the discretion of the user of this library,
+ this software may be licensed under the terms of the
+ GNU General Public License v3, a BSD-Style license, or the
+ original HIDAPI license as outlined in the LICENSE.txt,
+ LICENSE-gpl3.txt, LICENSE-bsd.txt, and LICENSE-orig.txt
+ files located at the root of the source distribution.
+ These files may also be found in the public source
+ code repository located at:
+        http://github.com/signal11/hidapi .
+********************************************************/
+
+#define _GNU_SOURCE /* needed for wcsdup() before glibc 2.10 */
+
+/* C */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <locale.h>
+#include <errno.h>
+
+/* Unix */
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/utsname.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <wchar.h>
+
+/* GNU / LibUSB */
+#include "libusb.h"
+#include "iconv.h"
+
+#include "hidapi.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef DEBUG_PRINTF
+#define LOG(...) fprintf(stderr, __VA_ARGS__)
+#else
+#define LOG(...) do {} while (0)
+#endif
+
+#ifndef __FreeBSD__
+#define DETACH_KERNEL_DRIVER
+#endif
+
+/* Uncomment to enable the retrieval of Usage and Usage Page in
+hid_enumerate(). Warning, on platforms different from FreeBSD
+this is very invasive as it requires the detach
+and re-attach of the kernel driver. See comments inside hid_enumerate().
+libusb HIDAPI programs are encouraged to use the interface number
+instead to differentiate between interfaces on a composite HID device. */
+/*#define INVASIVE_GET_USAGE*/
+
+/* Linked List of input reports received from the device. */
+struct input_report {
+	uint8_t *data;
+	size_t len;
+	struct input_report *next;
+};
+
+
+struct hid_device_ {
+	/* Handle to the actual device. */
+	libusb_device_handle *device_handle;
+
+	/* Endpoint information */
+	int input_endpoint;
+	int output_endpoint;
+	int input_ep_max_packet_size;
+
+	/* The interface number of the HID */
+	int interface;
+
+	/* Indexes of Strings */
+	int manufacturer_index;
+	int product_index;
+	int serial_index;
+
+	/* Whether blocking reads are used */
+	int blocking; /* boolean */
+
+	/* Read thread objects */
+	pthread_t thread;
+	pthread_mutex_t mutex; /* Protects input_reports */
+	pthread_cond_t condition;
+	pthread_barrier_t barrier; /* Ensures correct startup sequence */
+	int shutdown_thread;
+	int cancelled;
+	struct libusb_transfer *transfer;
+
+	/* List of received input reports. */
+	struct input_report *input_reports;
+};
+
+static libusb_context *usb_context = NULL;
+
+uint16_t get_usb_code_for_current_locale(void);
+static int return_data(hid_device *dev, unsigned char *data, size_t length);
+
+static hid_device *new_hid_device(void)
+{
+	hid_device *dev = calloc(1, sizeof(hid_device));
+	dev->blocking = 1;
+
+	pthread_mutex_init(&dev->mutex, NULL);
+	pthread_cond_init(&dev->condition, NULL);
+	pthread_barrier_init(&dev->barrier, NULL, 2);
+
+	return dev;
+}
+
+static void free_hid_device(hid_device *dev)
+{
+	/* Clean up the thread objects */
+	pthread_barrier_destroy(&dev->barrier);
+	pthread_cond_destroy(&dev->condition);
+	pthread_mutex_destroy(&dev->mutex);
+
+	/* Free the device itself */
+	free(dev);
+}
+
+#if 0
+/*TODO: Implement this funciton on hidapi/libusb.. */
+static void register_error(hid_device *device, const char *op)
+{
+
+}
+#endif
+
+#ifdef INVASIVE_GET_USAGE
+/* Get bytes from a HID Report Descriptor.
+   Only call with a num_bytes of 0, 1, 2, or 4. */
+static uint32_t get_bytes(uint8_t *rpt, size_t len, size_t num_bytes, size_t cur)
+{
+	/* Return if there aren't enough bytes. */
+	if (cur + num_bytes >= len)
+		return 0;
+
+	if (num_bytes == 0)
+		return 0;
+	else if (num_bytes == 1) {
+		return rpt[cur+1];
+	}
+	else if (num_bytes == 2) {
+		return (rpt[cur+2] * 256 + rpt[cur+1]);
+	}
+	else if (num_bytes == 4) {
+		return (rpt[cur+4] * 0x01000000 +
+		        rpt[cur+3] * 0x00010000 +
+		        rpt[cur+2] * 0x00000100 +
+		        rpt[cur+1] * 0x00000001);
+	}
+	else
+		return 0;
+}
+
+/* Retrieves the device's Usage Page and Usage from the report
+   descriptor. The algorithm is simple, as it just returns the first
+   Usage and Usage Page that it finds in the descriptor.
+   The return value is 0 on success and -1 on failure. */
+static int get_usage(uint8_t *report_descriptor, size_t size,
+                     unsigned short *usage_page, unsigned short *usage)
+{
+	unsigned int i = 0;
+	int size_code;
+	int data_len, key_size;
+	int usage_found = 0, usage_page_found = 0;
+
+	while (i < size) {
+		int key = report_descriptor[i];
+		int key_cmd = key & 0xfc;
+
+		//printf("key: %02hhx\n", key);
+
+		if ((key & 0xf0) == 0xf0) {
+			/* This is a Long Item. The next byte contains the
+			   length of the data section (value) for this key.
+			   See the HID specification, version 1.11, section
+			   6.2.2.3, titled "Long Items." */
+			if (i+1 < size)
+				data_len = report_descriptor[i+1];
+			else
+				data_len = 0; /* malformed report */
+			key_size = 3;
+		}
+		else {
+			/* This is a Short Item. The bottom two bits of the
+			   key contain the size code for the data section
+			   (value) for this key.  Refer to the HID
+			   specification, version 1.11, section 6.2.2.2,
+			   titled "Short Items." */
+			size_code = key & 0x3;
+			switch (size_code) {
+			case 0:
+			case 1:
+			case 2:
+				data_len = size_code;
+				break;
+			case 3:
+				data_len = 4;
+				break;
+			default:
+				/* Can't ever happen since size_code is & 0x3 */
+				data_len = 0;
+				break;
+			};
+			key_size = 1;
+		}
+
+		if (key_cmd == 0x4) {
+			*usage_page  = get_bytes(report_descriptor, size, data_len, i);
+			usage_page_found = 1;
+			//printf("Usage Page: %x\n", (uint32_t)*usage_page);
+		}
+		if (key_cmd == 0x8) {
+			*usage = get_bytes(report_descriptor, size, data_len, i);
+			usage_found = 1;
+			//printf("Usage: %x\n", (uint32_t)*usage);
+		}
+
+		if (usage_page_found && usage_found)
+			return 0; /* success */
+
+		/* Skip over this key and it's associated data */
+		i += data_len + key_size;
+	}
+
+	return -1; /* failure */
+}
+#endif /* INVASIVE_GET_USAGE */
+
+#ifdef __FreeBSD__
+/* The FreeBSD version of libusb doesn't have this funciton. In mainline
+   libusb, it's inlined in libusb.h. This function will bear a striking
+   resemblence to that one, because there's about one way to code it.
+
+   Note that the data parameter is Unicode in UTF-16LE encoding.
+   Return value is the number of bytes in data, or LIBUSB_ERROR_*.
+ */
+static inline int libusb_get_string_descriptor(libusb_device_handle *dev,
+	uint8_t descriptor_index, uint16_t lang_id,
+	unsigned char *data, int length)
+{
+	return libusb_control_transfer(dev,
+		LIBUSB_ENDPOINT_IN | 0x0, /* Endpoint 0 IN */
+		LIBUSB_REQUEST_GET_DESCRIPTOR,
+		(LIBUSB_DT_STRING << 8) | descriptor_index,
+		lang_id, data, (uint16_t) length, 1000);
+}
+
+#endif
+
+
+/* Get the first language the device says it reports. This comes from
+   USB string #0. */
+static uint16_t get_first_language(libusb_device_handle *dev)
+{
+	uint16_t buf[32];
+	int len;
+
+	/* Get the string from libusb. */
+	len = libusb_get_string_descriptor(dev,
+			0x0, /* String ID */
+			0x0, /* Language */
+			(unsigned char*)buf,
+			sizeof(buf));
+	if (len < 4)
+		return 0x0;
+
+	return buf[1]; /* First two bytes are len and descriptor type. */
+}
+
+static int is_language_supported(libusb_device_handle *dev, uint16_t lang)
+{
+	uint16_t buf[32];
+	int len;
+	int i;
+
+	/* Get the string from libusb. */
+	len = libusb_get_string_descriptor(dev,
+			0x0, /* String ID */
+			0x0, /* Language */
+			(unsigned char*)buf,
+			sizeof(buf));
+	if (len < 4)
+		return 0x0;
+
+
+	len /= 2; /* language IDs are two-bytes each. */
+	/* Start at index 1 because there are two bytes of protocol data. */
+	for (i = 1; i < len; i++) {
+		if (buf[i] == lang)
+			return 1;
+	}
+
+	return 0;
+}
+
+
+/* This function returns a newly allocated wide string containing the USB
+   device string numbered by the index. The returned string must be freed
+   by using free(). */
+static wchar_t *get_usb_string(libusb_device_handle *dev, uint8_t idx)
+{
+	char buf[512];
+	int len;
+	wchar_t *str = NULL;
+	wchar_t wbuf[256];
+
+	/* iconv variables */
+	iconv_t ic;
+	size_t inbytes;
+	size_t outbytes;
+	size_t res;
+#ifdef __FreeBSD__
+	const char *inptr;
+#else
+	char *inptr;
+#endif
+	char *outptr;
+
+	/* Determine which language to use. */
+	uint16_t lang;
+	lang = get_usb_code_for_current_locale();
+	if (!is_language_supported(dev, lang))
+		lang = get_first_language(dev);
+
+	/* Get the string from libusb. */
+	len = libusb_get_string_descriptor(dev,
+			idx,
+			lang,
+			(unsigned char*)buf,
+			sizeof(buf));
+	if (len < 0)
+		return NULL;
+
+	/* buf does not need to be explicitly NULL-terminated because
+	   it is only passed into iconv() which does not need it. */
+
+	/* Initialize iconv. */
+	ic = iconv_open("WCHAR_T", "UTF-16LE");
+	if (ic == (iconv_t)-1) {
+		LOG("iconv_open() failed\n");
+		return NULL;
+	}
+
+	/* Convert to native wchar_t (UTF-32 on glibc/BSD systems).
+	   Skip the first character (2-bytes). */
+	inptr = buf+2;
+	inbytes = len-2;
+	outptr = (char*) wbuf;
+	outbytes = sizeof(wbuf);
+	res = iconv(ic, &inptr, &inbytes, &outptr, &outbytes);
+	if (res == (size_t)-1) {
+		LOG("iconv() failed\n");
+		goto err;
+	}
+
+	/* Write the terminating NULL. */
+	wbuf[sizeof(wbuf)/sizeof(wbuf[0])-1] = 0x00000000;
+	if (outbytes >= sizeof(wbuf[0]))
+		*((wchar_t*)outptr) = 0x00000000;
+
+	/* Allocate and copy the string. */
+	str = wcsdup(wbuf);
+
+err:
+	iconv_close(ic);
+
+	return str;
+}
+
+static char *make_path(libusb_device *dev, int interface_number)
+{
+	char str[64];
+	snprintf(str, sizeof(str), "%04x:%04x:%02x",
+		libusb_get_bus_number(dev),
+		libusb_get_device_address(dev),
+		interface_number);
+	str[sizeof(str)-1] = '\0';
+
+	return strdup(str);
+}
+
+
+int HID_API_EXPORT hid_init(void)
+{
+	if (!usb_context) {
+		const char *locale;
+
+		/* Init Libusb */
+		if (libusb_init(&usb_context))
+			return -1;
+
+		/* Set the locale if it's not set. */
+		locale = setlocale(LC_CTYPE, NULL);
+		if (!locale)
+			setlocale(LC_CTYPE, "");
+	}
+
+	return 0;
+}
+
+int HID_API_EXPORT hid_exit(void)
+{
+	if (usb_context) {
+		libusb_exit(usb_context);
+		usb_context = NULL;
+	}
+
+	return 0;
+}
+
+struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id, unsigned short product_id)
+{
+	libusb_device **devs;
+	libusb_device *dev;
+	libusb_device_handle *handle;
+	ssize_t num_devs;
+	int i = 0;
+
+	struct hid_device_info *root = NULL; /* return object */
+	struct hid_device_info *cur_dev = NULL;
+
+	if(hid_init() < 0)
+		return NULL;
+
+	num_devs = libusb_get_device_list(usb_context, &devs);
+	if (num_devs < 0)
+		return NULL;
+	while ((dev = devs[i++]) != NULL) {
+		struct libusb_device_descriptor desc;
+		struct libusb_config_descriptor *conf_desc = NULL;
+		int j, k;
+		int interface_num = 0;
+
+		int res = libusb_get_device_descriptor(dev, &desc);
+		unsigned short dev_vid = desc.idVendor;
+		unsigned short dev_pid = desc.idProduct;
+
+		res = libusb_get_active_config_descriptor(dev, &conf_desc);
+		if (res < 0)
+			libusb_get_config_descriptor(dev, 0, &conf_desc);
+		if (conf_desc) {
+			for (j = 0; j < conf_desc->bNumInterfaces; j++) {
+				const struct libusb_interface *intf = &conf_desc->interface[j];
+				for (k = 0; k < intf->num_altsetting; k++) {
+					const struct libusb_interface_descriptor *intf_desc;
+					intf_desc = &intf->altsetting[k];
+					if (intf_desc->bInterfaceClass == LIBUSB_CLASS_HID) {
+						interface_num = intf_desc->bInterfaceNumber;
+
+						/* Check the VID/PID against the arguments */
+						if ((vendor_id == 0x0 || vendor_id == dev_vid) &&
+						    (product_id == 0x0 || product_id == dev_pid)) {
+							struct hid_device_info *tmp;
+
+							/* VID/PID match. Create the record. */
+							tmp = calloc(1, sizeof(struct hid_device_info));
+							if (cur_dev) {
+								cur_dev->next = tmp;
+							}
+							else {
+								root = tmp;
+							}
+							cur_dev = tmp;
+
+							/* Fill out the record */
+							cur_dev->next = NULL;
+							cur_dev->path = make_path(dev, interface_num);
+
+							res = libusb_open(dev, &handle);
+
+							if (res >= 0) {
+								/* Serial Number */
+								if (desc.iSerialNumber > 0)
+									cur_dev->serial_number =
+										get_usb_string(handle, desc.iSerialNumber);
+
+								/* Manufacturer and Product strings */
+								if (desc.iManufacturer > 0)
+									cur_dev->manufacturer_string =
+										get_usb_string(handle, desc.iManufacturer);
+								if (desc.iProduct > 0)
+									cur_dev->product_string =
+										get_usb_string(handle, desc.iProduct);
+
+#ifdef INVASIVE_GET_USAGE
+{
+							/*
+							This section is removed because it is too
+							invasive on the system. Getting a Usage Page
+							and Usage requires parsing the HID Report
+							descriptor. Getting a HID Report descriptor
+							involves claiming the interface. Claiming the
+							interface involves detaching the kernel driver.
+							Detaching the kernel driver is hard on the system
+							because it will unclaim interfaces (if another
+							app has them claimed) and the re-attachment of
+							the driver will sometimes change /dev entry names.
+							It is for these reasons that this section is
+							#if 0. For composite devices, use the interface
+							field in the hid_device_info struct to distinguish
+							between interfaces. */
+								unsigned char data[256];
+#ifdef DETACH_KERNEL_DRIVER
+								int detached = 0;
+								/* Usage Page and Usage */
+								res = libusb_kernel_driver_active(handle, interface_num);
+								if (res == 1) {
+									res = libusb_detach_kernel_driver(handle, interface_num);
+									if (res < 0)
+										LOG("Couldn't detach kernel driver, even though a kernel driver was attached.");
+									else
+										detached = 1;
+								}
+#endif
+								res = libusb_claim_interface(handle, interface_num);
+								if (res >= 0) {
+									/* Get the HID Report Descriptor. */
+									res = libusb_control_transfer(handle, LIBUSB_ENDPOINT_IN|LIBUSB_RECIPIENT_INTERFACE, LIBUSB_REQUEST_GET_DESCRIPTOR, (LIBUSB_DT_REPORT << 8)|interface_num, 0, data, sizeof(data), 5000);
+									if (res >= 0) {
+										unsigned short page=0, usage=0;
+										/* Parse the usage and usage page
+										   out of the report descriptor. */
+										get_usage(data, res,  &page, &usage);
+										cur_dev->usage_page = page;
+										cur_dev->usage = usage;
+									}
+									else
+										LOG("libusb_control_transfer() for getting the HID report failed with %d\n", res);
+
+									/* Release the interface */
+									res = libusb_release_interface(handle, interface_num);
+									if (res < 0)
+										LOG("Can't release the interface.\n");
+								}
+								else
+									LOG("Can't claim interface %d\n", res);
+#ifdef DETACH_KERNEL_DRIVER
+								/* Re-attach kernel driver if necessary. */
+								if (detached) {
+									res = libusb_attach_kernel_driver(handle, interface_num);
+									if (res < 0)
+										LOG("Couldn't re-attach kernel driver.\n");
+								}
+#endif
+}
+#endif /* INVASIVE_GET_USAGE */
+
+								libusb_close(handle);
+							}
+							/* VID/PID */
+							cur_dev->vendor_id = dev_vid;
+							cur_dev->product_id = dev_pid;
+
+							/* Release Number */
+							cur_dev->release_number = desc.bcdDevice;
+
+							/* Interface Number */
+							cur_dev->interface_number = interface_num;
+						}
+					}
+				} /* altsettings */
+			} /* interfaces */
+			libusb_free_config_descriptor(conf_desc);
+		}
+	}
+
+	libusb_free_device_list(devs, 1);
+
+	return root;
+}
+
+void  HID_API_EXPORT hid_free_enumeration(struct hid_device_info *devs)
+{
+	struct hid_device_info *d = devs;
+	while (d) {
+		struct hid_device_info *next = d->next;
+		free(d->path);
+		free(d->serial_number);
+		free(d->manufacturer_string);
+		free(d->product_string);
+		free(d);
+		d = next;
+	}
+}
+
+hid_device * hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number)
+{
+	struct hid_device_info *devs, *cur_dev;
+	const char *path_to_open = NULL;
+	hid_device *handle = NULL;
+
+	devs = hid_enumerate(vendor_id, product_id);
+	cur_dev = devs;
+	while (cur_dev) {
+		if (cur_dev->vendor_id == vendor_id &&
+		    cur_dev->product_id == product_id) {
+			if (serial_number) {
+				if (wcscmp(serial_number, cur_dev->serial_number) == 0) {
+					path_to_open = cur_dev->path;
+					break;
+				}
+			}
+			else {
+				path_to_open = cur_dev->path;
+				break;
+			}
+		}
+		cur_dev = cur_dev->next;
+	}
+
+	if (path_to_open) {
+		/* Open the device */
+		handle = hid_open_path(path_to_open);
+	}
+
+	hid_free_enumeration(devs);
+
+	return handle;
+}
+
+static void read_callback(struct libusb_transfer *transfer)
+{
+	hid_device *dev = transfer->user_data;
+	int res;
+
+	if (transfer->status == LIBUSB_TRANSFER_COMPLETED) {
+
+		struct input_report *rpt = malloc(sizeof(*rpt));
+		rpt->data = malloc(transfer->actual_length);
+		memcpy(rpt->data, transfer->buffer, transfer->actual_length);
+		rpt->len = transfer->actual_length;
+		rpt->next = NULL;
+
+		pthread_mutex_lock(&dev->mutex);
+
+		/* Attach the new report object to the end of the list. */
+		if (dev->input_reports == NULL) {
+			/* The list is empty. Put it at the root. */
+			dev->input_reports = rpt;
+			pthread_cond_signal(&dev->condition);
+		}
+		else {
+			/* Find the end of the list and attach. */
+			struct input_report *cur = dev->input_reports;
+			int num_queued = 0;
+			while (cur->next != NULL) {
+				cur = cur->next;
+				num_queued++;
+			}
+			cur->next = rpt;
+
+			/* Pop one off if we've reached 30 in the queue. This
+			   way we don't grow forever if the user never reads
+			   anything from the device. */
+			if (num_queued > 30) {
+				return_data(dev, NULL, 0);
+			}
+		}
+		pthread_mutex_unlock(&dev->mutex);
+	}
+	else if (transfer->status == LIBUSB_TRANSFER_CANCELLED) {
+		dev->shutdown_thread = 1;
+		dev->cancelled = 1;
+		return;
+	}
+	else if (transfer->status == LIBUSB_TRANSFER_NO_DEVICE) {
+		dev->shutdown_thread = 1;
+		dev->cancelled = 1;
+		return;
+	}
+	else if (transfer->status == LIBUSB_TRANSFER_TIMED_OUT) {
+		//LOG("Timeout (normal)\n");
+	}
+	else {
+		LOG("Unknown transfer code: %d\n", transfer->status);
+	}
+
+	/* Re-submit the transfer object. */
+	res = libusb_submit_transfer(transfer);
+	if (res != 0) {
+		LOG("Unable to submit URB. libusb error code: %d\n", res);
+		dev->shutdown_thread = 1;
+		dev->cancelled = 1;
+	}
+}
+
+
+static void *read_thread(void *param)
+{
+	hid_device *dev = param;
+	unsigned char *buf;
+	const size_t length = dev->input_ep_max_packet_size;
+
+	/* Set up the transfer object. */
+	buf = malloc(length);
+	dev->transfer = libusb_alloc_transfer(0);
+	libusb_fill_interrupt_transfer(dev->transfer,
+		dev->device_handle,
+		dev->input_endpoint,
+		buf,
+		length,
+		read_callback,
+		dev,
+		5000/*timeout*/);
+
+	/* Make the first submission. Further submissions are made
+	   from inside read_callback() */
+	libusb_submit_transfer(dev->transfer);
+
+	/* Notify the main thread that the read thread is up and running. */
+	pthread_barrier_wait(&dev->barrier);
+
+	/* Handle all the events. */
+	while (!dev->shutdown_thread) {
+		int res;
+		res = libusb_handle_events(usb_context);
+		if (res < 0) {
+			/* There was an error. */
+			LOG("read_thread(): libusb reports error # %d\n", res);
+
+			/* Break out of this loop only on fatal error.*/
+			if (res != LIBUSB_ERROR_BUSY &&
+			    res != LIBUSB_ERROR_TIMEOUT &&
+			    res != LIBUSB_ERROR_OVERFLOW &&
+			    res != LIBUSB_ERROR_INTERRUPTED) {
+				break;
+			}
+		}
+	}
+
+	/* Cancel any transfer that may be pending. This call will fail
+	   if no transfers are pending, but that's OK. */
+	libusb_cancel_transfer(dev->transfer);
+
+	while (!dev->cancelled)
+		libusb_handle_events_completed(usb_context, &dev->cancelled);
+
+	/* Now that the read thread is stopping, Wake any threads which are
+	   waiting on data (in hid_read_timeout()). Do this under a mutex to
+	   make sure that a thread which is about to go to sleep waiting on
+	   the condition acutally will go to sleep before the condition is
+	   signaled. */
+	pthread_mutex_lock(&dev->mutex);
+	pthread_cond_broadcast(&dev->condition);
+	pthread_mutex_unlock(&dev->mutex);
+
+	/* The dev->transfer->buffer and dev->transfer objects are cleaned up
+	   in hid_close(). They are not cleaned up here because this thread
+	   could end either due to a disconnect or due to a user
+	   call to hid_close(). In both cases the objects can be safely
+	   cleaned up after the call to pthread_join() (in hid_close()), but
+	   since hid_close() calls libusb_cancel_transfer(), on these objects,
+	   they can not be cleaned up here. */
+
+	return NULL;
+}
+
+
+hid_device * HID_API_EXPORT hid_open_path(const char *path)
+{
+	hid_device *dev = NULL;
+
+	libusb_device **devs;
+	libusb_device *usb_dev;
+	int res;
+	int d = 0;
+	int good_open = 0;
+
+	if(hid_init() < 0)
+		return NULL;
+
+	dev = new_hid_device();
+
+	libusb_get_device_list(usb_context, &devs);
+	while ((usb_dev = devs[d++]) != NULL) {
+		struct libusb_device_descriptor desc;
+		struct libusb_config_descriptor *conf_desc = NULL;
+		int i,j,k;
+		libusb_get_device_descriptor(usb_dev, &desc);
+
+		if (libusb_get_active_config_descriptor(usb_dev, &conf_desc) < 0)
+			continue;
+		for (j = 0; j < conf_desc->bNumInterfaces; j++) {
+			const struct libusb_interface *intf = &conf_desc->interface[j];
+			for (k = 0; k < intf->num_altsetting; k++) {
+				const struct libusb_interface_descriptor *intf_desc;
+				intf_desc = &intf->altsetting[k];
+				if (intf_desc->bInterfaceClass == LIBUSB_CLASS_HID) {
+					char *dev_path = make_path(usb_dev, intf_desc->bInterfaceNumber);
+					if (!strcmp(dev_path, path)) {
+						/* Matched Paths. Open this device */
+
+						/* OPEN HERE */
+						res = libusb_open(usb_dev, &dev->device_handle);
+						if (res < 0) {
+							LOG("can't open device\n");
+							free(dev_path);
+							break;
+						}
+						good_open = 1;
+#ifdef DETACH_KERNEL_DRIVER
+						/* Detach the kernel driver, but only if the
+						   device is managed by the kernel */
+						if (libusb_kernel_driver_active(dev->device_handle, intf_desc->bInterfaceNumber) == 1) {
+							res = libusb_detach_kernel_driver(dev->device_handle, intf_desc->bInterfaceNumber);
+							if (res < 0) {
+								libusb_close(dev->device_handle);
+								LOG("Unable to detach Kernel Driver\n");
+								free(dev_path);
+								good_open = 0;
+								break;
+							}
+						}
+#endif
+						res = libusb_claim_interface(dev->device_handle, intf_desc->bInterfaceNumber);
+						if (res < 0) {
+							LOG("can't claim interface %d: %d\n", intf_desc->bInterfaceNumber, res);
+							free(dev_path);
+							libusb_close(dev->device_handle);
+							good_open = 0;
+							break;
+						}
+
+						/* Store off the string descriptor indexes */
+						dev->manufacturer_index = desc.iManufacturer;
+						dev->product_index      = desc.iProduct;
+						dev->serial_index       = desc.iSerialNumber;
+
+						/* Store off the interface number */
+						dev->interface = intf_desc->bInterfaceNumber;
+
+						/* Find the INPUT and OUTPUT endpoints. An
+						   OUTPUT endpoint is not required. */
+						for (i = 0; i < intf_desc->bNumEndpoints; i++) {
+							const struct libusb_endpoint_descriptor *ep
+								= &intf_desc->endpoint[i];
+
+							/* Determine the type and direction of this
+							   endpoint. */
+							int is_interrupt =
+								(ep->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK)
+							      == LIBUSB_TRANSFER_TYPE_INTERRUPT;
+							int is_output =
+								(ep->bEndpointAddress & LIBUSB_ENDPOINT_DIR_MASK)
+							      == LIBUSB_ENDPOINT_OUT;
+							int is_input =
+								(ep->bEndpointAddress & LIBUSB_ENDPOINT_DIR_MASK)
+							      == LIBUSB_ENDPOINT_IN;
+
+							/* Decide whether to use it for intput or output. */
+							if (dev->input_endpoint == 0 &&
+							    is_interrupt && is_input) {
+								/* Use this endpoint for INPUT */
+								dev->input_endpoint = ep->bEndpointAddress;
+								dev->input_ep_max_packet_size = ep->wMaxPacketSize;
+							}
+							if (dev->output_endpoint == 0 &&
+							    is_interrupt && is_output) {
+								/* Use this endpoint for OUTPUT */
+								dev->output_endpoint = ep->bEndpointAddress;
+							}
+						}
+
+						pthread_create(&dev->thread, NULL, read_thread, dev);
+
+						/* Wait here for the read thread to be initialized. */
+						pthread_barrier_wait(&dev->barrier);
+
+					}
+					free(dev_path);
+				}
+			}
+		}
+		libusb_free_config_descriptor(conf_desc);
+
+	}
+
+	libusb_free_device_list(devs, 1);
+
+	/* If we have a good handle, return it. */
+	if (good_open) {
+		return dev;
+	}
+	else {
+		/* Unable to open any devices. */
+		free_hid_device(dev);
+		return NULL;
+	}
+}
+
+
+int HID_API_EXPORT hid_write(hid_device *dev, const unsigned char *data, size_t length)
+{
+	int res;
+	int report_number = data[0];
+	int skipped_report_id = 0;
+
+	if (report_number == 0x0) {
+		data++;
+		length--;
+		skipped_report_id = 1;
+	}
+
+
+	if (dev->output_endpoint <= 0) {
+		/* No interrput out endpoint. Use the Control Endpoint */
+		res = libusb_control_transfer(dev->device_handle,
+			LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_OUT,
+			0x09/*HID Set_Report*/,
+			(2/*HID output*/ << 8) | report_number,
+			dev->interface,
+			(unsigned char *)data, length,
+			1000/*timeout millis*/);
+
+		if (res < 0)
+			return -1;
+
+		if (skipped_report_id)
+			length++;
+
+		return length;
+	}
+	else {
+		/* Use the interrupt out endpoint */
+		int actual_length;
+		res = libusb_interrupt_transfer(dev->device_handle,
+			dev->output_endpoint,
+			(unsigned char*)data,
+			length,
+			&actual_length, 1000);
+
+		if (res < 0)
+			return -1;
+
+		if (skipped_report_id)
+			actual_length++;
+
+		return actual_length;
+	}
+}
+
+/* Helper function, to simplify hid_read().
+   This should be called with dev->mutex locked. */
+static int return_data(hid_device *dev, unsigned char *data, size_t length)
+{
+	/* Copy the data out of the linked list item (rpt) into the
+	   return buffer (data), and delete the liked list item. */
+	struct input_report *rpt = dev->input_reports;
+	size_t len = (length < rpt->len)? length: rpt->len;
+	if (len > 0)
+		memcpy(data, rpt->data, len);
+	dev->input_reports = rpt->next;
+	free(rpt->data);
+	free(rpt);
+	return len;
+}
+
+static void cleanup_mutex(void *param)
+{
+	hid_device *dev = param;
+	pthread_mutex_unlock(&dev->mutex);
+}
+
+
+int HID_API_EXPORT hid_read_timeout(hid_device *dev, unsigned char *data, size_t length, int milliseconds)
+{
+	int bytes_read = -1;
+
+#if 0
+	int transferred;
+	int res = libusb_interrupt_transfer(dev->device_handle, dev->input_endpoint, data, length, &transferred, 5000);
+	LOG("transferred: %d\n", transferred);
+	return transferred;
+#endif
+
+	pthread_mutex_lock(&dev->mutex);
+	pthread_cleanup_push(&cleanup_mutex, dev);
+
+	/* There's an input report queued up. Return it. */
+	if (dev->input_reports) {
+		/* Return the first one */
+		bytes_read = return_data(dev, data, length);
+		goto ret;
+	}
+
+	if (dev->shutdown_thread) {
+		/* This means the device has been disconnected.
+		   An error code of -1 should be returned. */
+		bytes_read = -1;
+		goto ret;
+	}
+
+	if (milliseconds == -1) {
+		/* Blocking */
+		while (!dev->input_reports && !dev->shutdown_thread) {
+			pthread_cond_wait(&dev->condition, &dev->mutex);
+		}
+		if (dev->input_reports) {
+			bytes_read = return_data(dev, data, length);
+		}
+	}
+	else if (milliseconds > 0) {
+		/* Non-blocking, but called with timeout. */
+		int res;
+		struct timespec ts;
+		clock_gettime(CLOCK_REALTIME, &ts);
+		ts.tv_sec += milliseconds / 1000;
+		ts.tv_nsec += (milliseconds % 1000) * 1000000;
+		if (ts.tv_nsec >= 1000000000L) {
+			ts.tv_sec++;
+			ts.tv_nsec -= 1000000000L;
+		}
+
+		while (!dev->input_reports && !dev->shutdown_thread) {
+			res = pthread_cond_timedwait(&dev->condition, &dev->mutex, &ts);
+			if (res == 0) {
+				if (dev->input_reports) {
+					bytes_read = return_data(dev, data, length);
+					break;
+				}
+
+				/* If we're here, there was a spurious wake up
+				   or the read thread was shutdown. Run the
+				   loop again (ie: don't break). */
+			}
+			else if (res == ETIMEDOUT) {
+				/* Timed out. */
+				bytes_read = 0;
+				break;
+			}
+			else {
+				/* Error. */
+				bytes_read = -1;
+				break;
+			}
+		}
+	}
+	else {
+		/* Purely non-blocking */
+		bytes_read = 0;
+	}
+
+ret:
+	pthread_mutex_unlock(&dev->mutex);
+	pthread_cleanup_pop(0);
+
+	return bytes_read;
+}
+
+int HID_API_EXPORT hid_read(hid_device *dev, unsigned char *data, size_t length)
+{
+	return hid_read_timeout(dev, data, length, dev->blocking ? -1 : 0);
+}
+
+int HID_API_EXPORT hid_set_nonblocking(hid_device *dev, int nonblock)
+{
+	dev->blocking = !nonblock;
+
+	return 0;
+}
+
+
+int HID_API_EXPORT hid_send_feature_report(hid_device *dev, const unsigned char *data, size_t length)
+{
+	int res = -1;
+	int skipped_report_id = 0;
+	int report_number = data[0];
+
+	if (report_number == 0x0) {
+		data++;
+		length--;
+		skipped_report_id = 1;
+	}
+
+	res = libusb_control_transfer(dev->device_handle,
+		LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_OUT,
+		0x09/*HID set_report*/,
+		(3/*HID feature*/ << 8) | report_number,
+		dev->interface,
+		(unsigned char *)data, length,
+		1000/*timeout millis*/);
+
+	if (res < 0)
+		return -1;
+
+	/* Account for the report ID */
+	if (skipped_report_id)
+		length++;
+
+	return length;
+}
+
+int HID_API_EXPORT hid_get_feature_report(hid_device *dev, unsigned char *data, size_t length)
+{
+	int res = -1;
+	int skipped_report_id = 0;
+	int report_number = data[0];
+
+	if (report_number == 0x0) {
+		/* Offset the return buffer by 1, so that the report ID
+		   will remain in byte 0. */
+		data++;
+		length--;
+		skipped_report_id = 1;
+	}
+	res = libusb_control_transfer(dev->device_handle,
+		LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_IN,
+		0x01/*HID get_report*/,
+		(3/*HID feature*/ << 8) | report_number,
+		dev->interface,
+		(unsigned char *)data, length,
+		1000/*timeout millis*/);
+
+	if (res < 0)
+		return -1;
+
+	if (skipped_report_id)
+		res++;
+
+	return res;
+}
+
+
+void HID_API_EXPORT hid_close(hid_device *dev)
+{
+	if (!dev)
+		return;
+
+	/* Cause read_thread() to stop. */
+	dev->shutdown_thread = 1;
+	libusb_cancel_transfer(dev->transfer);
+
+	/* Wait for read_thread() to end. */
+	pthread_join(dev->thread, NULL);
+
+	/* Clean up the Transfer objects allocated in read_thread(). */
+	free(dev->transfer->buffer);
+	libusb_free_transfer(dev->transfer);
+
+	/* release the interface */
+	libusb_release_interface(dev->device_handle, dev->interface);
+
+	/* Close the handle */
+	libusb_close(dev->device_handle);
+
+	/* Clear out the queue of received reports. */
+	pthread_mutex_lock(&dev->mutex);
+	while (dev->input_reports) {
+		return_data(dev, NULL, 0);
+	}
+	pthread_mutex_unlock(&dev->mutex);
+
+	free_hid_device(dev);
+}
+
+
+int HID_API_EXPORT_CALL hid_get_manufacturer_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return hid_get_indexed_string(dev, dev->manufacturer_index, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_product_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return hid_get_indexed_string(dev, dev->product_index, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_serial_number_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return hid_get_indexed_string(dev, dev->serial_index, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_indexed_string(hid_device *dev, int string_index, wchar_t *string, size_t maxlen)
+{
+	wchar_t *str;
+
+	str = get_usb_string(dev->device_handle, string_index);
+	if (str) {
+		wcsncpy(string, str, maxlen);
+		string[maxlen-1] = L'\0';
+		free(str);
+		return 0;
+	}
+	else
+		return -1;
+}
+
+
+HID_API_EXPORT const wchar_t * HID_API_CALL  hid_error(hid_device *dev)
+{
+	return NULL;
+}
+
+
+struct lang_map_entry {
+	const char *name;
+	const char *string_code;
+	uint16_t usb_code;
+};
+
+#define LANG(name,code,usb_code) { name, code, usb_code }
+static struct lang_map_entry lang_map[] = {
+	LANG("Afrikaans", "af", 0x0436),
+	LANG("Albanian", "sq", 0x041C),
+	LANG("Arabic - United Arab Emirates", "ar_ae", 0x3801),
+	LANG("Arabic - Bahrain", "ar_bh", 0x3C01),
+	LANG("Arabic - Algeria", "ar_dz", 0x1401),
+	LANG("Arabic - Egypt", "ar_eg", 0x0C01),
+	LANG("Arabic - Iraq", "ar_iq", 0x0801),
+	LANG("Arabic - Jordan", "ar_jo", 0x2C01),
+	LANG("Arabic - Kuwait", "ar_kw", 0x3401),
+	LANG("Arabic - Lebanon", "ar_lb", 0x3001),
+	LANG("Arabic - Libya", "ar_ly", 0x1001),
+	LANG("Arabic - Morocco", "ar_ma", 0x1801),
+	LANG("Arabic - Oman", "ar_om", 0x2001),
+	LANG("Arabic - Qatar", "ar_qa", 0x4001),
+	LANG("Arabic - Saudi Arabia", "ar_sa", 0x0401),
+	LANG("Arabic - Syria", "ar_sy", 0x2801),
+	LANG("Arabic - Tunisia", "ar_tn", 0x1C01),
+	LANG("Arabic - Yemen", "ar_ye", 0x2401),
+	LANG("Armenian", "hy", 0x042B),
+	LANG("Azeri - Latin", "az_az", 0x042C),
+	LANG("Azeri - Cyrillic", "az_az", 0x082C),
+	LANG("Basque", "eu", 0x042D),
+	LANG("Belarusian", "be", 0x0423),
+	LANG("Bulgarian", "bg", 0x0402),
+	LANG("Catalan", "ca", 0x0403),
+	LANG("Chinese - China", "zh_cn", 0x0804),
+	LANG("Chinese - Hong Kong SAR", "zh_hk", 0x0C04),
+	LANG("Chinese - Macau SAR", "zh_mo", 0x1404),
+	LANG("Chinese - Singapore", "zh_sg", 0x1004),
+	LANG("Chinese - Taiwan", "zh_tw", 0x0404),
+	LANG("Croatian", "hr", 0x041A),
+	LANG("Czech", "cs", 0x0405),
+	LANG("Danish", "da", 0x0406),
+	LANG("Dutch - Netherlands", "nl_nl", 0x0413),
+	LANG("Dutch - Belgium", "nl_be", 0x0813),
+	LANG("English - Australia", "en_au", 0x0C09),
+	LANG("English - Belize", "en_bz", 0x2809),
+	LANG("English - Canada", "en_ca", 0x1009),
+	LANG("English - Caribbean", "en_cb", 0x2409),
+	LANG("English - Ireland", "en_ie", 0x1809),
+	LANG("English - Jamaica", "en_jm", 0x2009),
+	LANG("English - New Zealand", "en_nz", 0x1409),
+	LANG("English - Phillippines", "en_ph", 0x3409),
+	LANG("English - Southern Africa", "en_za", 0x1C09),
+	LANG("English - Trinidad", "en_tt", 0x2C09),
+	LANG("English - Great Britain", "en_gb", 0x0809),
+	LANG("English - United States", "en_us", 0x0409),
+	LANG("Estonian", "et", 0x0425),
+	LANG("Farsi", "fa", 0x0429),
+	LANG("Finnish", "fi", 0x040B),
+	LANG("Faroese", "fo", 0x0438),
+	LANG("French - France", "fr_fr", 0x040C),
+	LANG("French - Belgium", "fr_be", 0x080C),
+	LANG("French - Canada", "fr_ca", 0x0C0C),
+	LANG("French - Luxembourg", "fr_lu", 0x140C),
+	LANG("French - Switzerland", "fr_ch", 0x100C),
+	LANG("Gaelic - Ireland", "gd_ie", 0x083C),
+	LANG("Gaelic - Scotland", "gd", 0x043C),
+	LANG("German - Germany", "de_de", 0x0407),
+	LANG("German - Austria", "de_at", 0x0C07),
+	LANG("German - Liechtenstein", "de_li", 0x1407),
+	LANG("German - Luxembourg", "de_lu", 0x1007),
+	LANG("German - Switzerland", "de_ch", 0x0807),
+	LANG("Greek", "el", 0x0408),
+	LANG("Hebrew", "he", 0x040D),
+	LANG("Hindi", "hi", 0x0439),
+	LANG("Hungarian", "hu", 0x040E),
+	LANG("Icelandic", "is", 0x040F),
+	LANG("Indonesian", "id", 0x0421),
+	LANG("Italian - Italy", "it_it", 0x0410),
+	LANG("Italian - Switzerland", "it_ch", 0x0810),
+	LANG("Japanese", "ja", 0x0411),
+	LANG("Korean", "ko", 0x0412),
+	LANG("Latvian", "lv", 0x0426),
+	LANG("Lithuanian", "lt", 0x0427),
+	LANG("F.Y.R.O. Macedonia", "mk", 0x042F),
+	LANG("Malay - Malaysia", "ms_my", 0x043E),
+	LANG("Malay  Brunei", "ms_bn", 0x083E),
+	LANG("Maltese", "mt", 0x043A),
+	LANG("Marathi", "mr", 0x044E),
+	LANG("Norwegian - Bokml", "no_no", 0x0414),
+	LANG("Norwegian - Nynorsk", "no_no", 0x0814),
+	LANG("Polish", "pl", 0x0415),
+	LANG("Portuguese - Portugal", "pt_pt", 0x0816),
+	LANG("Portuguese - Brazil", "pt_br", 0x0416),
+	LANG("Raeto-Romance", "rm", 0x0417),
+	LANG("Romanian - Romania", "ro", 0x0418),
+	LANG("Romanian - Republic of Moldova", "ro_mo", 0x0818),
+	LANG("Russian", "ru", 0x0419),
+	LANG("Russian - Republic of Moldova", "ru_mo", 0x0819),
+	LANG("Sanskrit", "sa", 0x044F),
+	LANG("Serbian - Cyrillic", "sr_sp", 0x0C1A),
+	LANG("Serbian - Latin", "sr_sp", 0x081A),
+	LANG("Setsuana", "tn", 0x0432),
+	LANG("Slovenian", "sl", 0x0424),
+	LANG("Slovak", "sk", 0x041B),
+	LANG("Sorbian", "sb", 0x042E),
+	LANG("Spanish - Spain (Traditional)", "es_es", 0x040A),
+	LANG("Spanish - Argentina", "es_ar", 0x2C0A),
+	LANG("Spanish - Bolivia", "es_bo", 0x400A),
+	LANG("Spanish - Chile", "es_cl", 0x340A),
+	LANG("Spanish - Colombia", "es_co", 0x240A),
+	LANG("Spanish - Costa Rica", "es_cr", 0x140A),
+	LANG("Spanish - Dominican Republic", "es_do", 0x1C0A),
+	LANG("Spanish - Ecuador", "es_ec", 0x300A),
+	LANG("Spanish - Guatemala", "es_gt", 0x100A),
+	LANG("Spanish - Honduras", "es_hn", 0x480A),
+	LANG("Spanish - Mexico", "es_mx", 0x080A),
+	LANG("Spanish - Nicaragua", "es_ni", 0x4C0A),
+	LANG("Spanish - Panama", "es_pa", 0x180A),
+	LANG("Spanish - Peru", "es_pe", 0x280A),
+	LANG("Spanish - Puerto Rico", "es_pr", 0x500A),
+	LANG("Spanish - Paraguay", "es_py", 0x3C0A),
+	LANG("Spanish - El Salvador", "es_sv", 0x440A),
+	LANG("Spanish - Uruguay", "es_uy", 0x380A),
+	LANG("Spanish - Venezuela", "es_ve", 0x200A),
+	LANG("Southern Sotho", "st", 0x0430),
+	LANG("Swahili", "sw", 0x0441),
+	LANG("Swedish - Sweden", "sv_se", 0x041D),
+	LANG("Swedish - Finland", "sv_fi", 0x081D),
+	LANG("Tamil", "ta", 0x0449),
+	LANG("Tatar", "tt", 0X0444),
+	LANG("Thai", "th", 0x041E),
+	LANG("Turkish", "tr", 0x041F),
+	LANG("Tsonga", "ts", 0x0431),
+	LANG("Ukrainian", "uk", 0x0422),
+	LANG("Urdu", "ur", 0x0420),
+	LANG("Uzbek - Cyrillic", "uz_uz", 0x0843),
+	LANG("Uzbek  Latin", "uz_uz", 0x0443),
+	LANG("Vietnamese", "vi", 0x042A),
+	LANG("Xhosa", "xh", 0x0434),
+	LANG("Yiddish", "yi", 0x043D),
+	LANG("Zulu", "zu", 0x0435),
+	LANG(NULL, NULL, 0x0),
+};
+
+uint16_t get_usb_code_for_current_locale(void)
+{
+	char *locale;
+	char search_string[64];
+	char *ptr;
+	struct lang_map_entry *lang;
+
+	/* Get the current locale. */
+	locale = setlocale(0, NULL);
+	if (!locale)
+		return 0x0;
+
+	/* Make a copy of the current locale string. */
+	strncpy(search_string, locale, sizeof(search_string));
+	search_string[sizeof(search_string)-1] = '\0';
+
+	/* Chop off the encoding part, and make it lower case. */
+	ptr = search_string;
+	while (*ptr) {
+		*ptr = tolower(*ptr);
+		if (*ptr == '.') {
+			*ptr = '\0';
+			break;
+		}
+		ptr++;
+	}
+
+	/* Find the entry which matches the string code of our locale. */
+	lang = lang_map;
+	while (lang->string_code) {
+		if (!strcmp(lang->string_code, search_string)) {
+			return lang->usb_code;
+		}
+		lang++;
+	}
+
+	/* There was no match. Find with just the language only. */
+	/* Chop off the variant. Chop it off at the '_'. */
+	ptr = search_string;
+	while (*ptr) {
+		*ptr = tolower(*ptr);
+		if (*ptr == '_') {
+			*ptr = '\0';
+			break;
+		}
+		ptr++;
+	}
+
+#if 0 /* TODO: Do we need this? */
+	/* Find the entry which matches the string code of our language. */
+	lang = lang_map;
+	while (lang->string_code) {
+		if (!strcmp(lang->string_code, search_string)) {
+			return lang->usb_code;
+		}
+		lang++;
+	}
+#endif
+
+	/* Found nothing. */
+	return 0x0;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/hidapi/hid-linux.c ../openambit.git/src/libambit/hidapi/hid-linux.c
--- ./src/libambit/hidapi/hid-linux.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/hidapi/hid-linux.c	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,795 @@
+/*******************************************************
+ HIDAPI - Multi-Platform library for
+ communication with HID devices.
+
+ Alan Ott
+ Signal 11 Software
+
+ 8/22/2009
+ Linux Version - 6/2/2009
+
+ Copyright 2009, All Rights Reserved.
+
+ At the discretion of the user of this library,
+ this software may be licensed under the terms of the
+ GNU General Public License v3, a BSD-Style license, or the
+ original HIDAPI license as outlined in the LICENSE.txt,
+ LICENSE-gpl3.txt, LICENSE-bsd.txt, and LICENSE-orig.txt
+ files located at the root of the source distribution.
+ These files may also be found in the public source
+ code repository located at:
+        http://github.com/signal11/hidapi .
+********************************************************/
+
+/* C */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <locale.h>
+#include <errno.h>
+
+/* Unix */
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/utsname.h>
+#include <fcntl.h>
+#include <poll.h>
+
+/* Linux */
+#include <linux/hidraw.h>
+#include <linux/version.h>
+#include <linux/input.h>
+#include <libudev.h>
+
+#include "hidapi.h"
+
+/* Definitions from linux/hidraw.h. Since these are new, some distros
+   may not have header files which contain them. */
+#ifndef HIDIOCSFEATURE
+#define HIDIOCSFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x06, len)
+#endif
+#ifndef HIDIOCGFEATURE
+#define HIDIOCGFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x07, len)
+#endif
+
+
+/* USB HID device property names */
+const char *device_string_names[] = {
+	"manufacturer",
+	"product",
+	"serial",
+};
+
+/* Symbolic names for the properties above */
+enum device_string_id {
+	DEVICE_STRING_MANUFACTURER,
+	DEVICE_STRING_PRODUCT,
+	DEVICE_STRING_SERIAL,
+
+	DEVICE_STRING_COUNT,
+};
+
+struct hid_device_ {
+	int device_handle;
+	int blocking;
+	int uses_numbered_reports;
+};
+
+
+static __u32 kernel_version = 0;
+
+static __u32 detect_kernel_version(void)
+{
+	struct utsname name;
+	int major, minor, release;
+	int ret;
+
+	uname(&name);
+	ret = sscanf(name.release, "%d.%d.%d", &major, &minor, &release);
+	if (ret == 3) {
+		return KERNEL_VERSION(major, minor, release);
+	}
+
+	ret = sscanf(name.release, "%d.%d", &major, &minor);
+	if (ret == 2) {
+		return KERNEL_VERSION(major, minor, 0);
+	}
+
+	printf("Couldn't determine kernel version from version string \"%s\"\n", name.release);
+	return 0;
+}
+
+static hid_device *new_hid_device(void)
+{
+	hid_device *dev = calloc(1, sizeof(hid_device));
+	dev->device_handle = -1;
+	dev->blocking = 1;
+	dev->uses_numbered_reports = 0;
+
+	return dev;
+}
+
+
+/* The caller must free the returned string with free(). */
+static wchar_t *utf8_to_wchar_t(const char *utf8)
+{
+	wchar_t *ret = NULL;
+
+	if (utf8) {
+		size_t wlen = mbstowcs(NULL, utf8, 0);
+		if ((size_t) -1 == wlen) {
+			return wcsdup(L"");
+		}
+		ret = calloc(wlen+1, sizeof(wchar_t));
+		mbstowcs(ret, utf8, wlen+1);
+		ret[wlen] = 0x0000;
+	}
+
+	return ret;
+}
+
+/* Get an attribute value from a udev_device and return it as a whar_t
+   string. The returned string must be freed with free() when done.*/
+static wchar_t *copy_udev_string(struct udev_device *dev, const char *udev_name)
+{
+	return utf8_to_wchar_t(udev_device_get_sysattr_value(dev, udev_name));
+}
+
+/* uses_numbered_reports() returns 1 if report_descriptor describes a device
+   which contains numbered reports. */
+static int uses_numbered_reports(__u8 *report_descriptor, __u32 size) {
+	unsigned int i = 0;
+	int size_code;
+	int data_len, key_size;
+
+	while (i < size) {
+		int key = report_descriptor[i];
+
+		/* Check for the Report ID key */
+		if (key == 0x85/*Report ID*/) {
+			/* This device has a Report ID, which means it uses
+			   numbered reports. */
+			return 1;
+		}
+
+		//printf("key: %02hhx\n", key);
+
+		if ((key & 0xf0) == 0xf0) {
+			/* This is a Long Item. The next byte contains the
+			   length of the data section (value) for this key.
+			   See the HID specification, version 1.11, section
+			   6.2.2.3, titled "Long Items." */
+			if (i+1 < size)
+				data_len = report_descriptor[i+1];
+			else
+				data_len = 0; /* malformed report */
+			key_size = 3;
+		}
+		else {
+			/* This is a Short Item. The bottom two bits of the
+			   key contain the size code for the data section
+			   (value) for this key.  Refer to the HID
+			   specification, version 1.11, section 6.2.2.2,
+			   titled "Short Items." */
+			size_code = key & 0x3;
+			switch (size_code) {
+			case 0:
+			case 1:
+			case 2:
+				data_len = size_code;
+				break;
+			case 3:
+				data_len = 4;
+				break;
+			default:
+				/* Can't ever happen since size_code is & 0x3 */
+				data_len = 0;
+				break;
+			};
+			key_size = 1;
+		}
+
+		/* Skip over this key and it's associated data */
+		i += data_len + key_size;
+	}
+
+	/* Didn't find a Report ID key. Device doesn't use numbered reports. */
+	return 0;
+}
+
+/*
+ * The caller is responsible for free()ing the (newly-allocated) character
+ * strings pointed to by serial_number_utf8 and product_name_utf8 after use.
+ */
+static int
+parse_uevent_info(const char *uevent, int *bus_type,
+	unsigned short *vendor_id, unsigned short *product_id,
+	char **serial_number_utf8, char **product_name_utf8)
+{
+	char *tmp = strdup(uevent);
+	char *saveptr = NULL;
+	char *line;
+	char *key;
+	char *value;
+
+	int found_id = 0;
+	int found_serial = 0;
+	int found_name = 0;
+
+	line = strtok_r(tmp, "\n", &saveptr);
+	while (line != NULL) {
+		/* line: "KEY=value" */
+		key = line;
+		value = strchr(line, '=');
+		if (!value) {
+			goto next_line;
+		}
+		*value = '\0';
+		value++;
+
+		if (strcmp(key, "HID_ID") == 0) {
+			/**
+			 *        type vendor   product
+			 * HID_ID=0003:000005AC:00008242
+			 **/
+			int ret = sscanf(value, "%x:%hx:%hx", bus_type, vendor_id, product_id);
+			if (ret == 3) {
+				found_id = 1;
+			}
+		} else if (strcmp(key, "HID_NAME") == 0) {
+			/* The caller has to free the product name */
+			*product_name_utf8 = strdup(value);
+			found_name = 1;
+		} else if (strcmp(key, "HID_UNIQ") == 0) {
+			/* The caller has to free the serial number */
+			*serial_number_utf8 = strdup(value);
+			found_serial = 1;
+		}
+
+next_line:
+		line = strtok_r(NULL, "\n", &saveptr);
+	}
+
+	free(tmp);
+	return (found_id && found_name && found_serial);
+}
+
+
+static int get_device_string(hid_device *dev, enum device_string_id key, wchar_t *string, size_t maxlen)
+{
+	struct udev *udev;
+	struct udev_device *udev_dev, *parent, *hid_dev;
+	struct stat s;
+	int ret = -1;
+        char *serial_number_utf8 = NULL;
+        char *product_name_utf8 = NULL;
+
+	/* Create the udev object */
+	udev = udev_new();
+	if (!udev) {
+		printf("Can't create udev\n");
+		return -1;
+	}
+
+	/* Get the dev_t (major/minor numbers) from the file handle. */
+	fstat(dev->device_handle, &s);
+	/* Open a udev device from the dev_t. 'c' means character device. */
+	udev_dev = udev_device_new_from_devnum(udev, 'c', s.st_rdev);
+	if (udev_dev) {
+		hid_dev = udev_device_get_parent_with_subsystem_devtype(
+			udev_dev,
+			"hid",
+			NULL);
+		if (hid_dev) {
+			unsigned short dev_vid;
+			unsigned short dev_pid;
+			int bus_type;
+			size_t retm;
+
+			ret = parse_uevent_info(
+			           udev_device_get_sysattr_value(hid_dev, "uevent"),
+			           &bus_type,
+			           &dev_vid,
+			           &dev_pid,
+			           &serial_number_utf8,
+			           &product_name_utf8);
+
+			if (bus_type == BUS_BLUETOOTH) {
+				switch (key) {
+					case DEVICE_STRING_MANUFACTURER:
+						wcsncpy(string, L"", maxlen);
+						ret = 0;
+						break;
+					case DEVICE_STRING_PRODUCT:
+						retm = mbstowcs(string, product_name_utf8, maxlen);
+						ret = (retm == (size_t)-1)? -1: 0;
+						break;
+					case DEVICE_STRING_SERIAL:
+						retm = mbstowcs(string, serial_number_utf8, maxlen);
+						ret = (retm == (size_t)-1)? -1: 0;
+						break;
+					case DEVICE_STRING_COUNT:
+					default:
+						ret = -1;
+						break;
+				}
+			}
+			else {
+				/* This is a USB device. Find its parent USB Device node. */
+				parent = udev_device_get_parent_with_subsystem_devtype(
+					   udev_dev,
+					   "usb",
+					   "usb_device");
+				if (parent) {
+					const char *str;
+					const char *key_str = NULL;
+
+					if (key >= 0 && key < DEVICE_STRING_COUNT) {
+						key_str = device_string_names[key];
+					} else {
+						ret = -1;
+						goto end;
+					}
+
+					str = udev_device_get_sysattr_value(parent, key_str);
+					if (str) {
+						/* Convert the string from UTF-8 to wchar_t */
+						retm = mbstowcs(string, str, maxlen);
+						ret = (retm == (size_t)-1)? -1: 0;
+						goto end;
+					}
+				}
+			}
+		}
+	}
+
+end:
+        free(serial_number_utf8);
+        free(product_name_utf8);
+
+	udev_device_unref(udev_dev);
+	/* parent and hid_dev don't need to be (and can't be) unref'd.
+	   I'm not sure why, but they'll throw double-free() errors. */
+	udev_unref(udev);
+
+	return ret;
+}
+
+int HID_API_EXPORT hid_init(void)
+{
+	const char *locale;
+
+	/* Set the locale if it's not set. */
+	locale = setlocale(LC_CTYPE, NULL);
+	if (!locale)
+		setlocale(LC_CTYPE, "");
+
+	kernel_version = detect_kernel_version();
+
+	return 0;
+}
+
+int HID_API_EXPORT hid_exit(void)
+{
+	/* Nothing to do for this in the Linux/hidraw implementation. */
+	return 0;
+}
+
+
+struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id, unsigned short product_id)
+{
+	struct udev *udev;
+	struct udev_enumerate *enumerate;
+	struct udev_list_entry *devices, *dev_list_entry;
+
+	struct hid_device_info *root = NULL; /* return object */
+	struct hid_device_info *cur_dev = NULL;
+	struct hid_device_info *prev_dev = NULL; /* previous device */
+
+	hid_init();
+
+	/* Create the udev object */
+	udev = udev_new();
+	if (!udev) {
+		printf("Can't create udev\n");
+		return NULL;
+	}
+
+	/* Create a list of the devices in the 'hidraw' subsystem. */
+	enumerate = udev_enumerate_new(udev);
+	udev_enumerate_add_match_subsystem(enumerate, "hidraw");
+	udev_enumerate_scan_devices(enumerate);
+	devices = udev_enumerate_get_list_entry(enumerate);
+	/* For each item, see if it matches the vid/pid, and if so
+	   create a udev_device record for it */
+	udev_list_entry_foreach(dev_list_entry, devices) {
+		const char *sysfs_path;
+		const char *dev_path;
+		const char *str;
+		struct udev_device *raw_dev; /* The device's hidraw udev node. */
+		struct udev_device *hid_dev; /* The device's HID udev node. */
+		struct udev_device *usb_dev; /* The device's USB udev node. */
+		struct udev_device *intf_dev; /* The device's interface (in the USB sense). */
+		unsigned short dev_vid;
+		unsigned short dev_pid;
+		char *serial_number_utf8 = NULL;
+		char *product_name_utf8 = NULL;
+		int bus_type;
+		int result;
+
+		/* Get the filename of the /sys entry for the device
+		   and create a udev_device object (dev) representing it */
+		sysfs_path = udev_list_entry_get_name(dev_list_entry);
+		raw_dev = udev_device_new_from_syspath(udev, sysfs_path);
+		dev_path = udev_device_get_devnode(raw_dev);
+
+		hid_dev = udev_device_get_parent_with_subsystem_devtype(
+			raw_dev,
+			"hid",
+			NULL);
+
+		if (!hid_dev) {
+			/* Unable to find parent hid device. */
+			goto next;
+		}
+
+		result = parse_uevent_info(
+			udev_device_get_sysattr_value(hid_dev, "uevent"),
+			&bus_type,
+			&dev_vid,
+			&dev_pid,
+			&serial_number_utf8,
+			&product_name_utf8);
+
+		if (!result) {
+			/* parse_uevent_info() failed for at least one field. */
+			goto next;
+		}
+
+		if (bus_type != BUS_USB && bus_type != BUS_BLUETOOTH) {
+			/* We only know how to handle USB and BT devices. */
+			goto next;
+		}
+
+		/* Check the VID/PID against the arguments */
+		if ((vendor_id == 0x0 || vendor_id == dev_vid) &&
+		    (product_id == 0x0 || product_id == dev_pid)) {
+			struct hid_device_info *tmp;
+
+			/* VID/PID match. Create the record. */
+			tmp = malloc(sizeof(struct hid_device_info));
+			if (cur_dev) {
+				cur_dev->next = tmp;
+			}
+			else {
+				root = tmp;
+			}
+			prev_dev = cur_dev;
+			cur_dev = tmp;
+
+			/* Fill out the record */
+			cur_dev->next = NULL;
+			cur_dev->path = dev_path? strdup(dev_path): NULL;
+
+			/* VID/PID */
+			cur_dev->vendor_id = dev_vid;
+			cur_dev->product_id = dev_pid;
+
+			/* Serial Number */
+			cur_dev->serial_number = utf8_to_wchar_t(serial_number_utf8);
+
+			/* Release Number */
+			cur_dev->release_number = 0x0;
+
+			/* Interface Number */
+			cur_dev->interface_number = -1;
+
+			switch (bus_type) {
+				case BUS_USB:
+					/* The device pointed to by raw_dev contains information about
+					   the hidraw device. In order to get information about the
+					   USB device, get the parent device with the
+					   subsystem/devtype pair of "usb"/"usb_device". This will
+					   be several levels up the tree, but the function will find
+					   it. */
+					usb_dev = udev_device_get_parent_with_subsystem_devtype(
+							raw_dev,
+							"usb",
+							"usb_device");
+
+					if (!usb_dev) {
+						/* Free this device */
+						free(cur_dev->serial_number);
+						free(cur_dev->path);
+						free(cur_dev);
+
+						/* Take it off the device list. */
+						if (prev_dev) {
+							prev_dev->next = NULL;
+							cur_dev = prev_dev;
+						}
+						else {
+							cur_dev = root = NULL;
+						}
+
+						goto next;
+					}
+
+					/* Manufacturer and Product strings */
+					cur_dev->manufacturer_string = copy_udev_string(usb_dev, device_string_names[DEVICE_STRING_MANUFACTURER]);
+					cur_dev->product_string = copy_udev_string(usb_dev, device_string_names[DEVICE_STRING_PRODUCT]);
+
+					/* Release Number */
+					str = udev_device_get_sysattr_value(usb_dev, "bcdDevice");
+					cur_dev->release_number = (str)? strtol(str, NULL, 16): 0x0;
+
+					/* Get a handle to the interface's udev node. */
+					intf_dev = udev_device_get_parent_with_subsystem_devtype(
+							raw_dev,
+							"usb",
+							"usb_interface");
+					if (intf_dev) {
+						str = udev_device_get_sysattr_value(intf_dev, "bInterfaceNumber");
+						cur_dev->interface_number = (str)? strtol(str, NULL, 16): -1;
+					}
+
+					break;
+
+				case BUS_BLUETOOTH:
+					/* Manufacturer and Product strings */
+					cur_dev->manufacturer_string = wcsdup(L"");
+					cur_dev->product_string = utf8_to_wchar_t(product_name_utf8);
+
+					break;
+
+				default:
+					/* Unknown device type - this should never happen, as we
+					 * check for USB and Bluetooth devices above */
+					break;
+			}
+		}
+
+	next:
+		free(serial_number_utf8);
+		free(product_name_utf8);
+		udev_device_unref(raw_dev);
+		/* hid_dev, usb_dev and intf_dev don't need to be (and can't be)
+		   unref()d.  It will cause a double-free() error.  I'm not
+		   sure why.  */
+	}
+	/* Free the enumerator and udev objects. */
+	udev_enumerate_unref(enumerate);
+	udev_unref(udev);
+
+	return root;
+}
+
+void  HID_API_EXPORT hid_free_enumeration(struct hid_device_info *devs)
+{
+	struct hid_device_info *d = devs;
+	while (d) {
+		struct hid_device_info *next = d->next;
+		free(d->path);
+		free(d->serial_number);
+		free(d->manufacturer_string);
+		free(d->product_string);
+		free(d);
+		d = next;
+	}
+}
+
+hid_device * hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number)
+{
+	struct hid_device_info *devs, *cur_dev;
+	const char *path_to_open = NULL;
+	hid_device *handle = NULL;
+
+	devs = hid_enumerate(vendor_id, product_id);
+	cur_dev = devs;
+	while (cur_dev) {
+		if (cur_dev->vendor_id == vendor_id &&
+		    cur_dev->product_id == product_id) {
+			if (serial_number) {
+				if (wcscmp(serial_number, cur_dev->serial_number) == 0) {
+					path_to_open = cur_dev->path;
+					break;
+				}
+			}
+			else {
+				path_to_open = cur_dev->path;
+				break;
+			}
+		}
+		cur_dev = cur_dev->next;
+	}
+
+	if (path_to_open) {
+		/* Open the device */
+		handle = hid_open_path(path_to_open);
+	}
+
+	hid_free_enumeration(devs);
+
+	return handle;
+}
+
+hid_device * HID_API_EXPORT hid_open_path(const char *path)
+{
+	hid_device *dev = NULL;
+
+	hid_init();
+
+	dev = new_hid_device();
+
+	/* OPEN HERE */
+	dev->device_handle = open(path, O_RDWR);
+
+	/* If we have a good handle, return it. */
+	if (dev->device_handle > 0) {
+
+		/* Get the report descriptor */
+		int res, desc_size = 0;
+		struct hidraw_report_descriptor rpt_desc;
+
+		memset(&rpt_desc, 0x0, sizeof(rpt_desc));
+
+		/* Get Report Descriptor Size */
+		res = ioctl(dev->device_handle, HIDIOCGRDESCSIZE, &desc_size);
+		if (res < 0)
+			perror("HIDIOCGRDESCSIZE");
+
+
+		/* Get Report Descriptor */
+		rpt_desc.size = desc_size;
+		res = ioctl(dev->device_handle, HIDIOCGRDESC, &rpt_desc);
+		if (res < 0) {
+			perror("HIDIOCGRDESC");
+		} else {
+			/* Determine if this device uses numbered reports. */
+			dev->uses_numbered_reports =
+				uses_numbered_reports(rpt_desc.value,
+				                      rpt_desc.size);
+		}
+
+		return dev;
+	}
+	else {
+		/* Unable to open any devices. */
+		free(dev);
+		return NULL;
+	}
+}
+
+
+int HID_API_EXPORT hid_write(hid_device *dev, const unsigned char *data, size_t length)
+{
+	int bytes_written;
+
+	bytes_written = write(dev->device_handle, data, length);
+
+	return bytes_written;
+}
+
+
+int HID_API_EXPORT hid_read_timeout(hid_device *dev, unsigned char *data, size_t length, int milliseconds)
+{
+	int bytes_read;
+
+	if (milliseconds >= 0) {
+		/* Milliseconds is either 0 (non-blocking) or > 0 (contains
+		   a valid timeout). In both cases we want to call poll()
+		   and wait for data to arrive.  Don't rely on non-blocking
+		   operation (O_NONBLOCK) since some kernels don't seem to
+		   properly report device disconnection through read() when
+		   in non-blocking mode.  */
+		int ret;
+		struct pollfd fds;
+
+		fds.fd = dev->device_handle;
+		fds.events = POLLIN;
+		fds.revents = 0;
+		ret = poll(&fds, 1, milliseconds);
+		if (ret == -1 || ret == 0) {
+			/* Error or timeout */
+			return ret;
+		}
+		else {
+			/* Check for errors on the file descriptor. This will
+			   indicate a device disconnection. */
+			if (fds.revents & (POLLERR | POLLHUP | POLLNVAL))
+				return -1;
+		}
+	}
+
+	bytes_read = read(dev->device_handle, data, length);
+	if (bytes_read < 0 && (errno == EAGAIN || errno == EINPROGRESS))
+		bytes_read = 0;
+
+	if (bytes_read >= 0 &&
+	    kernel_version != 0 &&
+	    kernel_version < KERNEL_VERSION(2,6,34) &&
+	    dev->uses_numbered_reports) {
+		/* Work around a kernel bug. Chop off the first byte. */
+		memmove(data, data+1, bytes_read);
+		bytes_read--;
+	}
+
+	return bytes_read;
+}
+
+int HID_API_EXPORT hid_read(hid_device *dev, unsigned char *data, size_t length)
+{
+	return hid_read_timeout(dev, data, length, (dev->blocking)? -1: 0);
+}
+
+int HID_API_EXPORT hid_set_nonblocking(hid_device *dev, int nonblock)
+{
+	/* Do all non-blocking in userspace using poll(), since it looks
+	   like there's a bug in the kernel in some versions where
+	   read() will not return -1 on disconnection of the USB device */
+
+	dev->blocking = !nonblock;
+	return 0; /* Success */
+}
+
+
+int HID_API_EXPORT hid_send_feature_report(hid_device *dev, const unsigned char *data, size_t length)
+{
+	int res;
+
+	res = ioctl(dev->device_handle, HIDIOCSFEATURE(length), data);
+	if (res < 0)
+		perror("ioctl (SFEATURE)");
+
+	return res;
+}
+
+int HID_API_EXPORT hid_get_feature_report(hid_device *dev, unsigned char *data, size_t length)
+{
+	int res;
+
+	res = ioctl(dev->device_handle, HIDIOCGFEATURE(length), data);
+	if (res < 0)
+		perror("ioctl (GFEATURE)");
+
+
+	return res;
+}
+
+
+void HID_API_EXPORT hid_close(hid_device *dev)
+{
+	if (!dev)
+		return;
+	close(dev->device_handle);
+	free(dev);
+}
+
+
+int HID_API_EXPORT_CALL hid_get_manufacturer_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return get_device_string(dev, DEVICE_STRING_MANUFACTURER, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_product_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return get_device_string(dev, DEVICE_STRING_PRODUCT, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_serial_number_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return get_device_string(dev, DEVICE_STRING_SERIAL, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_indexed_string(hid_device *dev, int string_index, wchar_t *string, size_t maxlen)
+{
+	return -1;
+}
+
+
+HID_API_EXPORT const wchar_t * HID_API_CALL  hid_error(hid_device *dev)
+{
+	return NULL;
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/hidapi/hid-pcapsimulate.c ../openambit.git/src/libambit/hidapi/hid-pcapsimulate.c
--- ./src/libambit/hidapi/hid-pcapsimulate.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/hidapi/hid-pcapsimulate.c	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,442 @@
+/*******************************************************
+ HIDAPI simulation interface for PCAP files
+
+ Set PCAP-file to parse by setting environment variable
+ HIDAPI_PCAPSIMULATE_FILENAME to the file path
+********************************************************/
+
+/* C */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <pcap/pcap.h>
+
+#include "hidapi.h"
+
+/* Local definitions */
+struct hid_device_ {
+    pcap_t *pcap;
+    char errbuf[PCAP_ERRBUF_SIZE];
+    uint16_t last_write_command;
+    uint16_t last_sequence_number;
+    uint8_t reading_parts;
+};
+
+typedef struct device_id_mappings_s {
+    uint16_t vendor_id;
+    uint16_t product_id;
+    char *model;
+    char *manufacturer;
+    char *product;
+} device_id_mappings_t;
+
+// crc16.c
+uint16_t crc16_ccitt_false(unsigned char *buf, size_t buflen);
+uint16_t crc16_ccitt_false_init(unsigned char *buf, size_t buflen, uint16_t crc);
+
+/* Static functions */
+static pcap_t *pcap_file_reopen(pcap_t *old_pcap, char *errbuf);
+static const u_char *pcap_file_get_next(pcap_t *pcap);
+static const u_char *pcap_file_find_next_pkt(pcap_t *pcap, uint16_t command, uint8_t recv_not_send, const u_char *data);
+static uint16_t pcap_file_find_next_pkt_reass(pcap_t *pcap, uint16_t command, uint8_t recv_not_send, const u_char *data, u_char **buf);
+
+static hid_device *new_hid_device(void);
+static wchar_t *utf8_to_wchar_t(const char *utf8);
+
+
+/* Static data */
+static device_id_mappings_t device_id_mapping[] = {
+    { 0x1493, 0x001d, "Greentit", "Suunto", "Ambit" },
+    { 0x1493, 0x001c, "Finch", "Suunto", "Ambit" },
+    { 0x1493, 0x001b, "Emu", "Suunto", "Ambit" },
+    { 0x1493, 0x001a, "Colibri", "Suunto", "Ambit" },
+    { 0x1493, 0x0019, "Duck", "Suunto", "Ambit" },
+    { 0x1493, 0x0010, "Bluebird", "Suunto", "Ambit" }
+};
+static const device_id_mappings_t *detected_device = NULL;
+static char *detected_device_serial = NULL;
+
+int HID_API_EXPORT hid_init(void)
+{
+    pcap_t *pcap;
+    char errbuf[PCAP_ERRBUF_SIZE];
+    u_char *pktbuf;
+    uint16_t pktbuf_len;
+    char *model_string;
+    char *serial_string;
+    int i;
+
+    if (detected_device == NULL) {
+        pcap = pcap_file_reopen(NULL, errbuf);
+        if (pcap == NULL) {
+            return -1;
+        }
+
+        // Try to find device info in PCAP file
+        pktbuf_len = pcap_file_find_next_pkt_reass(pcap, 0x0002, 1, NULL, &pktbuf);
+
+        if (pktbuf_len > 0) {
+            model_string = (char*)pktbuf;
+            serial_string = (char*)(pktbuf + 16);
+
+            // Try to find matching model
+            for (i=0; i<sizeof(device_id_mapping)/sizeof(device_id_mapping[0]); i++) {
+                if (strncmp(device_id_mapping[i].model, model_string, 16) == 0) {
+                    detected_device = &device_id_mapping[i];
+                    detected_device_serial = malloc(17);
+                    strncpy(detected_device_serial, serial_string, 16);
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+int HID_API_EXPORT hid_exit(void)
+{
+    return 0;
+}
+
+
+struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id, unsigned short product_id)
+{
+    struct hid_device_info *root = NULL; /* return object */
+
+    hid_init();
+
+    if (detected_device != NULL) {
+        struct hid_device_info *tmp;
+
+        tmp = malloc(sizeof(struct hid_device_info));
+        tmp->next = NULL;
+
+        tmp->path = calloc(1, 1);
+        tmp->vendor_id = detected_device->vendor_id;
+        tmp->product_id = detected_device->product_id;
+        tmp->serial_number = utf8_to_wchar_t(detected_device_serial);
+        tmp->release_number = 0x0;
+        tmp->interface_number = -1;
+        tmp->manufacturer_string = utf8_to_wchar_t(detected_device->manufacturer);
+        tmp->product_string = utf8_to_wchar_t(detected_device->product);
+
+        root = tmp;
+    }
+
+    return root;
+}
+
+void  HID_API_EXPORT hid_free_enumeration(struct hid_device_info *devs)
+{
+    struct hid_device_info *d = devs;
+    while (d) {
+        struct hid_device_info *next = d->next;
+        free(d->path);
+        free(d->serial_number);
+        free(d->manufacturer_string);
+        free(d->product_string);
+        free(d);
+        d = next;
+    }
+}
+
+hid_device * hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number)
+{
+    hid_device *handle = NULL;
+
+    handle = hid_open_path(NULL);
+
+    return handle;
+}
+
+hid_device * HID_API_EXPORT hid_open_path(const char *path)
+{
+    hid_device *dev = NULL;
+
+    hid_init();
+
+    if (detected_device != NULL) {
+        dev = new_hid_device();
+        dev->pcap = pcap_file_reopen(NULL, dev->errbuf);
+        if (dev->pcap == NULL) {
+            return NULL;
+        }
+    }
+
+    return dev;
+}
+
+
+int HID_API_EXPORT hid_write(hid_device *dev, const unsigned char *data, size_t length)
+{
+    const u_char *pkt;
+    uint16_t command;
+    uint8_t pkt_part;
+    uint8_t len;
+
+    // Parse a few parts of the data
+    len = data[1];
+    pkt_part = data[2];
+    command = be16toh(*(uint16_t*)(data + 8));
+
+    // If this is a contineous write, we have to assume this is just fine, do
+    // nothing
+    if (pkt_part == 0x5d) {
+        // First try, search to end
+        pkt = pcap_file_find_next_pkt(dev->pcap, command, 0, len != 20 ? data + 20 : NULL);
+        if (pkt != NULL) {
+        }
+        // Second try, read from top
+        if (pkt == NULL) {
+            dev->pcap = pcap_file_reopen(dev->pcap, dev->errbuf);
+            pkt = pcap_file_find_next_pkt(dev->pcap, command, 0, len != 20 ? data + 20 : NULL);
+        }
+        if (pkt != NULL) {
+        }
+        // Third try, do not care about data
+        if (pkt == NULL) {
+            dev->pcap = pcap_file_reopen(dev->pcap, dev->errbuf);
+            pkt = pcap_file_find_next_pkt(dev->pcap, command, 0, NULL);
+        }
+        if (pkt != NULL) {
+        }
+
+        dev->last_write_command = command;
+        dev->last_sequence_number = le16toh(*(uint16_t*)(data + 14));
+        dev->reading_parts = 0;
+    }
+    
+    return pkt != NULL ? 0 : -1;
+}
+
+
+int HID_API_EXPORT hid_read_timeout(hid_device *dev, unsigned char *data, size_t length, int milliseconds)
+{
+    const u_char *pkt = NULL;
+    u_char tmpbuf[64];
+    uint16_t *payload_crc, tmpcrc;
+
+    // If we have already started to read parts, we should just continue with
+    // next valid packet, else we need to resolve first packet
+    if (dev->reading_parts) {
+        pkt = pcap_file_get_next(dev->pcap);
+    }
+    else {
+        // Search for next receive packet
+        pkt = pcap_file_find_next_pkt(dev->pcap, 0xffff, 1, NULL);
+    }
+
+    if (pkt != NULL) {
+        if (dev->reading_parts == 0) {
+            // If we found firstpacket, we need to rewrite sequence number and crc
+            memcpy(tmpbuf, pkt, 64);
+            *(uint16_t*)(tmpbuf + 14) = htole16(dev->last_sequence_number);
+            tmpcrc = crc16_ccitt_false(&tmpbuf[2], 4);
+            *(uint16_t*)(tmpbuf + 6) = htole16(tmpcrc);
+            payload_crc = (uint16_t *)&tmpbuf[tmpbuf[1]];
+            *payload_crc = htole16(crc16_ccitt_false_init(&tmpbuf[8], tmpbuf[3], tmpcrc));
+            pkt = tmpbuf;
+        }
+        dev->reading_parts = 1;
+        // Fix length
+        if (length > 64)
+            length = 64;
+        if (data != NULL) {
+            memcpy(data, pkt, length);
+        }
+        return length;
+    }
+    return -1;
+}
+
+int HID_API_EXPORT hid_read(hid_device *dev, unsigned char *data, size_t length)
+{
+    return hid_read_timeout(dev, data, length, 0);
+}
+
+int HID_API_EXPORT hid_set_nonblocking(hid_device *dev, int nonblock)
+{
+    return 0; /* Success */
+}
+
+
+int HID_API_EXPORT hid_send_feature_report(hid_device *dev, const unsigned char *data, size_t length)
+{
+    return 0;
+}
+
+int HID_API_EXPORT hid_get_feature_report(hid_device *dev, unsigned char *data, size_t length)
+{
+    return 0;
+}
+
+
+void HID_API_EXPORT hid_close(hid_device *dev)
+{
+    if (!dev)
+        return;
+
+    pcap_close(dev->pcap);
+}
+
+
+int HID_API_EXPORT_CALL hid_get_manufacturer_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+    return -1;
+}
+
+int HID_API_EXPORT_CALL hid_get_product_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+    return -1;
+}
+
+int HID_API_EXPORT_CALL hid_get_serial_number_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+    return -1;
+}
+
+int HID_API_EXPORT_CALL hid_get_indexed_string(hid_device *dev, int string_index, wchar_t *string, size_t maxlen)
+{
+    return -1;
+}
+
+
+HID_API_EXPORT const wchar_t * HID_API_CALL  hid_error(hid_device *dev)
+{
+    return NULL;
+}
+
+static pcap_t *pcap_file_reopen(pcap_t *old_pcap, char *errbuf)
+{
+    char *pcap_file;
+    pcap_t *pcap = NULL;
+
+    if (old_pcap != NULL) {
+        pcap_close(old_pcap);
+    }
+
+    pcap_file = getenv("HIDAPI_PCAPSIMULATE_FILENAME");
+    if (pcap_file != NULL) {
+        pcap = pcap_open_offline(pcap_file, errbuf);
+        if (pcap == NULL) {
+            printf("Error: Failed to open pcap file %s\n", pcap_file);
+        }
+    }
+    else {
+        printf("Error: No HIDAPI_PCAPSIMULATE_FILENAME variable defined\n");
+    }
+
+    return pcap;
+}
+
+static const u_char *pcap_file_get_next(pcap_t *pcap)
+{
+    struct pcap_pkthdr h;
+    const u_char *pktdata;
+    size_t data_offset;
+
+    do {
+        pktdata = pcap_next(pcap, &h);
+        if (h.len == 128 || h.len == 91) { // Linux USB vs USBPcap
+            data_offset = h.len - 64;
+            if (pktdata[data_offset] == 0x3f) { // Sanity check, first byte
+                return pktdata + data_offset;
+            }
+        }
+    } while(pktdata != NULL);
+
+    return NULL;
+}
+
+static const u_char *pcap_file_find_next_pkt(pcap_t *pcap, uint16_t command, uint8_t recv_not_send, const u_char *data)
+{
+    const u_char *pktdata;
+
+    do {
+        pktdata = pcap_file_get_next(pcap);
+        if (pktdata != NULL) {
+            uint8_t len = pktdata[1];
+            uint8_t pkttype = pktdata[2];
+            uint16_t pktcommand = be16toh(*(uint16_t*)(pktdata + 8));
+            uint8_t send_recv = (pktdata[10] & 0x03) >> 1;
+            if (pkttype == 0x5d &&
+                (command == 0xffff || pktcommand == command) &&
+                send_recv == recv_not_send) {
+                if (data != NULL) {
+                    // Compare data as well
+                    if (memcmp(data, pktdata + 20, len - 20) == 0) {
+                        break;
+                    }
+                }
+                else {
+                    break;
+                }
+            }
+        }
+    } while(pktdata != NULL);
+
+    return pktdata;
+}
+
+static uint16_t pcap_file_find_next_pkt_reass(pcap_t *pcap, uint16_t command, uint8_t recv_not_send, const u_char *data, u_char **buf)
+{
+    const u_char *pkt;
+    u_char *retbuf = NULL;
+    uint16_t retlen = 0;
+    uint16_t msg_parts, msg_part;
+    uint16_t pkts_captured = 1;
+
+    pkt = pcap_file_find_next_pkt(pcap, command, recv_not_send, data);
+
+    if (pkt != NULL) {
+        // Check how many packets this entry should consist of
+        msg_parts = le16toh(*(uint16_t*)(pkt + 4));
+        retlen = le32toh(*(uint32_t*)(pkt + 16));
+        retbuf = malloc(44 + 56*(msg_parts-1));
+
+        if (retbuf != NULL) {
+            memcpy(retbuf, pkt + 20, 44);
+            while (msg_parts > pkts_captured) {
+                pkt = pcap_file_get_next(pcap);
+                if (pkt == NULL) {
+                    free(retbuf);
+                    retbuf = NULL;
+                    retlen = 0;
+                    break;
+                }
+                msg_part = le16toh(*(uint16_t*)(pkt + 4));
+                memcpy(retbuf + 44 + 56*(msg_part-1), pkt + 8, 56);
+                pkts_captured++;
+            }
+        }
+    }
+
+    *buf = retbuf;
+    return retlen;
+}
+
+static hid_device *new_hid_device(void)
+{
+    hid_device *dev = calloc(1, sizeof(hid_device));
+
+    return dev;
+}
+
+/* The caller must free the returned string with free(). */
+static wchar_t *utf8_to_wchar_t(const char *utf8)
+{
+    wchar_t *ret = NULL;
+
+    if (utf8) {
+        size_t wlen = mbstowcs(NULL, utf8, 0);
+        if ((size_t) -1 == wlen) {
+            return wcsdup(L"");
+        }
+        ret = calloc(wlen+1, sizeof(wchar_t));
+        mbstowcs(ret, utf8, wlen+1);
+        ret[wlen] = 0x0000;
+    }
+
+    return ret;
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/hid.c ../openambit.git/src/libambit/hid.c
--- ./src/libambit/hid.c	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/libambit/hid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,795 +0,0 @@
-/*******************************************************
- HIDAPI - Multi-Platform library for
- communication with HID devices.
-
- Alan Ott
- Signal 11 Software
-
- 8/22/2009
- Linux Version - 6/2/2009
-
- Copyright 2009, All Rights Reserved.
-
- At the discretion of the user of this library,
- this software may be licensed under the terms of the
- GNU General Public License v3, a BSD-Style license, or the
- original HIDAPI license as outlined in the LICENSE.txt,
- LICENSE-gpl3.txt, LICENSE-bsd.txt, and LICENSE-orig.txt
- files located at the root of the source distribution.
- These files may also be found in the public source
- code repository located at:
-        http://github.com/signal11/hidapi .
-********************************************************/
-
-/* C */
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <locale.h>
-#include <errno.h>
-
-/* Unix */
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <sys/utsname.h>
-#include <fcntl.h>
-#include <poll.h>
-
-/* Linux */
-#include <linux/hidraw.h>
-#include <linux/version.h>
-#include <linux/input.h>
-#include <libudev.h>
-
-#include "hidapi.h"
-
-/* Definitions from linux/hidraw.h. Since these are new, some distros
-   may not have header files which contain them. */
-#ifndef HIDIOCSFEATURE
-#define HIDIOCSFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x06, len)
-#endif
-#ifndef HIDIOCGFEATURE
-#define HIDIOCGFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x07, len)
-#endif
-
-
-/* USB HID device property names */
-const char *device_string_names[] = {
-	"manufacturer",
-	"product",
-	"serial",
-};
-
-/* Symbolic names for the properties above */
-enum device_string_id {
-	DEVICE_STRING_MANUFACTURER,
-	DEVICE_STRING_PRODUCT,
-	DEVICE_STRING_SERIAL,
-
-	DEVICE_STRING_COUNT,
-};
-
-struct hid_device_ {
-	int device_handle;
-	int blocking;
-	int uses_numbered_reports;
-};
-
-
-static __u32 kernel_version = 0;
-
-static __u32 detect_kernel_version(void)
-{
-	struct utsname name;
-	int major, minor, release;
-	int ret;
-
-	uname(&name);
-	ret = sscanf(name.release, "%d.%d.%d", &major, &minor, &release);
-	if (ret == 3) {
-		return KERNEL_VERSION(major, minor, release);
-	}
-
-	ret = sscanf(name.release, "%d.%d", &major, &minor);
-	if (ret == 2) {
-		return KERNEL_VERSION(major, minor, 0);
-	}
-
-	printf("Couldn't determine kernel version from version string \"%s\"\n", name.release);
-	return 0;
-}
-
-static hid_device *new_hid_device(void)
-{
-	hid_device *dev = calloc(1, sizeof(hid_device));
-	dev->device_handle = -1;
-	dev->blocking = 1;
-	dev->uses_numbered_reports = 0;
-
-	return dev;
-}
-
-
-/* The caller must free the returned string with free(). */
-static wchar_t *utf8_to_wchar_t(const char *utf8)
-{
-	wchar_t *ret = NULL;
-
-	if (utf8) {
-		size_t wlen = mbstowcs(NULL, utf8, 0);
-		if ((size_t) -1 == wlen) {
-			return wcsdup(L"");
-		}
-		ret = calloc(wlen+1, sizeof(wchar_t));
-		mbstowcs(ret, utf8, wlen+1);
-		ret[wlen] = 0x0000;
-	}
-
-	return ret;
-}
-
-/* Get an attribute value from a udev_device and return it as a whar_t
-   string. The returned string must be freed with free() when done.*/
-static wchar_t *copy_udev_string(struct udev_device *dev, const char *udev_name)
-{
-	return utf8_to_wchar_t(udev_device_get_sysattr_value(dev, udev_name));
-}
-
-/* uses_numbered_reports() returns 1 if report_descriptor describes a device
-   which contains numbered reports. */
-static int uses_numbered_reports(__u8 *report_descriptor, __u32 size) {
-	unsigned int i = 0;
-	int size_code;
-	int data_len, key_size;
-
-	while (i < size) {
-		int key = report_descriptor[i];
-
-		/* Check for the Report ID key */
-		if (key == 0x85/*Report ID*/) {
-			/* This device has a Report ID, which means it uses
-			   numbered reports. */
-			return 1;
-		}
-
-		//printf("key: %02hhx\n", key);
-
-		if ((key & 0xf0) == 0xf0) {
-			/* This is a Long Item. The next byte contains the
-			   length of the data section (value) for this key.
-			   See the HID specification, version 1.11, section
-			   6.2.2.3, titled "Long Items." */
-			if (i+1 < size)
-				data_len = report_descriptor[i+1];
-			else
-				data_len = 0; /* malformed report */
-			key_size = 3;
-		}
-		else {
-			/* This is a Short Item. The bottom two bits of the
-			   key contain the size code for the data section
-			   (value) for this key.  Refer to the HID
-			   specification, version 1.11, section 6.2.2.2,
-			   titled "Short Items." */
-			size_code = key & 0x3;
-			switch (size_code) {
-			case 0:
-			case 1:
-			case 2:
-				data_len = size_code;
-				break;
-			case 3:
-				data_len = 4;
-				break;
-			default:
-				/* Can't ever happen since size_code is & 0x3 */
-				data_len = 0;
-				break;
-			};
-			key_size = 1;
-		}
-
-		/* Skip over this key and it's associated data */
-		i += data_len + key_size;
-	}
-
-	/* Didn't find a Report ID key. Device doesn't use numbered reports. */
-	return 0;
-}
-
-/*
- * The caller is responsible for free()ing the (newly-allocated) character
- * strings pointed to by serial_number_utf8 and product_name_utf8 after use.
- */
-static int
-parse_uevent_info(const char *uevent, int *bus_type,
-	unsigned short *vendor_id, unsigned short *product_id,
-	char **serial_number_utf8, char **product_name_utf8)
-{
-	char *tmp = strdup(uevent);
-	char *saveptr = NULL;
-	char *line;
-	char *key;
-	char *value;
-
-	int found_id = 0;
-	int found_serial = 0;
-	int found_name = 0;
-
-	line = strtok_r(tmp, "\n", &saveptr);
-	while (line != NULL) {
-		/* line: "KEY=value" */
-		key = line;
-		value = strchr(line, '=');
-		if (!value) {
-			goto next_line;
-		}
-		*value = '\0';
-		value++;
-
-		if (strcmp(key, "HID_ID") == 0) {
-			/**
-			 *        type vendor   product
-			 * HID_ID=0003:000005AC:00008242
-			 **/
-			int ret = sscanf(value, "%x:%hx:%hx", bus_type, vendor_id, product_id);
-			if (ret == 3) {
-				found_id = 1;
-			}
-		} else if (strcmp(key, "HID_NAME") == 0) {
-			/* The caller has to free the product name */
-			*product_name_utf8 = strdup(value);
-			found_name = 1;
-		} else if (strcmp(key, "HID_UNIQ") == 0) {
-			/* The caller has to free the serial number */
-			*serial_number_utf8 = strdup(value);
-			found_serial = 1;
-		}
-
-next_line:
-		line = strtok_r(NULL, "\n", &saveptr);
-	}
-
-	free(tmp);
-	return (found_id && found_name && found_serial);
-}
-
-
-static int get_device_string(hid_device *dev, enum device_string_id key, wchar_t *string, size_t maxlen)
-{
-	struct udev *udev;
-	struct udev_device *udev_dev, *parent, *hid_dev;
-	struct stat s;
-	int ret = -1;
-        char *serial_number_utf8 = NULL;
-        char *product_name_utf8 = NULL;
-
-	/* Create the udev object */
-	udev = udev_new();
-	if (!udev) {
-		printf("Can't create udev\n");
-		return -1;
-	}
-
-	/* Get the dev_t (major/minor numbers) from the file handle. */
-	fstat(dev->device_handle, &s);
-	/* Open a udev device from the dev_t. 'c' means character device. */
-	udev_dev = udev_device_new_from_devnum(udev, 'c', s.st_rdev);
-	if (udev_dev) {
-		hid_dev = udev_device_get_parent_with_subsystem_devtype(
-			udev_dev,
-			"hid",
-			NULL);
-		if (hid_dev) {
-			unsigned short dev_vid;
-			unsigned short dev_pid;
-			int bus_type;
-			size_t retm;
-
-			ret = parse_uevent_info(
-			           udev_device_get_sysattr_value(hid_dev, "uevent"),
-			           &bus_type,
-			           &dev_vid,
-			           &dev_pid,
-			           &serial_number_utf8,
-			           &product_name_utf8);
-
-			if (bus_type == BUS_BLUETOOTH) {
-				switch (key) {
-					case DEVICE_STRING_MANUFACTURER:
-						wcsncpy(string, L"", maxlen);
-						ret = 0;
-						break;
-					case DEVICE_STRING_PRODUCT:
-						retm = mbstowcs(string, product_name_utf8, maxlen);
-						ret = (retm == (size_t)-1)? -1: 0;
-						break;
-					case DEVICE_STRING_SERIAL:
-						retm = mbstowcs(string, serial_number_utf8, maxlen);
-						ret = (retm == (size_t)-1)? -1: 0;
-						break;
-					case DEVICE_STRING_COUNT:
-					default:
-						ret = -1;
-						break;
-				}
-			}
-			else {
-				/* This is a USB device. Find its parent USB Device node. */
-				parent = udev_device_get_parent_with_subsystem_devtype(
-					   udev_dev,
-					   "usb",
-					   "usb_device");
-				if (parent) {
-					const char *str;
-					const char *key_str = NULL;
-
-					if (key >= 0 && key < DEVICE_STRING_COUNT) {
-						key_str = device_string_names[key];
-					} else {
-						ret = -1;
-						goto end;
-					}
-
-					str = udev_device_get_sysattr_value(parent, key_str);
-					if (str) {
-						/* Convert the string from UTF-8 to wchar_t */
-						retm = mbstowcs(string, str, maxlen);
-						ret = (retm == (size_t)-1)? -1: 0;
-						goto end;
-					}
-				}
-			}
-		}
-	}
-
-end:
-        free(serial_number_utf8);
-        free(product_name_utf8);
-
-	udev_device_unref(udev_dev);
-	/* parent and hid_dev don't need to be (and can't be) unref'd.
-	   I'm not sure why, but they'll throw double-free() errors. */
-	udev_unref(udev);
-
-	return ret;
-}
-
-int HID_API_EXPORT hid_init(void)
-{
-	const char *locale;
-
-	/* Set the locale if it's not set. */
-	locale = setlocale(LC_CTYPE, NULL);
-	if (!locale)
-		setlocale(LC_CTYPE, "");
-
-	kernel_version = detect_kernel_version();
-
-	return 0;
-}
-
-int HID_API_EXPORT hid_exit(void)
-{
-	/* Nothing to do for this in the Linux/hidraw implementation. */
-	return 0;
-}
-
-
-struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id, unsigned short product_id)
-{
-	struct udev *udev;
-	struct udev_enumerate *enumerate;
-	struct udev_list_entry *devices, *dev_list_entry;
-
-	struct hid_device_info *root = NULL; /* return object */
-	struct hid_device_info *cur_dev = NULL;
-	struct hid_device_info *prev_dev = NULL; /* previous device */
-
-	hid_init();
-
-	/* Create the udev object */
-	udev = udev_new();
-	if (!udev) {
-		printf("Can't create udev\n");
-		return NULL;
-	}
-
-	/* Create a list of the devices in the 'hidraw' subsystem. */
-	enumerate = udev_enumerate_new(udev);
-	udev_enumerate_add_match_subsystem(enumerate, "hidraw");
-	udev_enumerate_scan_devices(enumerate);
-	devices = udev_enumerate_get_list_entry(enumerate);
-	/* For each item, see if it matches the vid/pid, and if so
-	   create a udev_device record for it */
-	udev_list_entry_foreach(dev_list_entry, devices) {
-		const char *sysfs_path;
-		const char *dev_path;
-		const char *str;
-		struct udev_device *raw_dev; /* The device's hidraw udev node. */
-		struct udev_device *hid_dev; /* The device's HID udev node. */
-		struct udev_device *usb_dev; /* The device's USB udev node. */
-		struct udev_device *intf_dev; /* The device's interface (in the USB sense). */
-		unsigned short dev_vid;
-		unsigned short dev_pid;
-		char *serial_number_utf8 = NULL;
-		char *product_name_utf8 = NULL;
-		int bus_type;
-		int result;
-
-		/* Get the filename of the /sys entry for the device
-		   and create a udev_device object (dev) representing it */
-		sysfs_path = udev_list_entry_get_name(dev_list_entry);
-		raw_dev = udev_device_new_from_syspath(udev, sysfs_path);
-		dev_path = udev_device_get_devnode(raw_dev);
-
-		hid_dev = udev_device_get_parent_with_subsystem_devtype(
-			raw_dev,
-			"hid",
-			NULL);
-
-		if (!hid_dev) {
-			/* Unable to find parent hid device. */
-			goto next;
-		}
-
-		result = parse_uevent_info(
-			udev_device_get_sysattr_value(hid_dev, "uevent"),
-			&bus_type,
-			&dev_vid,
-			&dev_pid,
-			&serial_number_utf8,
-			&product_name_utf8);
-
-		if (!result) {
-			/* parse_uevent_info() failed for at least one field. */
-			goto next;
-		}
-
-		if (bus_type != BUS_USB && bus_type != BUS_BLUETOOTH) {
-			/* We only know how to handle USB and BT devices. */
-			goto next;
-		}
-
-		/* Check the VID/PID against the arguments */
-		if ((vendor_id == 0x0 || vendor_id == dev_vid) &&
-		    (product_id == 0x0 || product_id == dev_pid)) {
-			struct hid_device_info *tmp;
-
-			/* VID/PID match. Create the record. */
-			tmp = malloc(sizeof(struct hid_device_info));
-			if (cur_dev) {
-				cur_dev->next = tmp;
-			}
-			else {
-				root = tmp;
-			}
-			prev_dev = cur_dev;
-			cur_dev = tmp;
-
-			/* Fill out the record */
-			cur_dev->next = NULL;
-			cur_dev->path = dev_path? strdup(dev_path): NULL;
-
-			/* VID/PID */
-			cur_dev->vendor_id = dev_vid;
-			cur_dev->product_id = dev_pid;
-
-			/* Serial Number */
-			cur_dev->serial_number = utf8_to_wchar_t(serial_number_utf8);
-
-			/* Release Number */
-			cur_dev->release_number = 0x0;
-
-			/* Interface Number */
-			cur_dev->interface_number = -1;
-
-			switch (bus_type) {
-				case BUS_USB:
-					/* The device pointed to by raw_dev contains information about
-					   the hidraw device. In order to get information about the
-					   USB device, get the parent device with the
-					   subsystem/devtype pair of "usb"/"usb_device". This will
-					   be several levels up the tree, but the function will find
-					   it. */
-					usb_dev = udev_device_get_parent_with_subsystem_devtype(
-							raw_dev,
-							"usb",
-							"usb_device");
-
-					if (!usb_dev) {
-						/* Free this device */
-						free(cur_dev->serial_number);
-						free(cur_dev->path);
-						free(cur_dev);
-
-						/* Take it off the device list. */
-						if (prev_dev) {
-							prev_dev->next = NULL;
-							cur_dev = prev_dev;
-						}
-						else {
-							cur_dev = root = NULL;
-						}
-
-						goto next;
-					}
-
-					/* Manufacturer and Product strings */
-					cur_dev->manufacturer_string = copy_udev_string(usb_dev, device_string_names[DEVICE_STRING_MANUFACTURER]);
-					cur_dev->product_string = copy_udev_string(usb_dev, device_string_names[DEVICE_STRING_PRODUCT]);
-
-					/* Release Number */
-					str = udev_device_get_sysattr_value(usb_dev, "bcdDevice");
-					cur_dev->release_number = (str)? strtol(str, NULL, 16): 0x0;
-
-					/* Get a handle to the interface's udev node. */
-					intf_dev = udev_device_get_parent_with_subsystem_devtype(
-							raw_dev,
-							"usb",
-							"usb_interface");
-					if (intf_dev) {
-						str = udev_device_get_sysattr_value(intf_dev, "bInterfaceNumber");
-						cur_dev->interface_number = (str)? strtol(str, NULL, 16): -1;
-					}
-
-					break;
-
-				case BUS_BLUETOOTH:
-					/* Manufacturer and Product strings */
-					cur_dev->manufacturer_string = wcsdup(L"");
-					cur_dev->product_string = utf8_to_wchar_t(product_name_utf8);
-
-					break;
-
-				default:
-					/* Unknown device type - this should never happen, as we
-					 * check for USB and Bluetooth devices above */
-					break;
-			}
-		}
-
-	next:
-		free(serial_number_utf8);
-		free(product_name_utf8);
-		udev_device_unref(raw_dev);
-		/* hid_dev, usb_dev and intf_dev don't need to be (and can't be)
-		   unref()d.  It will cause a double-free() error.  I'm not
-		   sure why.  */
-	}
-	/* Free the enumerator and udev objects. */
-	udev_enumerate_unref(enumerate);
-	udev_unref(udev);
-
-	return root;
-}
-
-void  HID_API_EXPORT hid_free_enumeration(struct hid_device_info *devs)
-{
-	struct hid_device_info *d = devs;
-	while (d) {
-		struct hid_device_info *next = d->next;
-		free(d->path);
-		free(d->serial_number);
-		free(d->manufacturer_string);
-		free(d->product_string);
-		free(d);
-		d = next;
-	}
-}
-
-hid_device * hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number)
-{
-	struct hid_device_info *devs, *cur_dev;
-	const char *path_to_open = NULL;
-	hid_device *handle = NULL;
-
-	devs = hid_enumerate(vendor_id, product_id);
-	cur_dev = devs;
-	while (cur_dev) {
-		if (cur_dev->vendor_id == vendor_id &&
-		    cur_dev->product_id == product_id) {
-			if (serial_number) {
-				if (wcscmp(serial_number, cur_dev->serial_number) == 0) {
-					path_to_open = cur_dev->path;
-					break;
-				}
-			}
-			else {
-				path_to_open = cur_dev->path;
-				break;
-			}
-		}
-		cur_dev = cur_dev->next;
-	}
-
-	if (path_to_open) {
-		/* Open the device */
-		handle = hid_open_path(path_to_open);
-	}
-
-	hid_free_enumeration(devs);
-
-	return handle;
-}
-
-hid_device * HID_API_EXPORT hid_open_path(const char *path)
-{
-	hid_device *dev = NULL;
-
-	hid_init();
-
-	dev = new_hid_device();
-
-	/* OPEN HERE */
-	dev->device_handle = open(path, O_RDWR);
-
-	/* If we have a good handle, return it. */
-	if (dev->device_handle > 0) {
-
-		/* Get the report descriptor */
-		int res, desc_size = 0;
-		struct hidraw_report_descriptor rpt_desc;
-
-		memset(&rpt_desc, 0x0, sizeof(rpt_desc));
-
-		/* Get Report Descriptor Size */
-		res = ioctl(dev->device_handle, HIDIOCGRDESCSIZE, &desc_size);
-		if (res < 0)
-			perror("HIDIOCGRDESCSIZE");
-
-
-		/* Get Report Descriptor */
-		rpt_desc.size = desc_size;
-		res = ioctl(dev->device_handle, HIDIOCGRDESC, &rpt_desc);
-		if (res < 0) {
-			perror("HIDIOCGRDESC");
-		} else {
-			/* Determine if this device uses numbered reports. */
-			dev->uses_numbered_reports =
-				uses_numbered_reports(rpt_desc.value,
-				                      rpt_desc.size);
-		}
-
-		return dev;
-	}
-	else {
-		/* Unable to open any devices. */
-		free(dev);
-		return NULL;
-	}
-}
-
-
-int HID_API_EXPORT hid_write(hid_device *dev, const unsigned char *data, size_t length)
-{
-	int bytes_written;
-
-	bytes_written = write(dev->device_handle, data, length);
-
-	return bytes_written;
-}
-
-
-int HID_API_EXPORT hid_read_timeout(hid_device *dev, unsigned char *data, size_t length, int milliseconds)
-{
-	int bytes_read;
-
-	if (milliseconds >= 0) {
-		/* Milliseconds is either 0 (non-blocking) or > 0 (contains
-		   a valid timeout). In both cases we want to call poll()
-		   and wait for data to arrive.  Don't rely on non-blocking
-		   operation (O_NONBLOCK) since some kernels don't seem to
-		   properly report device disconnection through read() when
-		   in non-blocking mode.  */
-		int ret;
-		struct pollfd fds;
-
-		fds.fd = dev->device_handle;
-		fds.events = POLLIN;
-		fds.revents = 0;
-		ret = poll(&fds, 1, milliseconds);
-		if (ret == -1 || ret == 0) {
-			/* Error or timeout */
-			return ret;
-		}
-		else {
-			/* Check for errors on the file descriptor. This will
-			   indicate a device disconnection. */
-			if (fds.revents & (POLLERR | POLLHUP | POLLNVAL))
-				return -1;
-		}
-	}
-
-	bytes_read = read(dev->device_handle, data, length);
-	if (bytes_read < 0 && (errno == EAGAIN || errno == EINPROGRESS))
-		bytes_read = 0;
-
-	if (bytes_read >= 0 &&
-	    kernel_version != 0 &&
-	    kernel_version < KERNEL_VERSION(2,6,34) &&
-	    dev->uses_numbered_reports) {
-		/* Work around a kernel bug. Chop off the first byte. */
-		memmove(data, data+1, bytes_read);
-		bytes_read--;
-	}
-
-	return bytes_read;
-}
-
-int HID_API_EXPORT hid_read(hid_device *dev, unsigned char *data, size_t length)
-{
-	return hid_read_timeout(dev, data, length, (dev->blocking)? -1: 0);
-}
-
-int HID_API_EXPORT hid_set_nonblocking(hid_device *dev, int nonblock)
-{
-	/* Do all non-blocking in userspace using poll(), since it looks
-	   like there's a bug in the kernel in some versions where
-	   read() will not return -1 on disconnection of the USB device */
-
-	dev->blocking = !nonblock;
-	return 0; /* Success */
-}
-
-
-int HID_API_EXPORT hid_send_feature_report(hid_device *dev, const unsigned char *data, size_t length)
-{
-	int res;
-
-	res = ioctl(dev->device_handle, HIDIOCSFEATURE(length), data);
-	if (res < 0)
-		perror("ioctl (SFEATURE)");
-
-	return res;
-}
-
-int HID_API_EXPORT hid_get_feature_report(hid_device *dev, unsigned char *data, size_t length)
-{
-	int res;
-
-	res = ioctl(dev->device_handle, HIDIOCGFEATURE(length), data);
-	if (res < 0)
-		perror("ioctl (GFEATURE)");
-
-
-	return res;
-}
-
-
-void HID_API_EXPORT hid_close(hid_device *dev)
-{
-	if (!dev)
-		return;
-	close(dev->device_handle);
-	free(dev);
-}
-
-
-int HID_API_EXPORT_CALL hid_get_manufacturer_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return get_device_string(dev, DEVICE_STRING_MANUFACTURER, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_product_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return get_device_string(dev, DEVICE_STRING_PRODUCT, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_serial_number_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return get_device_string(dev, DEVICE_STRING_SERIAL, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_indexed_string(hid_device *dev, int string_index, wchar_t *string, size_t maxlen)
-{
-	return -1;
-}
-
-
-HID_API_EXPORT const wchar_t * HID_API_CALL  hid_error(hid_device *dev)
-{
-	return NULL;
-}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/hid-libusb.c ../openambit.git/src/libambit/hid-libusb.c
--- ./src/libambit/hid-libusb.c	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/libambit/hid-libusb.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1427 +0,0 @@
-/*******************************************************
- HIDAPI - Multi-Platform library for
- communication with HID devices.
-
- Alan Ott
- Signal 11 Software
-
- 8/22/2009
- Linux Version - 6/2/2010
- Libusb Version - 8/13/2010
- FreeBSD Version - 11/1/2011
-
- Copyright 2009, All Rights Reserved.
-
- At the discretion of the user of this library,
- this software may be licensed under the terms of the
- GNU General Public License v3, a BSD-Style license, or the
- original HIDAPI license as outlined in the LICENSE.txt,
- LICENSE-gpl3.txt, LICENSE-bsd.txt, and LICENSE-orig.txt
- files located at the root of the source distribution.
- These files may also be found in the public source
- code repository located at:
-        http://github.com/signal11/hidapi .
-********************************************************/
-
-#define _GNU_SOURCE /* needed for wcsdup() before glibc 2.10 */
-
-/* C */
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <ctype.h>
-#include <locale.h>
-#include <errno.h>
-
-/* Unix */
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <sys/utsname.h>
-#include <fcntl.h>
-#include <pthread.h>
-#include <wchar.h>
-
-/* GNU / LibUSB */
-#include "libusb.h"
-#include "iconv.h"
-
-#include "hidapi.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef DEBUG_PRINTF
-#define LOG(...) fprintf(stderr, __VA_ARGS__)
-#else
-#define LOG(...) do {} while (0)
-#endif
-
-#ifndef __FreeBSD__
-#define DETACH_KERNEL_DRIVER
-#endif
-
-/* Uncomment to enable the retrieval of Usage and Usage Page in
-hid_enumerate(). Warning, on platforms different from FreeBSD
-this is very invasive as it requires the detach
-and re-attach of the kernel driver. See comments inside hid_enumerate().
-libusb HIDAPI programs are encouraged to use the interface number
-instead to differentiate between interfaces on a composite HID device. */
-/*#define INVASIVE_GET_USAGE*/
-
-/* Linked List of input reports received from the device. */
-struct input_report {
-	uint8_t *data;
-	size_t len;
-	struct input_report *next;
-};
-
-
-struct hid_device_ {
-	/* Handle to the actual device. */
-	libusb_device_handle *device_handle;
-
-	/* Endpoint information */
-	int input_endpoint;
-	int output_endpoint;
-	int input_ep_max_packet_size;
-
-	/* The interface number of the HID */
-	int interface;
-
-	/* Indexes of Strings */
-	int manufacturer_index;
-	int product_index;
-	int serial_index;
-
-	/* Whether blocking reads are used */
-	int blocking; /* boolean */
-
-	/* Read thread objects */
-	pthread_t thread;
-	pthread_mutex_t mutex; /* Protects input_reports */
-	pthread_cond_t condition;
-	pthread_barrier_t barrier; /* Ensures correct startup sequence */
-	int shutdown_thread;
-	int cancelled;
-	struct libusb_transfer *transfer;
-
-	/* List of received input reports. */
-	struct input_report *input_reports;
-};
-
-static libusb_context *usb_context = NULL;
-
-uint16_t get_usb_code_for_current_locale(void);
-static int return_data(hid_device *dev, unsigned char *data, size_t length);
-
-static hid_device *new_hid_device(void)
-{
-	hid_device *dev = calloc(1, sizeof(hid_device));
-	dev->blocking = 1;
-
-	pthread_mutex_init(&dev->mutex, NULL);
-	pthread_cond_init(&dev->condition, NULL);
-	pthread_barrier_init(&dev->barrier, NULL, 2);
-
-	return dev;
-}
-
-static void free_hid_device(hid_device *dev)
-{
-	/* Clean up the thread objects */
-	pthread_barrier_destroy(&dev->barrier);
-	pthread_cond_destroy(&dev->condition);
-	pthread_mutex_destroy(&dev->mutex);
-
-	/* Free the device itself */
-	free(dev);
-}
-
-#if 0
-/*TODO: Implement this funciton on hidapi/libusb.. */
-static void register_error(hid_device *device, const char *op)
-{
-
-}
-#endif
-
-#ifdef INVASIVE_GET_USAGE
-/* Get bytes from a HID Report Descriptor.
-   Only call with a num_bytes of 0, 1, 2, or 4. */
-static uint32_t get_bytes(uint8_t *rpt, size_t len, size_t num_bytes, size_t cur)
-{
-	/* Return if there aren't enough bytes. */
-	if (cur + num_bytes >= len)
-		return 0;
-
-	if (num_bytes == 0)
-		return 0;
-	else if (num_bytes == 1) {
-		return rpt[cur+1];
-	}
-	else if (num_bytes == 2) {
-		return (rpt[cur+2] * 256 + rpt[cur+1]);
-	}
-	else if (num_bytes == 4) {
-		return (rpt[cur+4] * 0x01000000 +
-		        rpt[cur+3] * 0x00010000 +
-		        rpt[cur+2] * 0x00000100 +
-		        rpt[cur+1] * 0x00000001);
-	}
-	else
-		return 0;
-}
-
-/* Retrieves the device's Usage Page and Usage from the report
-   descriptor. The algorithm is simple, as it just returns the first
-   Usage and Usage Page that it finds in the descriptor.
-   The return value is 0 on success and -1 on failure. */
-static int get_usage(uint8_t *report_descriptor, size_t size,
-                     unsigned short *usage_page, unsigned short *usage)
-{
-	unsigned int i = 0;
-	int size_code;
-	int data_len, key_size;
-	int usage_found = 0, usage_page_found = 0;
-
-	while (i < size) {
-		int key = report_descriptor[i];
-		int key_cmd = key & 0xfc;
-
-		//printf("key: %02hhx\n", key);
-
-		if ((key & 0xf0) == 0xf0) {
-			/* This is a Long Item. The next byte contains the
-			   length of the data section (value) for this key.
-			   See the HID specification, version 1.11, section
-			   6.2.2.3, titled "Long Items." */
-			if (i+1 < size)
-				data_len = report_descriptor[i+1];
-			else
-				data_len = 0; /* malformed report */
-			key_size = 3;
-		}
-		else {
-			/* This is a Short Item. The bottom two bits of the
-			   key contain the size code for the data section
-			   (value) for this key.  Refer to the HID
-			   specification, version 1.11, section 6.2.2.2,
-			   titled "Short Items." */
-			size_code = key & 0x3;
-			switch (size_code) {
-			case 0:
-			case 1:
-			case 2:
-				data_len = size_code;
-				break;
-			case 3:
-				data_len = 4;
-				break;
-			default:
-				/* Can't ever happen since size_code is & 0x3 */
-				data_len = 0;
-				break;
-			};
-			key_size = 1;
-		}
-
-		if (key_cmd == 0x4) {
-			*usage_page  = get_bytes(report_descriptor, size, data_len, i);
-			usage_page_found = 1;
-			//printf("Usage Page: %x\n", (uint32_t)*usage_page);
-		}
-		if (key_cmd == 0x8) {
-			*usage = get_bytes(report_descriptor, size, data_len, i);
-			usage_found = 1;
-			//printf("Usage: %x\n", (uint32_t)*usage);
-		}
-
-		if (usage_page_found && usage_found)
-			return 0; /* success */
-
-		/* Skip over this key and it's associated data */
-		i += data_len + key_size;
-	}
-
-	return -1; /* failure */
-}
-#endif /* INVASIVE_GET_USAGE */
-
-#ifdef __FreeBSD__
-/* The FreeBSD version of libusb doesn't have this funciton. In mainline
-   libusb, it's inlined in libusb.h. This function will bear a striking
-   resemblence to that one, because there's about one way to code it.
-
-   Note that the data parameter is Unicode in UTF-16LE encoding.
-   Return value is the number of bytes in data, or LIBUSB_ERROR_*.
- */
-static inline int libusb_get_string_descriptor(libusb_device_handle *dev,
-	uint8_t descriptor_index, uint16_t lang_id,
-	unsigned char *data, int length)
-{
-	return libusb_control_transfer(dev,
-		LIBUSB_ENDPOINT_IN | 0x0, /* Endpoint 0 IN */
-		LIBUSB_REQUEST_GET_DESCRIPTOR,
-		(LIBUSB_DT_STRING << 8) | descriptor_index,
-		lang_id, data, (uint16_t) length, 1000);
-}
-
-#endif
-
-
-/* Get the first language the device says it reports. This comes from
-   USB string #0. */
-static uint16_t get_first_language(libusb_device_handle *dev)
-{
-	uint16_t buf[32];
-	int len;
-
-	/* Get the string from libusb. */
-	len = libusb_get_string_descriptor(dev,
-			0x0, /* String ID */
-			0x0, /* Language */
-			(unsigned char*)buf,
-			sizeof(buf));
-	if (len < 4)
-		return 0x0;
-
-	return buf[1]; /* First two bytes are len and descriptor type. */
-}
-
-static int is_language_supported(libusb_device_handle *dev, uint16_t lang)
-{
-	uint16_t buf[32];
-	int len;
-	int i;
-
-	/* Get the string from libusb. */
-	len = libusb_get_string_descriptor(dev,
-			0x0, /* String ID */
-			0x0, /* Language */
-			(unsigned char*)buf,
-			sizeof(buf));
-	if (len < 4)
-		return 0x0;
-
-
-	len /= 2; /* language IDs are two-bytes each. */
-	/* Start at index 1 because there are two bytes of protocol data. */
-	for (i = 1; i < len; i++) {
-		if (buf[i] == lang)
-			return 1;
-	}
-
-	return 0;
-}
-
-
-/* This function returns a newly allocated wide string containing the USB
-   device string numbered by the index. The returned string must be freed
-   by using free(). */
-static wchar_t *get_usb_string(libusb_device_handle *dev, uint8_t idx)
-{
-	char buf[512];
-	int len;
-	wchar_t *str = NULL;
-	wchar_t wbuf[256];
-
-	/* iconv variables */
-	iconv_t ic;
-	size_t inbytes;
-	size_t outbytes;
-	size_t res;
-#ifdef __FreeBSD__
-	const char *inptr;
-#else
-	char *inptr;
-#endif
-	char *outptr;
-
-	/* Determine which language to use. */
-	uint16_t lang;
-	lang = get_usb_code_for_current_locale();
-	if (!is_language_supported(dev, lang))
-		lang = get_first_language(dev);
-
-	/* Get the string from libusb. */
-	len = libusb_get_string_descriptor(dev,
-			idx,
-			lang,
-			(unsigned char*)buf,
-			sizeof(buf));
-	if (len < 0)
-		return NULL;
-
-	/* buf does not need to be explicitly NULL-terminated because
-	   it is only passed into iconv() which does not need it. */
-
-	/* Initialize iconv. */
-	ic = iconv_open("WCHAR_T", "UTF-16LE");
-	if (ic == (iconv_t)-1) {
-		LOG("iconv_open() failed\n");
-		return NULL;
-	}
-
-	/* Convert to native wchar_t (UTF-32 on glibc/BSD systems).
-	   Skip the first character (2-bytes). */
-	inptr = buf+2;
-	inbytes = len-2;
-	outptr = (char*) wbuf;
-	outbytes = sizeof(wbuf);
-	res = iconv(ic, &inptr, &inbytes, &outptr, &outbytes);
-	if (res == (size_t)-1) {
-		LOG("iconv() failed\n");
-		goto err;
-	}
-
-	/* Write the terminating NULL. */
-	wbuf[sizeof(wbuf)/sizeof(wbuf[0])-1] = 0x00000000;
-	if (outbytes >= sizeof(wbuf[0]))
-		*((wchar_t*)outptr) = 0x00000000;
-
-	/* Allocate and copy the string. */
-	str = wcsdup(wbuf);
-
-err:
-	iconv_close(ic);
-
-	return str;
-}
-
-static char *make_path(libusb_device *dev, int interface_number)
-{
-	char str[64];
-	snprintf(str, sizeof(str), "%04x:%04x:%02x",
-		libusb_get_bus_number(dev),
-		libusb_get_device_address(dev),
-		interface_number);
-	str[sizeof(str)-1] = '\0';
-
-	return strdup(str);
-}
-
-
-int HID_API_EXPORT hid_init(void)
-{
-	if (!usb_context) {
-		const char *locale;
-
-		/* Init Libusb */
-		if (libusb_init(&usb_context))
-			return -1;
-
-		/* Set the locale if it's not set. */
-		locale = setlocale(LC_CTYPE, NULL);
-		if (!locale)
-			setlocale(LC_CTYPE, "");
-	}
-
-	return 0;
-}
-
-int HID_API_EXPORT hid_exit(void)
-{
-	if (usb_context) {
-		libusb_exit(usb_context);
-		usb_context = NULL;
-	}
-
-	return 0;
-}
-
-struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id, unsigned short product_id)
-{
-	libusb_device **devs;
-	libusb_device *dev;
-	libusb_device_handle *handle;
-	ssize_t num_devs;
-	int i = 0;
-
-	struct hid_device_info *root = NULL; /* return object */
-	struct hid_device_info *cur_dev = NULL;
-
-	if(hid_init() < 0)
-		return NULL;
-
-	num_devs = libusb_get_device_list(usb_context, &devs);
-	if (num_devs < 0)
-		return NULL;
-	while ((dev = devs[i++]) != NULL) {
-		struct libusb_device_descriptor desc;
-		struct libusb_config_descriptor *conf_desc = NULL;
-		int j, k;
-		int interface_num = 0;
-
-		int res = libusb_get_device_descriptor(dev, &desc);
-		unsigned short dev_vid = desc.idVendor;
-		unsigned short dev_pid = desc.idProduct;
-
-		res = libusb_get_active_config_descriptor(dev, &conf_desc);
-		if (res < 0)
-			libusb_get_config_descriptor(dev, 0, &conf_desc);
-		if (conf_desc) {
-			for (j = 0; j < conf_desc->bNumInterfaces; j++) {
-				const struct libusb_interface *intf = &conf_desc->interface[j];
-				for (k = 0; k < intf->num_altsetting; k++) {
-					const struct libusb_interface_descriptor *intf_desc;
-					intf_desc = &intf->altsetting[k];
-					if (intf_desc->bInterfaceClass == LIBUSB_CLASS_HID) {
-						interface_num = intf_desc->bInterfaceNumber;
-
-						/* Check the VID/PID against the arguments */
-						if ((vendor_id == 0x0 || vendor_id == dev_vid) &&
-						    (product_id == 0x0 || product_id == dev_pid)) {
-							struct hid_device_info *tmp;
-
-							/* VID/PID match. Create the record. */
-							tmp = calloc(1, sizeof(struct hid_device_info));
-							if (cur_dev) {
-								cur_dev->next = tmp;
-							}
-							else {
-								root = tmp;
-							}
-							cur_dev = tmp;
-
-							/* Fill out the record */
-							cur_dev->next = NULL;
-							cur_dev->path = make_path(dev, interface_num);
-
-							res = libusb_open(dev, &handle);
-
-							if (res >= 0) {
-								/* Serial Number */
-								if (desc.iSerialNumber > 0)
-									cur_dev->serial_number =
-										get_usb_string(handle, desc.iSerialNumber);
-
-								/* Manufacturer and Product strings */
-								if (desc.iManufacturer > 0)
-									cur_dev->manufacturer_string =
-										get_usb_string(handle, desc.iManufacturer);
-								if (desc.iProduct > 0)
-									cur_dev->product_string =
-										get_usb_string(handle, desc.iProduct);
-
-#ifdef INVASIVE_GET_USAGE
-{
-							/*
-							This section is removed because it is too
-							invasive on the system. Getting a Usage Page
-							and Usage requires parsing the HID Report
-							descriptor. Getting a HID Report descriptor
-							involves claiming the interface. Claiming the
-							interface involves detaching the kernel driver.
-							Detaching the kernel driver is hard on the system
-							because it will unclaim interfaces (if another
-							app has them claimed) and the re-attachment of
-							the driver will sometimes change /dev entry names.
-							It is for these reasons that this section is
-							#if 0. For composite devices, use the interface
-							field in the hid_device_info struct to distinguish
-							between interfaces. */
-								unsigned char data[256];
-#ifdef DETACH_KERNEL_DRIVER
-								int detached = 0;
-								/* Usage Page and Usage */
-								res = libusb_kernel_driver_active(handle, interface_num);
-								if (res == 1) {
-									res = libusb_detach_kernel_driver(handle, interface_num);
-									if (res < 0)
-										LOG("Couldn't detach kernel driver, even though a kernel driver was attached.");
-									else
-										detached = 1;
-								}
-#endif
-								res = libusb_claim_interface(handle, interface_num);
-								if (res >= 0) {
-									/* Get the HID Report Descriptor. */
-									res = libusb_control_transfer(handle, LIBUSB_ENDPOINT_IN|LIBUSB_RECIPIENT_INTERFACE, LIBUSB_REQUEST_GET_DESCRIPTOR, (LIBUSB_DT_REPORT << 8)|interface_num, 0, data, sizeof(data), 5000);
-									if (res >= 0) {
-										unsigned short page=0, usage=0;
-										/* Parse the usage and usage page
-										   out of the report descriptor. */
-										get_usage(data, res,  &page, &usage);
-										cur_dev->usage_page = page;
-										cur_dev->usage = usage;
-									}
-									else
-										LOG("libusb_control_transfer() for getting the HID report failed with %d\n", res);
-
-									/* Release the interface */
-									res = libusb_release_interface(handle, interface_num);
-									if (res < 0)
-										LOG("Can't release the interface.\n");
-								}
-								else
-									LOG("Can't claim interface %d\n", res);
-#ifdef DETACH_KERNEL_DRIVER
-								/* Re-attach kernel driver if necessary. */
-								if (detached) {
-									res = libusb_attach_kernel_driver(handle, interface_num);
-									if (res < 0)
-										LOG("Couldn't re-attach kernel driver.\n");
-								}
-#endif
-}
-#endif /* INVASIVE_GET_USAGE */
-
-								libusb_close(handle);
-							}
-							/* VID/PID */
-							cur_dev->vendor_id = dev_vid;
-							cur_dev->product_id = dev_pid;
-
-							/* Release Number */
-							cur_dev->release_number = desc.bcdDevice;
-
-							/* Interface Number */
-							cur_dev->interface_number = interface_num;
-						}
-					}
-				} /* altsettings */
-			} /* interfaces */
-			libusb_free_config_descriptor(conf_desc);
-		}
-	}
-
-	libusb_free_device_list(devs, 1);
-
-	return root;
-}
-
-void  HID_API_EXPORT hid_free_enumeration(struct hid_device_info *devs)
-{
-	struct hid_device_info *d = devs;
-	while (d) {
-		struct hid_device_info *next = d->next;
-		free(d->path);
-		free(d->serial_number);
-		free(d->manufacturer_string);
-		free(d->product_string);
-		free(d);
-		d = next;
-	}
-}
-
-hid_device * hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number)
-{
-	struct hid_device_info *devs, *cur_dev;
-	const char *path_to_open = NULL;
-	hid_device *handle = NULL;
-
-	devs = hid_enumerate(vendor_id, product_id);
-	cur_dev = devs;
-	while (cur_dev) {
-		if (cur_dev->vendor_id == vendor_id &&
-		    cur_dev->product_id == product_id) {
-			if (serial_number) {
-				if (wcscmp(serial_number, cur_dev->serial_number) == 0) {
-					path_to_open = cur_dev->path;
-					break;
-				}
-			}
-			else {
-				path_to_open = cur_dev->path;
-				break;
-			}
-		}
-		cur_dev = cur_dev->next;
-	}
-
-	if (path_to_open) {
-		/* Open the device */
-		handle = hid_open_path(path_to_open);
-	}
-
-	hid_free_enumeration(devs);
-
-	return handle;
-}
-
-static void read_callback(struct libusb_transfer *transfer)
-{
-	hid_device *dev = transfer->user_data;
-	int res;
-
-	if (transfer->status == LIBUSB_TRANSFER_COMPLETED) {
-
-		struct input_report *rpt = malloc(sizeof(*rpt));
-		rpt->data = malloc(transfer->actual_length);
-		memcpy(rpt->data, transfer->buffer, transfer->actual_length);
-		rpt->len = transfer->actual_length;
-		rpt->next = NULL;
-
-		pthread_mutex_lock(&dev->mutex);
-
-		/* Attach the new report object to the end of the list. */
-		if (dev->input_reports == NULL) {
-			/* The list is empty. Put it at the root. */
-			dev->input_reports = rpt;
-			pthread_cond_signal(&dev->condition);
-		}
-		else {
-			/* Find the end of the list and attach. */
-			struct input_report *cur = dev->input_reports;
-			int num_queued = 0;
-			while (cur->next != NULL) {
-				cur = cur->next;
-				num_queued++;
-			}
-			cur->next = rpt;
-
-			/* Pop one off if we've reached 30 in the queue. This
-			   way we don't grow forever if the user never reads
-			   anything from the device. */
-			if (num_queued > 30) {
-				return_data(dev, NULL, 0);
-			}
-		}
-		pthread_mutex_unlock(&dev->mutex);
-	}
-	else if (transfer->status == LIBUSB_TRANSFER_CANCELLED) {
-		dev->shutdown_thread = 1;
-		dev->cancelled = 1;
-		return;
-	}
-	else if (transfer->status == LIBUSB_TRANSFER_NO_DEVICE) {
-		dev->shutdown_thread = 1;
-		dev->cancelled = 1;
-		return;
-	}
-	else if (transfer->status == LIBUSB_TRANSFER_TIMED_OUT) {
-		//LOG("Timeout (normal)\n");
-	}
-	else {
-		LOG("Unknown transfer code: %d\n", transfer->status);
-	}
-
-	/* Re-submit the transfer object. */
-	res = libusb_submit_transfer(transfer);
-	if (res != 0) {
-		LOG("Unable to submit URB. libusb error code: %d\n", res);
-		dev->shutdown_thread = 1;
-		dev->cancelled = 1;
-	}
-}
-
-
-static void *read_thread(void *param)
-{
-	hid_device *dev = param;
-	unsigned char *buf;
-	const size_t length = dev->input_ep_max_packet_size;
-
-	/* Set up the transfer object. */
-	buf = malloc(length);
-	dev->transfer = libusb_alloc_transfer(0);
-	libusb_fill_interrupt_transfer(dev->transfer,
-		dev->device_handle,
-		dev->input_endpoint,
-		buf,
-		length,
-		read_callback,
-		dev,
-		5000/*timeout*/);
-
-	/* Make the first submission. Further submissions are made
-	   from inside read_callback() */
-	libusb_submit_transfer(dev->transfer);
-
-	/* Notify the main thread that the read thread is up and running. */
-	pthread_barrier_wait(&dev->barrier);
-
-	/* Handle all the events. */
-	while (!dev->shutdown_thread) {
-		int res;
-		res = libusb_handle_events(usb_context);
-		if (res < 0) {
-			/* There was an error. */
-			LOG("read_thread(): libusb reports error # %d\n", res);
-
-			/* Break out of this loop only on fatal error.*/
-			if (res != LIBUSB_ERROR_BUSY &&
-			    res != LIBUSB_ERROR_TIMEOUT &&
-			    res != LIBUSB_ERROR_OVERFLOW &&
-			    res != LIBUSB_ERROR_INTERRUPTED) {
-				break;
-			}
-		}
-	}
-
-	/* Cancel any transfer that may be pending. This call will fail
-	   if no transfers are pending, but that's OK. */
-	libusb_cancel_transfer(dev->transfer);
-
-	while (!dev->cancelled)
-		libusb_handle_events_completed(usb_context, &dev->cancelled);
-
-	/* Now that the read thread is stopping, Wake any threads which are
-	   waiting on data (in hid_read_timeout()). Do this under a mutex to
-	   make sure that a thread which is about to go to sleep waiting on
-	   the condition acutally will go to sleep before the condition is
-	   signaled. */
-	pthread_mutex_lock(&dev->mutex);
-	pthread_cond_broadcast(&dev->condition);
-	pthread_mutex_unlock(&dev->mutex);
-
-	/* The dev->transfer->buffer and dev->transfer objects are cleaned up
-	   in hid_close(). They are not cleaned up here because this thread
-	   could end either due to a disconnect or due to a user
-	   call to hid_close(). In both cases the objects can be safely
-	   cleaned up after the call to pthread_join() (in hid_close()), but
-	   since hid_close() calls libusb_cancel_transfer(), on these objects,
-	   they can not be cleaned up here. */
-
-	return NULL;
-}
-
-
-hid_device * HID_API_EXPORT hid_open_path(const char *path)
-{
-	hid_device *dev = NULL;
-
-	libusb_device **devs;
-	libusb_device *usb_dev;
-	int res;
-	int d = 0;
-	int good_open = 0;
-
-	if(hid_init() < 0)
-		return NULL;
-
-	dev = new_hid_device();
-
-	libusb_get_device_list(usb_context, &devs);
-	while ((usb_dev = devs[d++]) != NULL) {
-		struct libusb_device_descriptor desc;
-		struct libusb_config_descriptor *conf_desc = NULL;
-		int i,j,k;
-		libusb_get_device_descriptor(usb_dev, &desc);
-
-		if (libusb_get_active_config_descriptor(usb_dev, &conf_desc) < 0)
-			continue;
-		for (j = 0; j < conf_desc->bNumInterfaces; j++) {
-			const struct libusb_interface *intf = &conf_desc->interface[j];
-			for (k = 0; k < intf->num_altsetting; k++) {
-				const struct libusb_interface_descriptor *intf_desc;
-				intf_desc = &intf->altsetting[k];
-				if (intf_desc->bInterfaceClass == LIBUSB_CLASS_HID) {
-					char *dev_path = make_path(usb_dev, intf_desc->bInterfaceNumber);
-					if (!strcmp(dev_path, path)) {
-						/* Matched Paths. Open this device */
-
-						/* OPEN HERE */
-						res = libusb_open(usb_dev, &dev->device_handle);
-						if (res < 0) {
-							LOG("can't open device\n");
-							free(dev_path);
-							break;
-						}
-						good_open = 1;
-#ifdef DETACH_KERNEL_DRIVER
-						/* Detach the kernel driver, but only if the
-						   device is managed by the kernel */
-						if (libusb_kernel_driver_active(dev->device_handle, intf_desc->bInterfaceNumber) == 1) {
-							res = libusb_detach_kernel_driver(dev->device_handle, intf_desc->bInterfaceNumber);
-							if (res < 0) {
-								libusb_close(dev->device_handle);
-								LOG("Unable to detach Kernel Driver\n");
-								free(dev_path);
-								good_open = 0;
-								break;
-							}
-						}
-#endif
-						res = libusb_claim_interface(dev->device_handle, intf_desc->bInterfaceNumber);
-						if (res < 0) {
-							LOG("can't claim interface %d: %d\n", intf_desc->bInterfaceNumber, res);
-							free(dev_path);
-							libusb_close(dev->device_handle);
-							good_open = 0;
-							break;
-						}
-
-						/* Store off the string descriptor indexes */
-						dev->manufacturer_index = desc.iManufacturer;
-						dev->product_index      = desc.iProduct;
-						dev->serial_index       = desc.iSerialNumber;
-
-						/* Store off the interface number */
-						dev->interface = intf_desc->bInterfaceNumber;
-
-						/* Find the INPUT and OUTPUT endpoints. An
-						   OUTPUT endpoint is not required. */
-						for (i = 0; i < intf_desc->bNumEndpoints; i++) {
-							const struct libusb_endpoint_descriptor *ep
-								= &intf_desc->endpoint[i];
-
-							/* Determine the type and direction of this
-							   endpoint. */
-							int is_interrupt =
-								(ep->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK)
-							      == LIBUSB_TRANSFER_TYPE_INTERRUPT;
-							int is_output =
-								(ep->bEndpointAddress & LIBUSB_ENDPOINT_DIR_MASK)
-							      == LIBUSB_ENDPOINT_OUT;
-							int is_input =
-								(ep->bEndpointAddress & LIBUSB_ENDPOINT_DIR_MASK)
-							      == LIBUSB_ENDPOINT_IN;
-
-							/* Decide whether to use it for intput or output. */
-							if (dev->input_endpoint == 0 &&
-							    is_interrupt && is_input) {
-								/* Use this endpoint for INPUT */
-								dev->input_endpoint = ep->bEndpointAddress;
-								dev->input_ep_max_packet_size = ep->wMaxPacketSize;
-							}
-							if (dev->output_endpoint == 0 &&
-							    is_interrupt && is_output) {
-								/* Use this endpoint for OUTPUT */
-								dev->output_endpoint = ep->bEndpointAddress;
-							}
-						}
-
-						pthread_create(&dev->thread, NULL, read_thread, dev);
-
-						/* Wait here for the read thread to be initialized. */
-						pthread_barrier_wait(&dev->barrier);
-
-					}
-					free(dev_path);
-				}
-			}
-		}
-		libusb_free_config_descriptor(conf_desc);
-
-	}
-
-	libusb_free_device_list(devs, 1);
-
-	/* If we have a good handle, return it. */
-	if (good_open) {
-		return dev;
-	}
-	else {
-		/* Unable to open any devices. */
-		free_hid_device(dev);
-		return NULL;
-	}
-}
-
-
-int HID_API_EXPORT hid_write(hid_device *dev, const unsigned char *data, size_t length)
-{
-	int res;
-	int report_number = data[0];
-	int skipped_report_id = 0;
-
-	if (report_number == 0x0) {
-		data++;
-		length--;
-		skipped_report_id = 1;
-	}
-
-
-	if (dev->output_endpoint <= 0) {
-		/* No interrput out endpoint. Use the Control Endpoint */
-		res = libusb_control_transfer(dev->device_handle,
-			LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_OUT,
-			0x09/*HID Set_Report*/,
-			(2/*HID output*/ << 8) | report_number,
-			dev->interface,
-			(unsigned char *)data, length,
-			1000/*timeout millis*/);
-
-		if (res < 0)
-			return -1;
-
-		if (skipped_report_id)
-			length++;
-
-		return length;
-	}
-	else {
-		/* Use the interrupt out endpoint */
-		int actual_length;
-		res = libusb_interrupt_transfer(dev->device_handle,
-			dev->output_endpoint,
-			(unsigned char*)data,
-			length,
-			&actual_length, 1000);
-
-		if (res < 0)
-			return -1;
-
-		if (skipped_report_id)
-			actual_length++;
-
-		return actual_length;
-	}
-}
-
-/* Helper function, to simplify hid_read().
-   This should be called with dev->mutex locked. */
-static int return_data(hid_device *dev, unsigned char *data, size_t length)
-{
-	/* Copy the data out of the linked list item (rpt) into the
-	   return buffer (data), and delete the liked list item. */
-	struct input_report *rpt = dev->input_reports;
-	size_t len = (length < rpt->len)? length: rpt->len;
-	if (len > 0)
-		memcpy(data, rpt->data, len);
-	dev->input_reports = rpt->next;
-	free(rpt->data);
-	free(rpt);
-	return len;
-}
-
-static void cleanup_mutex(void *param)
-{
-	hid_device *dev = param;
-	pthread_mutex_unlock(&dev->mutex);
-}
-
-
-int HID_API_EXPORT hid_read_timeout(hid_device *dev, unsigned char *data, size_t length, int milliseconds)
-{
-	int bytes_read = -1;
-
-#if 0
-	int transferred;
-	int res = libusb_interrupt_transfer(dev->device_handle, dev->input_endpoint, data, length, &transferred, 5000);
-	LOG("transferred: %d\n", transferred);
-	return transferred;
-#endif
-
-	pthread_mutex_lock(&dev->mutex);
-	pthread_cleanup_push(&cleanup_mutex, dev);
-
-	/* There's an input report queued up. Return it. */
-	if (dev->input_reports) {
-		/* Return the first one */
-		bytes_read = return_data(dev, data, length);
-		goto ret;
-	}
-
-	if (dev->shutdown_thread) {
-		/* This means the device has been disconnected.
-		   An error code of -1 should be returned. */
-		bytes_read = -1;
-		goto ret;
-	}
-
-	if (milliseconds == -1) {
-		/* Blocking */
-		while (!dev->input_reports && !dev->shutdown_thread) {
-			pthread_cond_wait(&dev->condition, &dev->mutex);
-		}
-		if (dev->input_reports) {
-			bytes_read = return_data(dev, data, length);
-		}
-	}
-	else if (milliseconds > 0) {
-		/* Non-blocking, but called with timeout. */
-		int res;
-		struct timespec ts;
-		clock_gettime(CLOCK_REALTIME, &ts);
-		ts.tv_sec += milliseconds / 1000;
-		ts.tv_nsec += (milliseconds % 1000) * 1000000;
-		if (ts.tv_nsec >= 1000000000L) {
-			ts.tv_sec++;
-			ts.tv_nsec -= 1000000000L;
-		}
-
-		while (!dev->input_reports && !dev->shutdown_thread) {
-			res = pthread_cond_timedwait(&dev->condition, &dev->mutex, &ts);
-			if (res == 0) {
-				if (dev->input_reports) {
-					bytes_read = return_data(dev, data, length);
-					break;
-				}
-
-				/* If we're here, there was a spurious wake up
-				   or the read thread was shutdown. Run the
-				   loop again (ie: don't break). */
-			}
-			else if (res == ETIMEDOUT) {
-				/* Timed out. */
-				bytes_read = 0;
-				break;
-			}
-			else {
-				/* Error. */
-				bytes_read = -1;
-				break;
-			}
-		}
-	}
-	else {
-		/* Purely non-blocking */
-		bytes_read = 0;
-	}
-
-ret:
-	pthread_mutex_unlock(&dev->mutex);
-	pthread_cleanup_pop(0);
-
-	return bytes_read;
-}
-
-int HID_API_EXPORT hid_read(hid_device *dev, unsigned char *data, size_t length)
-{
-	return hid_read_timeout(dev, data, length, dev->blocking ? -1 : 0);
-}
-
-int HID_API_EXPORT hid_set_nonblocking(hid_device *dev, int nonblock)
-{
-	dev->blocking = !nonblock;
-
-	return 0;
-}
-
-
-int HID_API_EXPORT hid_send_feature_report(hid_device *dev, const unsigned char *data, size_t length)
-{
-	int res = -1;
-	int skipped_report_id = 0;
-	int report_number = data[0];
-
-	if (report_number == 0x0) {
-		data++;
-		length--;
-		skipped_report_id = 1;
-	}
-
-	res = libusb_control_transfer(dev->device_handle,
-		LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_OUT,
-		0x09/*HID set_report*/,
-		(3/*HID feature*/ << 8) | report_number,
-		dev->interface,
-		(unsigned char *)data, length,
-		1000/*timeout millis*/);
-
-	if (res < 0)
-		return -1;
-
-	/* Account for the report ID */
-	if (skipped_report_id)
-		length++;
-
-	return length;
-}
-
-int HID_API_EXPORT hid_get_feature_report(hid_device *dev, unsigned char *data, size_t length)
-{
-	int res = -1;
-	int skipped_report_id = 0;
-	int report_number = data[0];
-
-	if (report_number == 0x0) {
-		/* Offset the return buffer by 1, so that the report ID
-		   will remain in byte 0. */
-		data++;
-		length--;
-		skipped_report_id = 1;
-	}
-	res = libusb_control_transfer(dev->device_handle,
-		LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_IN,
-		0x01/*HID get_report*/,
-		(3/*HID feature*/ << 8) | report_number,
-		dev->interface,
-		(unsigned char *)data, length,
-		1000/*timeout millis*/);
-
-	if (res < 0)
-		return -1;
-
-	if (skipped_report_id)
-		res++;
-
-	return res;
-}
-
-
-void HID_API_EXPORT hid_close(hid_device *dev)
-{
-	if (!dev)
-		return;
-
-	/* Cause read_thread() to stop. */
-	dev->shutdown_thread = 1;
-	libusb_cancel_transfer(dev->transfer);
-
-	/* Wait for read_thread() to end. */
-	pthread_join(dev->thread, NULL);
-
-	/* Clean up the Transfer objects allocated in read_thread(). */
-	free(dev->transfer->buffer);
-	libusb_free_transfer(dev->transfer);
-
-	/* release the interface */
-	libusb_release_interface(dev->device_handle, dev->interface);
-
-	/* Close the handle */
-	libusb_close(dev->device_handle);
-
-	/* Clear out the queue of received reports. */
-	pthread_mutex_lock(&dev->mutex);
-	while (dev->input_reports) {
-		return_data(dev, NULL, 0);
-	}
-	pthread_mutex_unlock(&dev->mutex);
-
-	free_hid_device(dev);
-}
-
-
-int HID_API_EXPORT_CALL hid_get_manufacturer_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return hid_get_indexed_string(dev, dev->manufacturer_index, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_product_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return hid_get_indexed_string(dev, dev->product_index, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_serial_number_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return hid_get_indexed_string(dev, dev->serial_index, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_indexed_string(hid_device *dev, int string_index, wchar_t *string, size_t maxlen)
-{
-	wchar_t *str;
-
-	str = get_usb_string(dev->device_handle, string_index);
-	if (str) {
-		wcsncpy(string, str, maxlen);
-		string[maxlen-1] = L'\0';
-		free(str);
-		return 0;
-	}
-	else
-		return -1;
-}
-
-
-HID_API_EXPORT const wchar_t * HID_API_CALL  hid_error(hid_device *dev)
-{
-	return NULL;
-}
-
-
-struct lang_map_entry {
-	const char *name;
-	const char *string_code;
-	uint16_t usb_code;
-};
-
-#define LANG(name,code,usb_code) { name, code, usb_code }
-static struct lang_map_entry lang_map[] = {
-	LANG("Afrikaans", "af", 0x0436),
-	LANG("Albanian", "sq", 0x041C),
-	LANG("Arabic - United Arab Emirates", "ar_ae", 0x3801),
-	LANG("Arabic - Bahrain", "ar_bh", 0x3C01),
-	LANG("Arabic - Algeria", "ar_dz", 0x1401),
-	LANG("Arabic - Egypt", "ar_eg", 0x0C01),
-	LANG("Arabic - Iraq", "ar_iq", 0x0801),
-	LANG("Arabic - Jordan", "ar_jo", 0x2C01),
-	LANG("Arabic - Kuwait", "ar_kw", 0x3401),
-	LANG("Arabic - Lebanon", "ar_lb", 0x3001),
-	LANG("Arabic - Libya", "ar_ly", 0x1001),
-	LANG("Arabic - Morocco", "ar_ma", 0x1801),
-	LANG("Arabic - Oman", "ar_om", 0x2001),
-	LANG("Arabic - Qatar", "ar_qa", 0x4001),
-	LANG("Arabic - Saudi Arabia", "ar_sa", 0x0401),
-	LANG("Arabic - Syria", "ar_sy", 0x2801),
-	LANG("Arabic - Tunisia", "ar_tn", 0x1C01),
-	LANG("Arabic - Yemen", "ar_ye", 0x2401),
-	LANG("Armenian", "hy", 0x042B),
-	LANG("Azeri - Latin", "az_az", 0x042C),
-	LANG("Azeri - Cyrillic", "az_az", 0x082C),
-	LANG("Basque", "eu", 0x042D),
-	LANG("Belarusian", "be", 0x0423),
-	LANG("Bulgarian", "bg", 0x0402),
-	LANG("Catalan", "ca", 0x0403),
-	LANG("Chinese - China", "zh_cn", 0x0804),
-	LANG("Chinese - Hong Kong SAR", "zh_hk", 0x0C04),
-	LANG("Chinese - Macau SAR", "zh_mo", 0x1404),
-	LANG("Chinese - Singapore", "zh_sg", 0x1004),
-	LANG("Chinese - Taiwan", "zh_tw", 0x0404),
-	LANG("Croatian", "hr", 0x041A),
-	LANG("Czech", "cs", 0x0405),
-	LANG("Danish", "da", 0x0406),
-	LANG("Dutch - Netherlands", "nl_nl", 0x0413),
-	LANG("Dutch - Belgium", "nl_be", 0x0813),
-	LANG("English - Australia", "en_au", 0x0C09),
-	LANG("English - Belize", "en_bz", 0x2809),
-	LANG("English - Canada", "en_ca", 0x1009),
-	LANG("English - Caribbean", "en_cb", 0x2409),
-	LANG("English - Ireland", "en_ie", 0x1809),
-	LANG("English - Jamaica", "en_jm", 0x2009),
-	LANG("English - New Zealand", "en_nz", 0x1409),
-	LANG("English - Phillippines", "en_ph", 0x3409),
-	LANG("English - Southern Africa", "en_za", 0x1C09),
-	LANG("English - Trinidad", "en_tt", 0x2C09),
-	LANG("English - Great Britain", "en_gb", 0x0809),
-	LANG("English - United States", "en_us", 0x0409),
-	LANG("Estonian", "et", 0x0425),
-	LANG("Farsi", "fa", 0x0429),
-	LANG("Finnish", "fi", 0x040B),
-	LANG("Faroese", "fo", 0x0438),
-	LANG("French - France", "fr_fr", 0x040C),
-	LANG("French - Belgium", "fr_be", 0x080C),
-	LANG("French - Canada", "fr_ca", 0x0C0C),
-	LANG("French - Luxembourg", "fr_lu", 0x140C),
-	LANG("French - Switzerland", "fr_ch", 0x100C),
-	LANG("Gaelic - Ireland", "gd_ie", 0x083C),
-	LANG("Gaelic - Scotland", "gd", 0x043C),
-	LANG("German - Germany", "de_de", 0x0407),
-	LANG("German - Austria", "de_at", 0x0C07),
-	LANG("German - Liechtenstein", "de_li", 0x1407),
-	LANG("German - Luxembourg", "de_lu", 0x1007),
-	LANG("German - Switzerland", "de_ch", 0x0807),
-	LANG("Greek", "el", 0x0408),
-	LANG("Hebrew", "he", 0x040D),
-	LANG("Hindi", "hi", 0x0439),
-	LANG("Hungarian", "hu", 0x040E),
-	LANG("Icelandic", "is", 0x040F),
-	LANG("Indonesian", "id", 0x0421),
-	LANG("Italian - Italy", "it_it", 0x0410),
-	LANG("Italian - Switzerland", "it_ch", 0x0810),
-	LANG("Japanese", "ja", 0x0411),
-	LANG("Korean", "ko", 0x0412),
-	LANG("Latvian", "lv", 0x0426),
-	LANG("Lithuanian", "lt", 0x0427),
-	LANG("F.Y.R.O. Macedonia", "mk", 0x042F),
-	LANG("Malay - Malaysia", "ms_my", 0x043E),
-	LANG("Malay  Brunei", "ms_bn", 0x083E),
-	LANG("Maltese", "mt", 0x043A),
-	LANG("Marathi", "mr", 0x044E),
-	LANG("Norwegian - Bokml", "no_no", 0x0414),
-	LANG("Norwegian - Nynorsk", "no_no", 0x0814),
-	LANG("Polish", "pl", 0x0415),
-	LANG("Portuguese - Portugal", "pt_pt", 0x0816),
-	LANG("Portuguese - Brazil", "pt_br", 0x0416),
-	LANG("Raeto-Romance", "rm", 0x0417),
-	LANG("Romanian - Romania", "ro", 0x0418),
-	LANG("Romanian - Republic of Moldova", "ro_mo", 0x0818),
-	LANG("Russian", "ru", 0x0419),
-	LANG("Russian - Republic of Moldova", "ru_mo", 0x0819),
-	LANG("Sanskrit", "sa", 0x044F),
-	LANG("Serbian - Cyrillic", "sr_sp", 0x0C1A),
-	LANG("Serbian - Latin", "sr_sp", 0x081A),
-	LANG("Setsuana", "tn", 0x0432),
-	LANG("Slovenian", "sl", 0x0424),
-	LANG("Slovak", "sk", 0x041B),
-	LANG("Sorbian", "sb", 0x042E),
-	LANG("Spanish - Spain (Traditional)", "es_es", 0x040A),
-	LANG("Spanish - Argentina", "es_ar", 0x2C0A),
-	LANG("Spanish - Bolivia", "es_bo", 0x400A),
-	LANG("Spanish - Chile", "es_cl", 0x340A),
-	LANG("Spanish - Colombia", "es_co", 0x240A),
-	LANG("Spanish - Costa Rica", "es_cr", 0x140A),
-	LANG("Spanish - Dominican Republic", "es_do", 0x1C0A),
-	LANG("Spanish - Ecuador", "es_ec", 0x300A),
-	LANG("Spanish - Guatemala", "es_gt", 0x100A),
-	LANG("Spanish - Honduras", "es_hn", 0x480A),
-	LANG("Spanish - Mexico", "es_mx", 0x080A),
-	LANG("Spanish - Nicaragua", "es_ni", 0x4C0A),
-	LANG("Spanish - Panama", "es_pa", 0x180A),
-	LANG("Spanish - Peru", "es_pe", 0x280A),
-	LANG("Spanish - Puerto Rico", "es_pr", 0x500A),
-	LANG("Spanish - Paraguay", "es_py", 0x3C0A),
-	LANG("Spanish - El Salvador", "es_sv", 0x440A),
-	LANG("Spanish - Uruguay", "es_uy", 0x380A),
-	LANG("Spanish - Venezuela", "es_ve", 0x200A),
-	LANG("Southern Sotho", "st", 0x0430),
-	LANG("Swahili", "sw", 0x0441),
-	LANG("Swedish - Sweden", "sv_se", 0x041D),
-	LANG("Swedish - Finland", "sv_fi", 0x081D),
-	LANG("Tamil", "ta", 0x0449),
-	LANG("Tatar", "tt", 0X0444),
-	LANG("Thai", "th", 0x041E),
-	LANG("Turkish", "tr", 0x041F),
-	LANG("Tsonga", "ts", 0x0431),
-	LANG("Ukrainian", "uk", 0x0422),
-	LANG("Urdu", "ur", 0x0420),
-	LANG("Uzbek - Cyrillic", "uz_uz", 0x0843),
-	LANG("Uzbek  Latin", "uz_uz", 0x0443),
-	LANG("Vietnamese", "vi", 0x042A),
-	LANG("Xhosa", "xh", 0x0434),
-	LANG("Yiddish", "yi", 0x043D),
-	LANG("Zulu", "zu", 0x0435),
-	LANG(NULL, NULL, 0x0),
-};
-
-uint16_t get_usb_code_for_current_locale(void)
-{
-	char *locale;
-	char search_string[64];
-	char *ptr;
-	struct lang_map_entry *lang;
-
-	/* Get the current locale. */
-	locale = setlocale(0, NULL);
-	if (!locale)
-		return 0x0;
-
-	/* Make a copy of the current locale string. */
-	strncpy(search_string, locale, sizeof(search_string));
-	search_string[sizeof(search_string)-1] = '\0';
-
-	/* Chop off the encoding part, and make it lower case. */
-	ptr = search_string;
-	while (*ptr) {
-		*ptr = tolower(*ptr);
-		if (*ptr == '.') {
-			*ptr = '\0';
-			break;
-		}
-		ptr++;
-	}
-
-	/* Find the entry which matches the string code of our locale. */
-	lang = lang_map;
-	while (lang->string_code) {
-		if (!strcmp(lang->string_code, search_string)) {
-			return lang->usb_code;
-		}
-		lang++;
-	}
-
-	/* There was no match. Find with just the language only. */
-	/* Chop off the variant. Chop it off at the '_'. */
-	ptr = search_string;
-	while (*ptr) {
-		*ptr = tolower(*ptr);
-		if (*ptr == '_') {
-			*ptr = '\0';
-			break;
-		}
-		ptr++;
-	}
-
-#if 0 /* TODO: Do we need this? */
-	/* Find the entry which matches the string code of our language. */
-	lang = lang_map;
-	while (lang->string_code) {
-		if (!strcmp(lang->string_code, search_string)) {
-			return lang->usb_code;
-		}
-		lang++;
-	}
-#endif
-
-	/* Found nothing. */
-	return 0x0;
-}
-
-#ifdef __cplusplus
-}
-#endif
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/libambit.c ../openambit.git/src/libambit/libambit.c
--- ./src/libambit/libambit.c	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/libambit/libambit.c	2015-03-20 20:47:45.908512152 +0100
@@ -21,8 +21,14 @@
  */
 #include "libambit.h"
 #include "libambit_int.h"
+#include "device_support.h"
+#include "device_driver.h"
+#include "protocol.h"
+#include "utils.h"
+#include "debug.h"
 
 #include <errno.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
@@ -34,221 +40,177 @@
 /*
  * Local definitions
  */
-#define SUUNTO_USB_VENDOR_ID 0x1493
-
-typedef struct ambit_known_device_s ambit_known_device_t;
-
-struct ambit_known_device_s {
-    uint16_t vid;
-    uint16_t pid;
-    char *model;
-    uint8_t min_sw_version[4];
-    char *name;
-    bool supported;
-    uint16_t pmem20_chunksize;
-};
+#define LIBAMBIT_MODEL_LENGTH    16
+#define LIBAMBIT_SERIAL_LENGTH   16
 
 /*
  * Static functions
  */
 static int device_info_get(ambit_object_t *object, ambit_device_info_t *info);
-static int lock_log(ambit_object_t *object, bool lock);
-static uint32_t version_number(const uint8_t version[4]);
+static ambit_device_info_t * ambit_device_info_new(const struct hid_device_info *dev);
 
 /*
  * Static variables
  */
-static ambit_known_device_t known_devices[] = {
-    { SUUNTO_USB_VENDOR_ID, 0x001c, "Finch", {0x00,0x00,0x00,0x00}, "Suunto Ambit3 Sport", false, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x001b, "Emu", {0x00,0x00,0x00,0x00}, "Suunto Ambit3 Peak", false, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x001d, "Greentit", {0x00,0x00,0x00,0x00}, "Suunto Ambit2 R", true, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x01,0x01,0x02,0x00}, "Suunto Ambit2 S", true, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x01,0x01,0x02,0x00}, "Suunto Ambit2", true, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x00,0x02,0x03,0x00}, "Suunto Ambit2 S", false, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x00,0x02,0x03,0x00}, "Suunto Ambit2", false, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x00,0x02,0x02,0x00}, "Suunto Ambit2 S (up to 0.2.2)", false, 0x0200 },
-    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x00,0x02,0x02,0x00}, "Suunto Ambit2 (up to 0.2.2)", false, 0x0200 },
-    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x02,0x01,0x00,0x00}, "Suunto Ambit", true, 0x0200 },
-    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x09,0x00,0x00}, "Suunto Ambit", false, 0x0200 }, /* First with PMEM 2.0!? */
-    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x06,0x00,0x00}, "Suunto Ambit", false, 0 },
-    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x01,0x00,0x00}, "Suunto Ambit", false, 0 },
-    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x00,0x00,0x00,0x00}, "Suunto Ambit", false, 0 },
-    { 0x0000, 0x0000, NULL, {0x00,0x00,0x00,0x00}, NULL, false }
-};
-
-static uint8_t komposti_version[] = { 0x01, 0x08, 0x01, 0x00 };
+static uint8_t komposti_version[] = { 0x02, 0x00, 0x2d, 0x00 };
 
 /*
  * Public functions
  */
-ambit_object_t *libambit_detect(void)
+ambit_device_info_t * libambit_enumerate(void)
 {
-    hid_device *handle;
-    struct hid_device_info *devs, *cur_dev;
-    ambit_object_t *ret_object = NULL;
-    int i;
-    ambit_known_device_t *device = NULL;
-    char *path = NULL;
+    ambit_device_info_t *devices = NULL;
 
-    LOG_INFO("Searching devices");
+    struct hid_device_info *devs = hid_enumerate(0, 0);
+    struct hid_device_info *current;
 
-    devs = hid_enumerate(0x0, 0x0);
-    cur_dev = devs;
-    while (cur_dev) {
-        LOG_INFO("vendor_id=%04x, product_id=%04x", cur_dev->vendor_id, cur_dev->product_id);
-        for (i=0; i<sizeof(known_devices)/sizeof(known_devices[0]); i++) {
-            if (cur_dev->vendor_id == known_devices[i].vid && cur_dev->product_id == known_devices[i].pid) {
-                LOG_INFO("match!");
-                // Found at least one supported row, lets remember that!
-                device = &known_devices[i];
-                path = strdup (cur_dev->path);
-                break;
-            }
-        }
-        if (device != NULL) {
-            // Devcice was found, we can stop looping through devices now...
-            break;
-        }
-        cur_dev = cur_dev->next;
+    if (!devs) {
+      LOG_WARNING("HID: no USB HID devices found");
+      return NULL;
     }
-    hid_free_enumeration(devs);
-
-    if (device != NULL) {
-        LOG_INFO("Trying to open device");
-        handle = hid_open(device->vid, device->pid, NULL);
-        if (handle != NULL) {
-            // Setup hid device correctly
-            hid_set_nonblocking(handle, 1);
-
-            ret_object = malloc(sizeof(ambit_object_t));
-            memset(ret_object, 0, sizeof(ambit_object_t));
-            ret_object->handle = handle;
-            ret_object->vendor_id = device->vid;
-            ret_object->product_id = device->pid;
-
-            // Get device info to resolve supported functionality
-            if (device_info_get(ret_object, &ret_object->device_info) == 0) {
-                // Let's resolve the correct device
-                for (i=0; i<sizeof(known_devices)/sizeof(known_devices[0]); i++) {
-                    if (ret_object->vendor_id == known_devices[i].vid &&
-                        ret_object->product_id == known_devices[i].pid &&
-                        strncmp(ret_object->device_info.model, known_devices[i].model, LIBAMBIT_MODEL_NAME_LENGTH) == 0 &&
-                        (version_number (ret_object->device_info.fw_version) >= version_number (known_devices[i].min_sw_version))) {
-                        // Found matching entry, reset to this one!
-                        device = &known_devices[i];
-                        break;
-                    }
-                }
-                strncpy(ret_object->device_info.name, device->name, LIBAMBIT_PRODUCT_NAME_LENGTH);
-                ret_object->device_info.is_supported = device->supported;
 
-                // Initialize pmem
-                libambit_pmem20_init(ret_object, device->pmem20_chunksize);
+    current = devs;
+    while (current) {
+        ambit_device_info_t *tmp = ambit_device_info_new(current);
 
-                LOG_INFO("Successfully opened device \"%s (%s)\" SW: %d.%d.%d, Supported: %s", device->name, device->model, ret_object->device_info.fw_version[0], ret_object->device_info.fw_version[1], ret_object->device_info.fw_version[3] << 8 | ret_object->device_info.fw_version[2], device->supported ? "YES" : "NO");
+        if (tmp) {
+            if (devices) {
+                tmp->next = devices;
             }
             else {
-                free(ret_object);
-                ret_object = NULL;
-                LOG_ERROR("Failed to get device info from \"%s (%s)\"", device->name, device->model);
+                devices = tmp;
             }
         }
-        else {
-#ifdef DEBUG_PRINT_ERROR
-            int error = 0;
-            int fd = 0;
-            if (path) fd = open (path, O_RDWR);
-            if (-1 == fd) error = errno;
-            else close (fd);
-#endif
-            LOG_ERROR("Failed to open device \"%s (%s)\"", device->name, device->model);
-            LOG_ERROR("Reason: %s", (error ? strerror(error) : "Unknown"));
-        }
+        current = current->next;
     }
+    hid_free_enumeration(devs);
 
-    if (path) free (path);
-    return ret_object;
+    return devices;
 }
 
-void libambit_close(ambit_object_t *object)
+void libambit_free_enumeration(ambit_device_info_t *devices)
 {
-    LOG_INFO("Closing");
-    if (object != NULL) {
-        if (object->handle != NULL) {
-            // Make sure to clear log lock (if possible)
-            lock_log(object, false);
-            hid_close(object->handle);
-        }
-
-        libambit_pmem20_deinit(object);
-        free(object);
+    while (devices) {
+        ambit_device_info_t *next = devices->next;
+        if (devices->name)   free(devices->name);
+        if (devices->model)  free(devices->model);
+        if (devices->serial) free(devices->serial);
+        free((char *) devices->path);
+        free(devices);
+        devices = next;
     }
 }
 
-bool libambit_device_supported(ambit_object_t *object)
+ambit_object_t * libambit_new(const ambit_device_info_t *device)
 {
-    bool ret = false;
+    ambit_object_t *object = NULL;
+    const ambit_known_device_t *known_device = NULL;
+    const char *path = NULL;
 
-    if (object != NULL) {
-        ret = object->device_info.is_supported;
+    if (!device || !device->path) {
+        LOG_ERROR("%s", strerror(EINVAL));
+        return NULL;
     }
 
-    return ret;
+    path = strdup (device->path);
+    if (!path) return NULL;
+
+    if (0 == device->access_status && device->is_supported) {
+        // Note, this should never fail if device was properly received with libambit_enumerate
+        known_device = libambit_device_support_find(device->vendor_id, device->product_id, device->model, device->fw_version);
+        if (known_device != NULL) {
+            object = calloc(1, sizeof(*object));
+            if (object) {
+                object->handle = hid_open_path(path);
+                memcpy(&object->device_info, device, sizeof(*device));
+                object->device_info.path = path;
+                object->driver = known_device->driver;
+
+                if (object->handle) {
+                    hid_set_nonblocking(object->handle, true);
+                }
+
+                // Initialize driver
+                object->driver->init(object, known_device->driver_param);
+            }
+        }
+    }
+    if (!object) {
+        free((char *) path);
+    }
+
+    return object;
 }
 
-int libambit_device_info_get(ambit_object_t *object, ambit_device_info_t *info)
+ambit_object_t * libambit_new_from_pathname(const char* pathname)
 {
-    int ret = -1;
+    ambit_object_t *object = NULL;
+    ambit_device_info_t *info;
+    ambit_device_info_t *current;
 
-    if (object != NULL) {
-        if (info != NULL) {
-            memcpy(info, &object->device_info, sizeof(ambit_device_info_t));
+    if (!pathname) {
+        LOG_ERROR("%s", strerror(EINVAL));
+        return NULL;
+    }
+
+    info = libambit_enumerate();
+    current = info;
+    while (!object && current) {
+        if (0 == strcmp(pathname, current->path)) {
+            object = libambit_new(current);
         }
-        ret = 0;
+        current = current->next;
     }
+    libambit_free_enumeration(info);
 
-    return ret;
+    return object;
+}
+
+void libambit_close(ambit_object_t *object)
+{
+    LOG_INFO("Closing");
+    if (object != NULL) {
+        if (object->driver != NULL) {
+            // Make sure to clear log lock (if possible)
+            if (object->driver->lock_log != NULL) {
+                object->driver->lock_log(object, false);
+            }
+            if (object->driver->deinit != NULL) {
+                object->driver->deinit(object);
+            }
+        }
+        if (object->handle != NULL) {
+            hid_close(object->handle);
+        }
+
+        free((char *) object->device_info.path);
+        free(object);
+    }
 }
 
 void libambit_sync_display_show(ambit_object_t *object)
 {
-    lock_log(object, true);
+    if (object->driver != NULL && object->driver->lock_log != NULL) {
+        object->driver->lock_log(object, true);
+    }
 }
 
 void libambit_sync_display_clear(ambit_object_t *object)
 {
-    lock_log(object, false);
+    if (object->driver != NULL && object->driver->lock_log != NULL) {
+        object->driver->lock_log(object, false);
+    }
 }
 
 int libambit_date_time_set(ambit_object_t *object, struct tm *tm)
 {
-    uint8_t date_data[8] = { 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00 };
-    uint8_t time_data[8];
     int ret = -1;
 
-    LOG_INFO("Writing date and time to clock");
-
-    // Set date
-    *(uint16_t*)(&date_data[0]) = htole16(1900 + tm->tm_year);
-    date_data[2] = 1 + tm->tm_mon;
-    date_data[3] = tm->tm_mday;
-    // byte[4-7] unknown (but set to 0x28000000 in moveslink)
-
-    // Set time (+date)
-    *(uint16_t*)(&time_data[0]) = htole16(1900 + tm->tm_year);
-    time_data[2] = 1 + tm->tm_mon;
-    time_data[3] = tm->tm_mday;
-    time_data[4] = tm->tm_hour;
-    time_data[5] = tm->tm_min;
-    *(uint16_t*)(&time_data[6]) = htole16(1000*tm->tm_sec);
-
-    if (libambit_protocol_command(object, ambit_command_date, date_data, sizeof(date_data), NULL, NULL, 0) == 0 &&
-        libambit_protocol_command(object, ambit_command_time, time_data, sizeof(time_data), NULL, NULL, 0) == 0) {
-
-        ret = 0;
+    if (object->driver != NULL && object->driver->date_time_set != NULL) {
+        ret = object->driver->date_time_set(object, tm);
     }
     else {
-        LOG_WARNING("Failed to write date and time");
+        LOG_WARNING("Driver does not support date_time_set");
     }
 
     return ret;
@@ -256,41 +218,27 @@
 
 int libambit_device_status_get(ambit_object_t *object, ambit_device_status_t *status)
 {
-    uint8_t *reply_data = NULL;
-    size_t replylen;
     int ret = -1;
 
-    LOG_INFO("Reading device status");
-
-    if (libambit_protocol_command(object, ambit_command_status, NULL, 0, &reply_data, &replylen, 0) == 0) {
-        if (status != NULL) {
-            status->charge = reply_data[1];
-        }
-        ret = 0;
+    if (object->driver != NULL && object->driver->status_get != NULL) {
+        ret = object->driver->status_get(object, status);
     }
     else {
-        LOG_WARNING("Failed to read device status");
+        LOG_WARNING("Driver does not support status_get");
     }
 
-    libambit_protocol_free(reply_data);
-
     return ret;
 }
 
 int libambit_personal_settings_get(ambit_object_t *object, ambit_personal_settings_t *settings)
 {
-    uint8_t *reply_data = NULL;
-    size_t replylen = 0;
     int ret = -1;
 
-    LOG_INFO("Reading personal settings");
-
-    if (libambit_protocol_command(object, ambit_command_personal_settings, NULL, 0, &reply_data, &replylen, 0) == 0) {
-        ret = libambit_personal_settings_parse(reply_data, replylen, settings);
-        libambit_protocol_free(reply_data);
+    if (object->driver != NULL && object->driver->personal_settings_get != NULL) {
+        ret = object->driver->personal_settings_get(object, settings);
     }
     else {
-        LOG_WARNING("Failed to read personal settings");
+        LOG_WARNING("Driver does not support personal_settings_get");
     }
 
     return ret;
@@ -298,18 +246,13 @@
 
 int libambit_gps_orbit_header_read(ambit_object_t *object, uint8_t data[8])
 {
-    uint8_t *reply_data = NULL;
-    size_t replylen = 0;
     int ret = -1;
 
-    if (libambit_protocol_command(object, ambit_command_gps_orbit_head, NULL, 0, &reply_data, &replylen, 0) == 0 && replylen >= 9) {
-        memcpy(data, &reply_data[1], 8);
-        libambit_protocol_free(reply_data);
-
-        ret = 0;
+    if (object->driver != NULL && object->driver->gps_orbit_header_read != NULL) {
+        ret = object->driver->gps_orbit_header_read(object, data);
     }
     else {
-        LOG_WARNING("Failed to read GPS orbit header");
+        LOG_WARNING("Driver does not support gps_orbit_header_read");
     }
 
     return ret;
@@ -317,31 +260,13 @@
 
 int libambit_gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen)
 {
-    uint8_t header[8], cmpheader[8];
     int ret = -1;
 
-    LOG_INFO("Writing GPS orbit data");
-
-    libambit_protocol_command(object, ambit_command_write_start, NULL, 0, NULL, NULL, 0);
-
-    if (libambit_gps_orbit_header_read(object, header) == 0) {
-        cmpheader[0] = data[7]; // Year, swap bytes
-        cmpheader[1] = data[6];
-        cmpheader[2] = data[8];
-        cmpheader[3] = data[9];
-        cmpheader[4] = data[13]; // 4 byte swap
-        cmpheader[5] = data[12];
-        cmpheader[6] = data[11];
-        cmpheader[7] = data[10];
-
-        // Check if new data differs 
-        if (memcmp(header, cmpheader, 8) != 0) {
-            ret = libambit_pmem20_gps_orbit_write(object, data, datalen);
-        }
-        else {
-            LOG_INFO("Current GPS orbit data is already up to date, skipping");
-            ret = 0;
-        }
+    if (object->driver != NULL && object->driver->gps_orbit_write != NULL) {
+        ret = object->driver->gps_orbit_write(object, data, datalen);
+    }
+    else {
+        LOG_WARNING("Driver does not support gps_orbit_write");
     }
 
     return ret;
@@ -349,138 +274,16 @@
 
 int libambit_log_read(ambit_object_t *object, ambit_log_skip_cb skip_cb, ambit_log_push_cb push_cb, ambit_log_progress_cb progress_cb, void *userref)
 {
-    int entries_read = 0;
-
-    uint8_t *reply_data = NULL;
-    size_t replylen = 0;
-    uint16_t log_entries_total = 0;
-    uint16_t log_entries_walked = 0;
-
-    uint32_t more = 0x00000400;
-
-    bool read_pmem = false;
-
-    ambit_log_header_t log_header;
-    ambit_log_entry_t *log_entry;
-
-    LOG_INFO("Reading number of logs");
-
-    /*
-     * Read number of log entries
-     */
-    if (libambit_protocol_command(object, ambit_command_log_count, NULL, 0, &reply_data, &replylen, 0) != 0) {
-        LOG_WARNING("Failed to read number of log entries");
-        return -1;
-    }
-    log_entries_total = le16toh(*(uint16_t*)(reply_data + 2));
-    libambit_protocol_free(reply_data);
-
-    LOG_INFO("Number of logs=%d", log_entries_total);
-
-    /*
-     * First part walks through headers to check if there is any point in start
-     * reading the PMEM content. If no skip callback is defined, there is no
-     * point in checking the headers, because no one can tell us to not include
-     * the logs...
-     */
-
-    if (skip_cb != NULL) {
-        LOG_INFO("Look in headers for new logs");
-        // Rewind
-        if (libambit_protocol_command(object, ambit_command_log_head_first, NULL, 0, &reply_data, &replylen, 0) != 0) {
-            LOG_WARNING("Failed to rewind header pointer");
-            return -1;
-        }
-        more = le32toh(*(uint32_t*)reply_data);
-        libambit_protocol_free(reply_data);
-
-        // Loop through logs while more entries exists
-        while (more == 0x00000400) {
-            LOG_INFO("Reading next header");
-            // Go to next entry
-            if (libambit_protocol_command(object, ambit_command_log_head_step, NULL, 0, &reply_data, &replylen, 0) != 0) {
-                LOG_WARNING("Failed to walk to next header");
-                return -1;
-            }
-            libambit_protocol_free(reply_data);
-
-            // Assume every header is composited by 2 parts, where only the
-            // second is of interrest right now
-            if (libambit_protocol_command(object, ambit_command_log_head, NULL, 0, &reply_data, &replylen, 0) != 0) {
-                LOG_WARNING("Failed to read first part of header");
-                return -1;
-            }
-            libambit_protocol_free(reply_data);
-
-            if (libambit_protocol_command(object, ambit_command_log_head, NULL, 0, &reply_data, &replylen, 0) == 0) {
-                if (replylen > 8 && libambit_pmem20_log_parse_header(reply_data + 8, replylen - 8, &log_header) == 0) {
-                    if (skip_cb(userref, &log_header) != 0) {
-                        // Header was NOT skipped, break out!
-                        read_pmem = true;
-                        LOG_INFO("Found new entry, start reading log data");
-                        break;
-                    }
-                }
-                else {
-                    LOG_ERROR("Failed to parse log header");
-                    return -1;
-                }
-                libambit_protocol_free(reply_data);
-            }
-            else {
-                LOG_WARNING("Failed to read second part of header");
-                return -1;
-            }
+    int ret = -1;
 
-            // Is there more entries to read?
-            if (libambit_protocol_command(object, ambit_command_log_head_peek, NULL, 0, &reply_data, &replylen, 0) != 0) {
-                LOG_WARNING("Failed to check for more headers");
-                return -1;
-            }
-            more = le32toh(*(uint32_t*)reply_data);
-            libambit_protocol_free(reply_data);
-        }
+    if (object->driver != NULL && object->driver->log_read != NULL) {
+        ret = object->driver->log_read(object, skip_cb, push_cb, progress_cb, userref);
     }
     else {
-        LOG_INFO("No skip callback defined, reading log data");
-        read_pmem = true;
+        LOG_WARNING("Driver does not support log_read");
     }
 
-    if (read_pmem) {
-        if (libambit_pmem20_log_init(object) != 0) {
-            return -1;
-        }
-
-        // Loop through all log entries, first check headers
-        while (log_entries_walked < log_entries_total && libambit_pmem20_log_next_header(object, &log_header) == 1) {
-            LOG_INFO("Reading header of log %d of %d", log_entries_walked + 1, log_entries_total);
-            if (progress_cb != NULL) {
-                progress_cb(userref, log_entries_total, log_entries_walked+1, 100*log_entries_walked/log_entries_total);
-            }
-            // Check if this entry needs to be read
-            if (skip_cb == NULL || skip_cb(userref, &log_header) != 0) {
-                LOG_INFO("Reading data of log %d of %d", log_entries_walked + 1, log_entries_total);
-                log_entry = libambit_pmem20_log_read_entry(object);
-                if (log_entry != NULL) {
-                    if (push_cb != NULL) {
-                        push_cb(userref, log_entry);
-                    }
-                    entries_read++;
-                }
-            }
-            else {
-                LOG_INFO("Log %d of %d already exists, skip reading data", log_entries_walked + 1, log_entries_total);
-            }
-            log_entries_walked++;
-            if (progress_cb != NULL) {
-                progress_cb(userref, log_entries_total, log_entries_walked, 100*log_entries_walked/log_entries_total);
-            }
-        }
-    }
-
-    LOG_INFO("%d entries read", entries_read);
-
-    return entries_read;
+    return ret;
 }
 
 void libambit_log_entry_free(ambit_log_entry_t *log_entry)
@@ -508,6 +311,9 @@
             }
             free(log_entry->samples);
         }
+        if (log_entry->header.activity_name) {
+            free(log_entry->header.activity_name);
+        }
         free(log_entry);
     }
 }
@@ -522,12 +328,14 @@
 
     if (libambit_protocol_command(object, ambit_command_device_info, komposti_version, sizeof(komposti_version), &reply_data, &replylen, 1) == 0) {
         if (info != NULL) {
-            memcpy(info->model, reply_data, 16);
-            info->model[16] = 0;
-            memcpy(info->serial, &reply_data[16], 16);
-            info->serial[16] = 0;
-            memcpy(info->fw_version, &reply_data[32], 4);
-            memcpy(info->hw_version, &reply_data[36], 4);
+            const char *p = (char *)reply_data;
+
+            info->model  = utf8memconv(p, LIBAMBIT_MODEL_LENGTH, NULL);
+            p += LIBAMBIT_MODEL_LENGTH;
+            info->serial = utf8memconv(p, LIBAMBIT_SERIAL_LENGTH, NULL);
+            p += LIBAMBIT_SERIAL_LENGTH;
+            memcpy(info->fw_version, p, 4);
+            memcpy(info->hw_version, p + 4, 4);
         }
         ret = 0;
     }
@@ -540,40 +348,164 @@
     return ret;
 }
 
-static int lock_log(ambit_object_t *object, bool lock)
+const size_t LIBAMBIT_VERSION_LENGTH = 13;      /* max: 255.255.65535 */
+static inline void version_string(char string[LIBAMBIT_VERSION_LENGTH+1],
+                                  const uint8_t version[4])
 {
-    int ret = -1;
-    uint8_t send_data[] = { 0x00, 0x00, 0x00, 0x00 };
-    uint8_t *reply_data = NULL;
-    size_t replylen;
+  if (!string || !version) return;
+
+  snprintf(string, LIBAMBIT_VERSION_LENGTH+1, "%d.%d.%d",
+           version[0], version[1], (version[2] << 0) | (version[3] << 8));
+}
+
+static ambit_device_info_t * ambit_device_info_new(const struct hid_device_info *dev)
+{
+    ambit_device_info_t *device = NULL;
+    const ambit_known_device_t *known_device = NULL;
 
-    uint32_t current_lock = 0xffffffff;
+    const char *dev_path;
 
-    if ((ret = libambit_protocol_command(object, ambit_command_lock_check, NULL, 0, &reply_data, &replylen, 0)) == 0) {
-        current_lock = le32toh(*(uint32_t*)reply_data);
-        libambit_protocol_free(reply_data);
-    }
-
-    if (lock && current_lock == 0) {
-        LOG_INFO("Setting Sync message to device display");
-        send_data[0] = 1;
-        ret = libambit_protocol_command(object, ambit_command_lock_set, send_data, sizeof(send_data), &reply_data, &replylen, 0);
-        libambit_protocol_free(reply_data);
-    }
-    else if (!lock && current_lock == 1) {
-        LOG_INFO("Clearing Sync message to device display");
-        send_data[0] = 0;
-        ret = libambit_protocol_command(object, ambit_command_lock_set, send_data, sizeof(send_data), &reply_data, &replylen, 0);
-        libambit_protocol_free(reply_data);
+    uint16_t vid;
+    uint16_t pid;
+
+    hid_device *hid;
+
+    if (!dev || !dev->path) {
+        LOG_ERROR("internal error: expecting hidraw device");
+        return NULL;
+    }
+
+    dev_path = dev->path;
+    vid = dev->vendor_id;
+    pid = dev->product_id;
+
+    if (!libambit_device_support_known(vid, pid)) {
+        LOG_INFO("ignoring unknown device (VID/PID: %04x/%04x)", vid, pid);
+        return NULL;
+    }
+
+    dev_path = strdup(dev_path);
+    if (!dev_path) return NULL;
+
+    device = calloc(1, sizeof(*device));
+    if (!device) {
+        free ((char *) dev_path);
+        return NULL;
+    }
+
+    device->path = dev_path;
+    device->vendor_id  = vid;
+    device->product_id = pid;
+
+    {                           /* create name for display purposes */
+        char *vendor  = utf8wcsconv(dev->manufacturer_string);
+        char *product = utf8wcsconv(dev->product_string);
+        if (vendor && product) {
+            char *name = (char *)malloc((strlen(vendor) + 1
+                                         + strlen(product) + 1)
+                                        * sizeof(char));
+            if (name) {
+                strcpy(name, vendor);
+                strcat(name, " ");
+                strcat(name, product);
+                free(vendor);
+                free(product);
+                device->name = name;
+            }
+            else {
+                device->name = product;
+                if (vendor) free(vendor);
+            }
+        }
+        else {
+            device->name = product;
+            if (vendor) free(vendor);
+        }
+        device->serial = utf8wcsconv(dev->serial_number);
     }
 
-    return ret;
-}
+    LOG_INFO("HID  : %s: '%s' (serial: %s, VID/PID: %04x/%04x)",
+             device->path, device->name, device->serial,
+             device->vendor_id, device->product_id);
+
+    hid = hid_open_path(device->path);
+    if (hid) {
+        /* HACK ALERT: minimally initialize an ambit object so we can
+         * call device_info_get().  Note that this function sets the
+         * device's model and serial string fields.  Above the latter
+         * has been set already using the HID information.
+         */
+        char *serial = device->serial;
+        ambit_object_t obj;
+        obj.handle = hid;
+        obj.sequence_no = 0;
+        if (0 == device_info_get(&obj, device)) {
 
-static uint32_t version_number(const uint8_t version[4])
-{
-    return (  (version[0] << 24)
-            | (version[1] << 16)
-            | (version[2] <<  0)
-            | (version[3] <<  8));
+            if (!device->serial) { /* fall back to HID information */
+                device->serial = serial;
+            }
+            else {
+                if (serial && 0 != strcmp(device->serial, serial)) {
+                  LOG_INFO("preferring F/W serial number over HID '%s'",
+                           serial);
+                }
+                if (serial) free(serial);
+            }
+
+            known_device = libambit_device_support_find(device->vendor_id, device->product_id, device->model, device->fw_version);
+            if (known_device != NULL) {
+                device->is_supported = known_device->supported;
+                if (device->name && known_device->name
+                    && 0 != strcmp(device->name, known_device->name)) {
+                    char *name = strdup(known_device->name);
+                    if (name) {
+                        LOG_INFO("preferring known name over HID '%s'",
+                                 device->name);
+                        free(device->name);
+                        device->name = name;
+                    }
+                }
+            }
+
+#ifdef DEBUG_PRINT_INFO
+            {
+                char fw_version[LIBAMBIT_VERSION_LENGTH+1];
+                char hw_version[LIBAMBIT_VERSION_LENGTH+1];
+                version_string(fw_version, device->fw_version);
+                version_string(hw_version, device->hw_version);
+
+                LOG_INFO("Ambit: %s: '%s' (serial: %s, VID/PID: %04x/%04x, "
+                         "nick: %s, F/W: %s, H/W: %s, supported: %s)",
+                         device->path, device->name, device->serial,
+                         device->vendor_id, device->product_id,
+                         device->model, fw_version, hw_version,
+                         (device->is_supported ? "YES" : "NO"));
+            }
+#endif
+        }
+        else {
+            LOG_ERROR("cannot get device info from %s", device->path);
+        }
+        hid_close(hid);
+    }
+    else {
+        /* Store an educated guess as to why we cannot open the HID
+         * device.  Without read/write access we cannot communicate
+         * to begin with but there may be other reasons.
+         */
+        int fd = open(device->path, O_RDWR);
+
+        if (-1 == fd) {
+            device->access_status = errno;
+            LOG_ERROR("cannot open HID device (%s): %s", device->path,
+                      strerror (device->access_status));
+        }
+        else {
+            LOG_WARNING("have read/write access to %s but cannot open HID "
+                        "device", device->path);
+            close(fd);
+        }
+    }
+
+    return device;
 }
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/libambit.h ../openambit.git/src/libambit/libambit.h
--- ./src/libambit/libambit.h	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/libambit/libambit.h	2015-03-20 20:47:45.908512152 +0100
@@ -30,19 +30,22 @@
 #include <stdbool.h>
 #include <time.h>
 
-#define LIBAMBIT_MODEL_NAME_LENGTH    16
-#define LIBAMBIT_SERIAL_LENGTH        16
-#define LIBAMBIT_PRODUCT_NAME_LENGTH  32
-
 typedef struct ambit_object_s ambit_object_t;
 
 typedef struct ambit_device_info_s {
-    char name[LIBAMBIT_PRODUCT_NAME_LENGTH+1];
-    char model[LIBAMBIT_MODEL_NAME_LENGTH+1];
-    char serial[LIBAMBIT_SERIAL_LENGTH+1];
+    char *name;                                        /* UTF-8 */
+    char *model;                                       /* UTF-8 */
+    char *serial;                                      /* UTF-8 */
     uint8_t fw_version[4];
     uint8_t hw_version[4];
-    bool is_supported;
+
+    const char *path;                   /* file system encoding */
+    uint16_t    vendor_id;
+    uint16_t    product_id;
+    bool        is_supported;
+    int         access_status;
+
+    struct ambit_device_info_s *next;
 } ambit_device_info_t;
 
 typedef struct ambit_device_status_s {
@@ -94,12 +97,15 @@
     uint8_t  is_male;
     uint8_t  length;
     uint8_t  alti_baro_mode;
+    uint8_t  storm_alarm;
     uint8_t  fused_alti_disabled;
     uint16_t bikepod_calibration;     /* scale 0.0001 */
     uint16_t bikepod_calibration2;    /* scale 0.0001 */
     uint16_t bikepod_calibration3;    /* scale 0.0001 */
     uint16_t footpod_calibration;     /* scale 0.0001 */
     uint8_t  automatic_bikepower_calib;
+    uint8_t  automatic_footpod_calib;
+    uint8_t  training_program;
 } ambit_personal_settings_t;
 
 typedef struct ambit_log_date_time_s {
@@ -124,8 +130,12 @@
     ambit_log_sample_type_gps_small = 0x0310,
     ambit_log_sample_type_gps_tiny = 0x0311,
     ambit_log_sample_type_time = 0x0312,
+    ambit_log_sample_type_swimming_turn = 0x0314,
+    ambit_log_sample_type_swimming_stroke = 0x0315,
     ambit_log_sample_type_activity = 0x0318,
+    ambit_log_sample_type_cadence_source = 0x031a,
     ambit_log_sample_type_position = 0x031b,
+    ambit_log_sample_type_fwinfo = 0x031c,
     ambit_log_sample_type_unknown = 0xf000
 } ambit_log_sample_type_t;
 
@@ -224,7 +234,12 @@
             uint16_t ibi[32];
         } ibi;
         uint16_t ttff;
-        uint8_t  distance_source;               /* 2 = GPS, 3 = Wrist */
+        uint8_t  distance_source;               /* 0x00 = Bikepod,
+                                                   0x01 = Footpod,
+                                                   0x02 = GPS,
+                                                   0x03 = Wrist,
+                                                   0x04 = Indoorswimming,
+                                                   0x05 = Outdoorswimming */
         struct {
             uint8_t event_type;                 /* 0x01 = manual lap,
                                                    0x14 = high interval end,
@@ -274,14 +289,31 @@
             uint8_t  second;
         } time;
         struct {
+            uint32_t distance;                  /* Total distance, meters scale: 0.01 */
+            uint16_t lengths;                   /* Total pool lengths */
+            uint16_t classification[4];
+            uint8_t  style;                     /* (style of previous length)
+                                                   0x00 = Other,
+                                                   0x01 = Butterfly,
+                                                   0x02 = Backstroke,
+                                                   0x03 = Breaststroke,
+                                                   0x04 = Freestyle,
+                                                   0x05 = Drill */
+        } swimming_turn;
+        struct {
             uint16_t activitytype;
             uint32_t custommode;
         } activity;
+        uint8_t cadence_source;                 /* 0x40 = Wrist */
         struct {
             int32_t  latitude;                  /* degree, scale: 0.0000001, -90 <= latitude <= 90 */
             int32_t  longitude;                 /* degree, scale: 0.0000001, -180 <= latitude <= 180 */
         } position;
         struct {
+            uint8_t version[4];
+            ambit_date_time_t build_date;
+        } fwinfo;
+        struct {
             size_t datalen;
             uint8_t *data;
         } unknown;
@@ -310,7 +342,7 @@
     uint32_t heartrate_min_time;    /* ms */
     uint8_t  peak_training_effect;  /* effect scale 0.1 */
     uint8_t  activity_type;
-    char     activity_name[16+1];   /* name of activity in ISO 8859-1 */
+    char    *activity_name;         /* name of activity in UTF-8 */
     int16_t  temperature_max;       /* degree celsius scale 0.1 */
     int16_t  temperature_min;       /* degree celsius scale 0.1 */
     uint32_t temperature_max_time;  /* ms */
@@ -327,9 +359,10 @@
     uint8_t  unknown2;
     uint8_t  cadence_max;           /* rpm */
     uint8_t  cadence_avg;           /* rpm */
-    uint8_t  unknown3[4];
+    uint8_t  unknown3[2];
+    uint16_t swimming_pool_lengths;
     uint32_t cadence_max_time;      /* ms */
-    uint8_t  unknown4[4];
+    uint32_t swimming_pool_length;  /* m */
     uint8_t  unknown5[4];
     uint8_t  unknown6[24];
 } ambit_log_header_t;
@@ -340,33 +373,37 @@
     ambit_log_sample_t *samples;
 } ambit_log_entry_t;
 
-/**
- * Try to detect clock
- * If clock detected, object handle is returned
- * \return object handle if clock found, else NULL
+/** \brief Create a list of all known Ambit clocks on the system
+ *
+ *  The list may include clocks that are not supported or cannot be
+ *  accessed.
  */
-ambit_object_t *libambit_detect(void);
+ambit_device_info_t * libambit_enumerate(void);
 
-/**
- * Close open Ambit object
- * \param object Object to close
+/** \brief Release resources acquired by libambit_enumerate()
  */
-void libambit_close(ambit_object_t *object);
+void libambit_free_enumeration(ambit_device_info_t *devices);
 
-/**
- * Check if detected device is currently supported
- * \param object Object to check
- * \return true if device supported, else false
+/** \brief Create an Ambit object for a clock
+ *
+ *  The pointer returned corresponds to a known, accessible and
+ *  supported clock.  In case no such clock is found \c NULL is
+ *  returned.
+ */
+ambit_object_t * libambit_new(const ambit_device_info_t *device);
+
+/** \brief Create an Ambit object from a \a pathname
+ *
+ *  Convenience function for when the path name for a clock is known.
+ *  These path names are platform dependent.
  */
-bool libambit_device_supported(ambit_object_t *object);
+ambit_object_t * libambit_new_from_pathname(const char *pathname);
 
 /**
- * Get device info on connected dev
- * \param object Object to get info from
- * \param status Status object to be filled
- * \return 0 on success, else -1
+ * Close open Ambit object
+ * \param object Object to close
  */
-int libambit_device_info_get(ambit_object_t *object, ambit_device_info_t *status);
+void libambit_close(ambit_object_t *object);
 
 /**
  * Set sync message to device display
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/libambit_int.h ../openambit.git/src/libambit/libambit_int.h
--- ./src/libambit/libambit_int.h	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/libambit/libambit_int.h	2014-11-05 21:53:14.000000000 +0100
@@ -28,127 +28,13 @@
 
 struct ambit_object_s {
     hid_device *handle;
-    uint16_t vendor_id;
-    uint16_t product_id;
     uint16_t sequence_no;
     ambit_device_info_t device_info;
 
-    struct {
-        uint16_t chunk_size;
-        struct {
-            bool initialized;
-            uint32_t first_entry;
-            uint32_t last_entry;
-            uint32_t entries;
-            uint32_t next_free_address;
-            struct {
-                uint32_t current;
-                uint32_t next;
-                uint32_t prev;
-            } current;
-            uint8_t *buffer;
-            uint8_t *chunks_read;
-        } log;
-    } pmem20;
+    struct ambit_device_driver_s *driver;
+    struct ambit_device_driver_data_s *driver_data; // Driver specific struct,
+                                                    // should be defined
+                                                    // locally for each driver
 };
 
-enum ambit_commands_e {
-    ambit_command_device_info        = 0x0000,
-    ambit_command_time               = 0x0300,
-    ambit_command_date               = 0x0302,
-    ambit_command_status             = 0x0306,
-    ambit_command_personal_settings  = 0x0b00,
-    ambit_command_unknown1           = 0x0b04,
-    ambit_command_log_count          = 0x0b06,
-    ambit_command_log_head_first     = 0x0b07,
-    ambit_command_log_head_peek      = 0x0b08,
-    ambit_command_log_head_step      = 0x0b0a,
-    ambit_command_log_head           = 0x0b0b,
-    ambit_command_gps_orbit_head     = 0x0b15,
-    ambit_command_data_write         = 0x0b16,
-    ambit_command_log_read           = 0x0b17,
-    ambit_command_data_tail_len      = 0x0b18,
-    ambit_command_lock_check         = 0x0b19,
-    ambit_command_lock_set           = 0x0b1a,
-    ambit_command_write_start        = 0x0b1b // Really!? Just a guess...
-};
-
-// crc16.c
-uint16_t crc16_ccitt_false(unsigned char *buf, size_t buflen);
-uint16_t crc16_ccitt_false_init(unsigned char *buf, size_t buflen, uint16_t crc);
-
-// personal.c
-int libambit_personal_settings_parse(uint8_t *data, size_t datalen, ambit_personal_settings_t *settings);
-
-// pmem20.c
-int libambit_pmem20_init(ambit_object_t *object, uint16_t chunk_size);
-int libambit_pmem20_deinit(ambit_object_t *object);
-int libambit_pmem20_log_init(ambit_object_t *object);
-int libambit_pmem20_log_deinit(ambit_object_t *object);
-int libambit_pmem20_log_next_header(ambit_object_t *object, ambit_log_header_t *log_header);
-ambit_log_entry_t *libambit_pmem20_log_read_entry(ambit_object_t *object);
-int libambit_pmem20_log_parse_header(uint8_t *data, size_t datalen, ambit_log_header_t *log_header);
-int libambit_pmem20_gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen);
-
-// protocol.c
-int libambit_protocol_command(ambit_object_t *object, uint16_t command, uint8_t *data, size_t datalen, uint8_t **reply_data, size_t *replylen, uint8_t legacy_format);
-void libambit_protocol_free(uint8_t *data);
-
-// debug.c
-typedef enum debug_level_e {
-    debug_level_err,
-    debug_level_warn,
-    debug_level_info
-} debug_level_t;
-void debug_printf(debug_level_t level, const char *file, int line, const char *func, const char *fmt, ...);
-#ifdef DEBUG_PRINT_ERROR
-#define LOG_ERROR(fmt, ...) debug_printf(debug_level_err, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
-#else
-#define LOG_ERROR(fmt, ...)
-#endif
-#ifdef DEBUG_PRINT_WARNING
-#define LOG_WARNING(fmt, ...) debug_printf(debug_level_warn, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
-#else
-#define LOG_WARNING(fmt, ...)
-#endif
-#ifdef DEBUG_PRINT_INFO
-#define LOG_INFO(fmt, ...) debug_printf(debug_level_info, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
-#else
-#define LOG_INFO(fmt, ...)
-#endif
-
-// static helpers
-static inline uint8_t read8(uint8_t *buf, size_t offset)
-{
-    return buf[offset];
-}
-
-static inline uint16_t read16(uint8_t *buf, size_t offset)
-{
-    return (buf[offset] | (buf[offset+1] << 8));
-}
-
-static inline uint32_t read32(uint8_t *buf, size_t offset)
-{
-    return (buf[offset] | (buf[offset+1] << 8) | (buf[offset+2] << 16) | (buf[offset+3] << 24));
-}
-
-static inline uint8_t read8inc(uint8_t *buf, size_t *offset)
-{
-    *offset += 1;
-    return buf[(*offset)-1];
-}
-
-static inline uint16_t read16inc(uint8_t *buf, size_t *offset)
-{
-    *offset += 2;
-    return (buf[(*offset)-2] | (buf[(*offset)-1] << 8));
-}
-
-static inline uint32_t read32inc(uint8_t *buf, size_t *offset)
-{
-    *offset += 4;
-    return (buf[(*offset)-4] | (buf[(*offset)-3] << 8) | (buf[(*offset)-2] << 16) | (buf[(*offset)-1] << 24));
-}
-
 #endif /* __LIBAMBIT_INT_H__ */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/libambit.rules ../openambit.git/src/libambit/libambit.rules
--- ./src/libambit/libambit.rules	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/libambit.rules	2015-03-20 20:47:45.908512152 +0100
@@ -0,0 +1,30 @@
+# Rules for Suunto Ambit devices
+# Change permissions so that libambit can communicate with these
+# devices for any user.
+
+ACTION!="add", GOTO="openambit_rules_end"
+ATTR{idVendor}!="1493", GOTO="openambit_rules_end"
+
+LABEL="openambit_rules_begin"
+
+# Bluebird (a.k.a Suunto Ambit)
+SUBSYSTEMS=="usb", ATTRS{idProduct}=="0010", ENV{openambit}="yes"
+
+# Duck (a.k.a Suunto Ambit2)
+SUBSYSTEMS=="usb", ATTRS{idProduct}=="0019", ENV{openambit}="yes"
+
+# Colibri (a.k.a Suunto Ambit2 S)
+SUBSYSTEMS=="usb", ATTRS{idProduct}=="001a", ENV{openambit}="yes"
+
+# Emu (a.k.a Suunto Ambit3 Peak)
+SUBSYSTEMS=="usb", ATTRS{idProduct}=="001b", ENV{openambit}="yes"
+
+# Finch (a.k.a Suunto Ambit3 Sport)
+SUBSYSTEMS=="usb", ATTRS{idProduct}=="001c", ENV{openambit}="yes"
+
+# Greentit (a.k.a Suunto Ambit2 R)
+SUBSYSTEMS=="usb", ATTRS{idProduct}=="001d", ENV{openambit}="yes"
+
+ENV{openambit}=="yes", MODE="0666", OWNER="root", GROUP="root"
+
+LABEL="openambit_rules_end"
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/personal.c ../openambit.git/src/libambit/personal.c
--- ./src/libambit/personal.c	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/libambit/personal.c	2015-03-20 20:47:45.908512152 +0100
@@ -19,8 +19,8 @@
  * Contributors:
  *
  */
-#include "libambit.h"
-#include "libambit_int.h"
+#include "personal.h"
+#include "utils.h"
 
 #include <stdlib.h>
 #include <string.h>
@@ -102,9 +102,7 @@
     offset += 3;
 
     settings->alti_baro_mode = read8inc(data, &offset);
-
-    offset += 1;
-
+    settings->storm_alarm = read8inc(data, &offset);
     settings->fused_alti_disabled = read8inc(data, &offset);
 
     offset = 0x80;
@@ -116,6 +114,10 @@
         settings->bikepod_calibration3 = read16inc(data, &offset);
         settings->footpod_calibration = read16inc(data, &offset);
         settings->automatic_bikepower_calib = read8inc(data, &offset);
+        settings->automatic_footpod_calib = read8inc(data, &offset);
+
+        offset = 0xba;
+        settings->training_program = read8inc(data, &offset);
     }
 
     return 0;
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/personal.h ../openambit.git/src/libambit/personal.h
--- ./src/libambit/personal.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/personal.h	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __PERSONAL_H__
+#define __PERSONAL_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include "libambit.h"
+
+int libambit_personal_settings_parse(uint8_t *data, size_t datalen, ambit_personal_settings_t *settings);
+
+#endif /* __PERSONAL_H__ */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/pmem20.c ../openambit.git/src/libambit/pmem20.c
--- ./src/libambit/pmem20.c	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/libambit/pmem20.c	2015-03-20 20:47:45.908512152 +0100
@@ -19,8 +19,11 @@
  * Contributors:
  *
  */
-#include "libambit.h"
-#include "libambit_int.h"
+#include "pmem20.h"
+#include "protocol.h"
+#include "sha256.h"
+#include "utils.h"
+#include "debug.h"
 
 #include <stdlib.h>
 #include <string.h>
@@ -29,8 +32,6 @@
 /*
  * Local definitions
  */
-#define PMEM20_LOG_START                  0x000f4240
-#define PMEM20_LOG_SIZE                   0x0029f630 /* 2 750 000 */
 #define PMEM20_LOG_WRAP_START_OFFSET      0x00000012
 #define PMEM20_LOG_WRAP_BUFFER_MARGIN     0x00010000 /* Max theoretical size of sample */
 #define PMEM20_LOG_HEADER_MIN_LEN                512 /* Header actually longer, but not interesting*/
@@ -46,10 +47,11 @@
 /*
  * Static functions
  */
-static int parse_sample(uint8_t *buf, size_t offset, uint8_t **spec, ambit_log_entry_t *log_entry, size_t *sample_count);
-static int read_upto(ambit_object_t *object, uint32_t address, uint32_t length);
-static int read_log_chunk(ambit_object_t *object, uint32_t address);
-static int write_data_chunk(ambit_object_t *object, uint32_t address, size_t buffer_count, uint8_t **buffers, size_t *buffer_sizes);
+static int parse_sample(uint8_t *buf, size_t offset, uint8_t **spec, ambit_log_entry_t *log_entry, size_t *sample_count, int32_t *time_compensators);
+static void correct_samples(ambit_log_entry_t *log_entry, int32_t *time_compensators);
+static int read_upto(libambit_pmem20_t *object, uint32_t address, uint32_t length);
+static int read_log_chunk(libambit_pmem20_t *object, uint32_t address, uint32_t length, uint8_t *buffer);
+static int write_data_chunk(ambit_object_t *object, uint32_t address, size_t buffer_count, const uint8_t **buffers, const size_t *buffer_sizes);
 static void add_time(ambit_date_time_t *intime, int32_t offset, ambit_date_time_t *outtime);
 static int is_leap(unsigned int y);
 static void to_timeval(ambit_date_time_t *ambit_time, struct timeval *timeval);
@@ -63,53 +65,58 @@
 /*
  * Public functions
  */
-int libambit_pmem20_init(ambit_object_t *object, uint16_t chunk_size)
+int libambit_pmem20_init(libambit_pmem20_t *object, ambit_object_t *ambit_object, uint16_t chunk_size)
 {
-    object->pmem20.chunk_size = chunk_size;
+    object->ambit_object = ambit_object;
+    object->chunk_size = chunk_size;
 
     return 0;
 }
 
-int libambit_pmem20_log_init(ambit_object_t *object)
+int libambit_pmem20_log_init(libambit_pmem20_t *object, uint32_t mem_start, uint32_t mem_size)
 {
     int ret = -1;
     size_t offset;
 
     // Allocate buffer for complete memory
-    if (object->pmem20.log.buffer != NULL) {
-        free(object->pmem20.log.buffer);
+    if (object->log.buffer != NULL) {
+        free(object->log.buffer);
     }
-    if (object->pmem20.log.chunks_read != NULL) {
-        free(object->pmem20.log.chunks_read);
+    if (object->log.chunks_read != NULL) {
+        free(object->log.chunks_read);
     }
-    memset(&object->pmem20.log, 0, sizeof(object->pmem20.log));
+    memset(&object->log, 0, sizeof(object->log));
 
-    object->pmem20.log.buffer = malloc(PMEM20_LOG_SIZE + PMEM20_LOG_WRAP_BUFFER_MARGIN);
-    object->pmem20.log.chunks_read = malloc((PMEM20_LOG_SIZE/object->pmem20.chunk_size)+1);
+    // Set memory structure
+    object->log.mem_start = mem_start;
+    object->log.mem_size = mem_size;
 
-    if (object->pmem20.log.buffer != NULL && object->pmem20.log.chunks_read != NULL) {
+    object->log.buffer = malloc(object->log.mem_size + PMEM20_LOG_WRAP_BUFFER_MARGIN);
+    object->log.chunks_read = malloc((object->log.mem_size/object->chunk_size)+1);
+
+    if (object->log.buffer != NULL && object->log.chunks_read != NULL) {
         // Set all chunks to NOT read
-        memset(object->pmem20.log.chunks_read, 0, (PMEM20_LOG_SIZE/object->pmem20.chunk_size)+1);
+        memset(object->log.chunks_read, 0, (object->log.mem_size/object->chunk_size)+1);
 
         // Read initial log header
         LOG_INFO("Reading first log data chunk");
-        ret = read_log_chunk(object, PMEM20_LOG_START);
-        
+        ret = read_log_chunk(object, object->log.mem_start, object->chunk_size, object->log.buffer);
+
         if (ret == 0) {
             // Parse PMEM header
             offset = 0;
-            object->pmem20.log.last_entry = read32inc(object->pmem20.log.buffer, &offset);
-            object->pmem20.log.first_entry = read32inc(object->pmem20.log.buffer, &offset);
-            object->pmem20.log.entries = read32inc(object->pmem20.log.buffer, &offset);
-            object->pmem20.log.next_free_address = read32inc(object->pmem20.log.buffer, &offset);
-            object->pmem20.log.current.current = PMEM20_LOG_START;
-            object->pmem20.log.current.next = object->pmem20.log.first_entry;
-            object->pmem20.log.current.prev = PMEM20_LOG_START;
+            object->log.last_entry = read32inc(object->log.buffer, &offset);
+            object->log.first_entry = read32inc(object->log.buffer, &offset);
+            object->log.entries = read32inc(object->log.buffer, &offset);
+            object->log.next_free_address = read32inc(object->log.buffer, &offset);
+            object->log.current.current = object->log.mem_start;
+            object->log.current.next = object->log.first_entry;
+            object->log.current.prev = object->log.mem_start;
 
-            LOG_INFO("log data header read, entries=%d, first_entry=%08x, last_entry=%08x, next_free_address=%08x", object->pmem20.log.entries, object->pmem20.log.first_entry, object->pmem20.log.last_entry, object->pmem20.log.next_free_address);
+            LOG_INFO("log data header read, entries=%d, first_entry=%08x, last_entry=%08x, next_free_address=%08x", object->log.entries, object->log.first_entry, object->log.last_entry, object->log.next_free_address);
 
             // Set initialized
-            object->pmem20.log.initialized = true;
+            object->log.initialized = true;
         }
         else {
             LOG_WARNING("Failed to read first data chunk");
@@ -119,20 +126,20 @@
     return ret;
 }
 
-int libambit_pmem20_deinit(ambit_object_t *object)
+int libambit_pmem20_deinit(libambit_pmem20_t *object)
 {
-    if (object->pmem20.log.buffer != NULL) {
-        free(object->pmem20.log.buffer);
+    if (object->log.buffer != NULL) {
+        free(object->log.buffer);
     }
-    if (object->pmem20.log.chunks_read != NULL) {
-        free(object->pmem20.log.chunks_read);
+    if (object->log.chunks_read != NULL) {
+        free(object->log.chunks_read);
     }
-    memset(&object->pmem20.log, 0, sizeof(object->pmem20.log));
+    memset(&object->log, 0, sizeof(object->log));
 
     return 0;
 }
 
-int libambit_pmem20_log_next_header(ambit_object_t *object, ambit_log_header_t *log_header)
+int libambit_pmem20_log_next_header(libambit_pmem20_t *object, ambit_log_header_t *log_header)
 {
     int ret = -1;
     size_t buffer_offset;
@@ -140,29 +147,29 @@
 
     LOG_INFO("Reading header of next log entry");
 
-    if (!object->pmem20.log.initialized) {
+    if (!object->log.initialized) {
         LOG_ERROR("Trying to get next log without initialization");
         return -1;
     }
 
     // Check if we reached end of entries
-    if (object->pmem20.log.current.current == object->pmem20.log.current.next) {
+    if (object->log.current.current == object->log.current.next) {
         LOG_INFO("No more entries to read");
         return 0;
     }
 
-    if (read_upto(object, object->pmem20.log.current.next, PMEM20_LOG_HEADER_MIN_LEN) == 0) {
-        buffer_offset = (object->pmem20.log.current.next - PMEM20_LOG_START);
+    if (read_upto(object, object->log.current.next, PMEM20_LOG_HEADER_MIN_LEN) == 0) {
+        buffer_offset = (object->log.current.next - object->log.mem_start);
         // First check that header seems to be correctly present
-        if (strncmp((char*)object->pmem20.log.buffer + buffer_offset, "PMEM", 4) == 0) {
-            object->pmem20.log.current.current = object->pmem20.log.current.next;
+        if (strncmp((char*)object->log.buffer + buffer_offset, "PMEM", 4) == 0) {
+            object->log.current.current = object->log.current.next;
             buffer_offset += 4;
-            object->pmem20.log.current.next = read32inc(object->pmem20.log.buffer, &buffer_offset);
-            object->pmem20.log.current.prev = read32inc(object->pmem20.log.buffer, &buffer_offset);
-            tmp_len = read16inc(object->pmem20.log.buffer, &buffer_offset);
+            object->log.current.next = read32inc(object->log.buffer, &buffer_offset);
+            object->log.current.prev = read32inc(object->log.buffer, &buffer_offset);
+            tmp_len = read16inc(object->log.buffer, &buffer_offset);
             buffer_offset += tmp_len;
-            tmp_len = read16inc(object->pmem20.log.buffer, &buffer_offset);
-            if (libambit_pmem20_log_parse_header(object->pmem20.log.buffer + buffer_offset, tmp_len, log_header) == 0) {
+            tmp_len = read16inc(object->log.buffer, &buffer_offset);
+            if (libambit_pmem20_log_parse_header(object->log.buffer + buffer_offset, tmp_len, log_header) == 0) {
                 LOG_INFO("Log entry header parsed");
                 ret = 1;
             }
@@ -180,61 +187,72 @@
 
     // Unset initialized of something went wrong
     if (ret < 0) {
-        object->pmem20.log.initialized = false;
+        object->log.initialized = false;
     }
 
     return ret;
 }
 
-ambit_log_entry_t *libambit_pmem20_log_read_entry(ambit_object_t *object)
+ambit_log_entry_t *libambit_pmem20_log_read_entry(libambit_pmem20_t *object)
 {
     // Note! We assume that the caller has called libambit_pmem20_log_next_header just before
     uint8_t *periodic_sample_spec;
     uint16_t tmp_len, sample_len;
-    size_t buffer_offset, sample_count = 0, i;
+    size_t buffer_offset, sample_count = 0;
     ambit_log_entry_t *log_entry;
-    ambit_log_sample_t *last_periodic = NULL, *utcsource = NULL, *altisource = NULL;
-    ambit_date_time_t utcbase;
-    uint32_t altisource_index = 0;
-    uint32_t last_base_lat = 0, last_base_long = 0;
-    uint32_t last_small_lat = 0, last_small_long = 0;
-    uint32_t last_ehpe = 0;
+    int32_t *time_compensators;
 
-    if (!object->pmem20.log.initialized) {
+    if (!object->log.initialized) {
         LOG_ERROR("Trying to get log entry without initialization");
         return NULL;
     }
 
     // Allocate log entry
     if ((log_entry = calloc(1, sizeof(ambit_log_entry_t))) == NULL) {
-        object->pmem20.log.initialized = false;
+        object->log.initialized = false;
         return NULL;
     }
+    log_entry->header.activity_name = NULL;
 
-    LOG_INFO("Reading log entry from address=%08x", object->pmem20.log.current.current);
+    LOG_INFO("Reading log entry from address=%08x", object->log.current.current);
 
-    buffer_offset = (object->pmem20.log.current.current - PMEM20_LOG_START);
+    buffer_offset = (object->log.current.current - object->log.mem_start);
     buffer_offset += 12;
     // Read samples content definition
-    tmp_len = read16inc(object->pmem20.log.buffer, &buffer_offset);
-    periodic_sample_spec = object->pmem20.log.buffer + buffer_offset;
+    tmp_len = read16inc(object->log.buffer, &buffer_offset);
+    periodic_sample_spec = object->log.buffer + buffer_offset;
     buffer_offset += tmp_len;
     // Parse header
-    tmp_len = read16inc(object->pmem20.log.buffer, &buffer_offset);
-    if (libambit_pmem20_log_parse_header(object->pmem20.log.buffer + buffer_offset, tmp_len, &log_entry->header) != 0) {
+    tmp_len = read16inc(object->log.buffer, &buffer_offset);
+    if (libambit_pmem20_log_parse_header(object->log.buffer + buffer_offset, tmp_len, &log_entry->header) != 0) {
         LOG_ERROR("Failed to parse log entry header correctly");
+        if (log_entry->header.activity_name) {
+            free(log_entry->header.activity_name);
+        }
         free(log_entry);
-        object->pmem20.log.initialized = false;
+        object->log.initialized = false;
         return NULL;
     }
     buffer_offset += tmp_len;
     // Now that we know number of samples, allocate space for them!
     if ((log_entry->samples = calloc(log_entry->header.samples_count, sizeof(ambit_log_sample_t))) == NULL) {
+        if (log_entry->header.activity_name) {
+            free(log_entry->header.activity_name);
+        }
         free(log_entry);
-        object->pmem20.log.initialized = false;
+        object->log.initialized = false;
         return NULL;
     }
     log_entry->samples_count = log_entry->header.samples_count;
+    if ((time_compensators = calloc(log_entry->header.samples_count, sizeof(int32_t))) == NULL) {
+        free(log_entry->samples);
+        if (log_entry->header.activity_name) {
+            free(log_entry->header.activity_name);
+        }
+        free(log_entry);
+        object->log.initialized = false;
+        return NULL;
+    }
 
     LOG_INFO("Log entry got %d samples, reading", log_entry->samples_count);
 
@@ -247,100 +265,141 @@
            to the end of the buffer. */
 
         // First check for log area wrap
-        if (buffer_offset >= PMEM20_LOG_SIZE - 1) {
-            read_upto(object, PMEM20_LOG_START + PMEM20_LOG_WRAP_START_OFFSET, 2);
-            sample_len = read16(object->pmem20.log.buffer, PMEM20_LOG_WRAP_START_OFFSET);
-        }
-        else if (buffer_offset == PMEM20_LOG_SIZE - 2) {
-            read_upto(object, PMEM20_LOG_START + PMEM20_LOG_WRAP_START_OFFSET, 1);
-            sample_len = object->pmem20.log.buffer[buffer_offset] | (object->pmem20.log.buffer[PMEM20_LOG_WRAP_START_OFFSET] << 8);
+        if (buffer_offset >= object->log.mem_size - 1) {
+            read_upto(object, object->log.mem_start + PMEM20_LOG_WRAP_START_OFFSET, 2);
+            sample_len = read16(object->log.buffer, PMEM20_LOG_WRAP_START_OFFSET);
+        }
+        else if (buffer_offset == object->log.mem_size - 2) {
+            read_upto(object, object->log.mem_start + PMEM20_LOG_WRAP_START_OFFSET, 1);
+            sample_len = object->log.buffer[buffer_offset] | (object->log.buffer[PMEM20_LOG_WRAP_START_OFFSET] << 8);
         }
         else {
-            read_upto(object, PMEM20_LOG_START + buffer_offset, 2);
-            sample_len = read16(object->pmem20.log.buffer, buffer_offset);
+            read_upto(object, object->log.mem_start + buffer_offset, 2);
+            sample_len = read16(object->log.buffer, buffer_offset);
         }
 
         // Read all data
-        if (buffer_offset + 2 < (PMEM20_LOG_SIZE-1)) {
-            read_upto(object, PMEM20_LOG_START + buffer_offset + 2, sample_len);
+        if (buffer_offset + 2 < (object->log.mem_size-1)) {
+            read_upto(object, object->log.mem_start + buffer_offset + 2, sample_len);
         }
-        if (buffer_offset + 2 + sample_len > PMEM20_LOG_SIZE) {
-            read_upto(object, PMEM20_LOG_START + PMEM20_LOG_WRAP_START_OFFSET, (buffer_offset + 2 + sample_len) - PMEM20_LOG_SIZE);
-            memcpy(object->pmem20.log.buffer + PMEM20_LOG_SIZE, object->pmem20.log.buffer + PMEM20_LOG_WRAP_START_OFFSET, (buffer_offset + 2 + sample_len) - PMEM20_LOG_SIZE);
+        if (buffer_offset + 2 + sample_len > object->log.mem_size) {
+            read_upto(object, object->log.mem_start + PMEM20_LOG_WRAP_START_OFFSET, (buffer_offset + 2 + sample_len) - object->log.mem_size);
+            memcpy(object->log.buffer + object->log.mem_size, object->log.buffer + PMEM20_LOG_WRAP_START_OFFSET, (buffer_offset + 2 + sample_len) - object->log.mem_size);
         }
 
-        if (parse_sample(object->pmem20.log.buffer, buffer_offset, &periodic_sample_spec, log_entry, &sample_count) == 1) {
-            // Calculate times
-            if (log_entry->samples[sample_count-1].type == ambit_log_sample_type_periodic) {
-                last_periodic = &log_entry->samples[sample_count-1];
-            }
-            else if (last_periodic != NULL) {
-                log_entry->samples[sample_count-1].time += last_periodic->time;
-            }
-            else {
-                log_entry->samples[sample_count-1].time = 0;
-            }
+        parse_sample(object->log.buffer, buffer_offset, &periodic_sample_spec, log_entry, &sample_count, time_compensators);
+        buffer_offset += 2 + sample_len;
+        // Wrap
+        if (buffer_offset >= object->log.mem_size) {
+            buffer_offset = PMEM20_LOG_WRAP_START_OFFSET + (buffer_offset - object->log.mem_size);
+        }
+    }
 
-            if (utcsource == NULL && log_entry->samples[sample_count-1].type == ambit_log_sample_type_gps_base) {
-                utcsource = &log_entry->samples[sample_count-1];
-                // Calculate UTC base time
-                add_time(&utcsource->u.gps_base.utc_base_time, 0-utcsource->time, &utcbase);
-            }
+    correct_samples(log_entry, time_compensators);
 
-            // Calculate positions
-            if (log_entry->samples[sample_count-1].type == ambit_log_sample_type_gps_base) {
-                last_base_lat = log_entry->samples[sample_count-1].u.gps_base.latitude;
-                last_base_long = log_entry->samples[sample_count-1].u.gps_base.longitude;
-                last_small_lat = log_entry->samples[sample_count-1].u.gps_base.latitude;
-                last_small_long = log_entry->samples[sample_count-1].u.gps_base.longitude;
-                last_ehpe = log_entry->samples[sample_count-1].u.gps_base.ehpe;
-            }
-            else if (log_entry->samples[sample_count-1].type == ambit_log_sample_type_gps_small) {
-                log_entry->samples[sample_count-1].u.gps_small.latitude = last_base_lat + log_entry->samples[sample_count-1].u.gps_small.latitude*10;
-                log_entry->samples[sample_count-1].u.gps_small.longitude = last_base_long + log_entry->samples[sample_count-1].u.gps_small.longitude*10;
-                last_small_lat = log_entry->samples[sample_count-1].u.gps_small.latitude;
-                last_small_long = log_entry->samples[sample_count-1].u.gps_small.longitude;
-                last_ehpe = log_entry->samples[sample_count-1].u.gps_small.ehpe;
-            }
-            else if (log_entry->samples[sample_count-1].type == ambit_log_sample_type_gps_tiny) {
-                log_entry->samples[sample_count-1].u.gps_tiny.latitude = last_small_lat + log_entry->samples[sample_count-1].u.gps_tiny.latitude*10;
-                log_entry->samples[sample_count-1].u.gps_tiny.longitude = last_small_long + log_entry->samples[sample_count-1].u.gps_tiny.longitude*10;
-                log_entry->samples[sample_count-1].u.gps_tiny.ehpe = (last_ehpe > 700 ? 700 : last_ehpe);
-                last_small_lat = log_entry->samples[sample_count-1].u.gps_tiny.latitude;
-                last_small_long = log_entry->samples[sample_count-1].u.gps_tiny.longitude;
-            }
+    free(time_compensators);
 
-            if (altisource == NULL && log_entry->samples[sample_count-1].type == ambit_log_sample_type_altitude_source) {
-                altisource = &log_entry->samples[sample_count-1];
-                altisource_index = sample_count-1;
-            }
+    return log_entry;
+}
+
+ambit_log_entry_t *libambit_pmem20_log_read_entry_address(libambit_pmem20_t *object, uint32_t address, uint32_t length)
+{
+    uint8_t *buffer;
+    uint8_t *periodic_sample_spec;
+    uint32_t next_address;
+    uint32_t buffer_read = 0, read_length;
+    uint16_t tmp_len, sample_len;
+    size_t buffer_offset, sample_count = 0;
+    ambit_log_entry_t *log_entry;
+    int32_t *time_compensators;
+
+    // Allocate log entry
+    if ((log_entry = calloc(1, sizeof(ambit_log_entry_t))) == NULL) {
+        object->log.initialized = false;
+        return NULL;
+    }
+
+    // Allocate temporary log buffer
+    if ((buffer = calloc(1, length)) == NULL) {
+        object->log.initialized = false;
+        free(log_entry);
+        return NULL;
+    }
+
+    LOG_INFO("Reading log entry from address=%08x", address);
+    log_entry->header.activity_name = NULL;
+
+    // Handle wrap in "the middle" of the log
+    next_address = address;
+    while (buffer_read < length) {
+        if (next_address >= object->log.mem_start + object->log.mem_size) {
+            next_address = object->log.mem_start + PMEM20_LOG_WRAP_START_OFFSET;
         }
-        buffer_offset += 2 + sample_len;
-        // Wrap
-        if (buffer_offset >= PMEM20_LOG_SIZE) {
-            buffer_offset = PMEM20_LOG_WRAP_START_OFFSET + (buffer_offset - PMEM20_LOG_SIZE);
+        if (length - buffer_read >= object->chunk_size) {
+            read_length = object->chunk_size;
         }
+        else {
+            read_length = length - buffer_read;
+        }
+        if (next_address + read_length > object->log.mem_start + object->log.mem_size) {
+            read_length = object->log.mem_start + object->log.mem_size - next_address;
+        }
+
+        read_log_chunk(object, next_address, read_length, buffer + buffer_read);
+
+        next_address += read_length;
+        buffer_read += read_length;
     }
 
-    // Loop through samples again and correct times etc
-    for (sample_count = 0; sample_count < log_entry->header.samples_count; sample_count++) {
-        // Set UTC times (if UTC source found)
-        if (utcsource != NULL) {
-            add_time(&utcbase, log_entry->samples[sample_count].time, &log_entry->samples[sample_count].utc_time);
+    buffer_offset = 12;
+    // Read samples content definition
+    tmp_len = read16inc(buffer, &buffer_offset);
+    periodic_sample_spec = buffer + buffer_offset;
+    buffer_offset += tmp_len;
+    // Parse header
+    tmp_len = read16inc(buffer, &buffer_offset);
+    if (libambit_pmem20_log_parse_header(buffer + buffer_offset, tmp_len, &log_entry->header) != 0) {
+        LOG_ERROR("Failed to parse log entry header correctly");
+        if (log_entry->header.activity_name) {
+            free(log_entry->header.activity_name);
         }
-        // Correct altitude based on altitude offset in altitude source
-        if (altisource != NULL && log_entry->samples[sample_count].type == ambit_log_sample_type_periodic && sample_count < altisource_index) {
-            for (i=0; i<log_entry->samples[sample_count].u.periodic.value_count; i++) {
-                if (log_entry->samples[sample_count].u.periodic.values[i].type == ambit_log_sample_periodic_type_sealevelpressure) {
-                    log_entry->samples[sample_count].u.periodic.values[i].u.sealevelpressure += altisource->u.altitude_source.pressure_offset;
-                }
-                if (log_entry->samples[sample_count].u.periodic.values[i].type == ambit_log_sample_periodic_type_altitude) {
-                    log_entry->samples[sample_count].u.periodic.values[i].u.altitude += altisource->u.altitude_source.altitude_offset;
-                }
-            }
+        free(log_entry);
+        object->log.initialized = false;
+        return NULL;
+    }
+    buffer_offset += tmp_len;
+    // Now that we know number of samples, allocate space for them!
+    if ((log_entry->samples = calloc(log_entry->header.samples_count, sizeof(ambit_log_sample_t))) == NULL) {
+        if (log_entry->header.activity_name) {
+            free(log_entry->header.activity_name);
+        }
+        free(log_entry);
+        object->log.initialized = false;
+        return NULL;
+    }
+    log_entry->samples_count = log_entry->header.samples_count;
+    if ((time_compensators = calloc(log_entry->header.samples_count, sizeof(int32_t))) == NULL) {
+        free(log_entry->samples);
+        if (log_entry->header.activity_name) {
+            free(log_entry->header.activity_name);
         }
+        free(log_entry);
+        object->log.initialized = false;
+        return NULL;
     }
 
+    LOG_INFO("Log entry got %d samples, reading", log_entry->samples_count);
+
+    // OK, so we are at start of samples, get them all!
+    while (sample_count < log_entry->samples_count) {
+        sample_len = read16(buffer, buffer_offset);
+
+        parse_sample(buffer, buffer_offset, &periodic_sample_spec, log_entry, &sample_count, time_compensators);
+        buffer_offset += 2 + sample_len;
+    }
+
+    correct_samples(log_entry, time_compensators);
+
     return log_entry;
 }
 
@@ -378,8 +437,11 @@
     log_header->heartrate_max = read8inc(data, &offset);
     log_header->peak_training_effect = read8inc(data, &offset);
     log_header->activity_type = read8inc(data, &offset);
-    memcpy(log_header->activity_name, data + offset, 16);
-    log_header->activity_name[16] = 0;
+    if (log_header->activity_name) {
+        free(log_header->activity_name);
+    }
+    log_header->activity_name = utf8memconv((char *)data + offset, 16,
+                                            "ISO-8859-15");
     offset += 16;
     log_header->heartrate_min = read8inc(data, &offset);
 
@@ -394,9 +456,10 @@
     log_header->cadence_max = read8inc(data, &offset);
     log_header->cadence_avg = read8inc(data, &offset);
 
-    memcpy(log_header->unknown3, data+offset, 4);
-    offset += 4;
+    memcpy(log_header->unknown3, data+offset, 2);
+    offset += 2;
 
+    log_header->swimming_pool_lengths = read16inc(data, &offset);
     log_header->speed_max_time = read32inc(data, &offset);
     log_header->altitude_max_time = read32inc(data, &offset);
     log_header->altitude_min_time = read32inc(data, &offset);
@@ -405,10 +468,7 @@
     log_header->temperature_max_time = read32inc(data, &offset);
     log_header->temperature_min_time = read32inc(data, &offset);
     log_header->cadence_max_time = read32inc(data, &offset);
-
-    memcpy(log_header->unknown4, data+offset, 4);
-    offset += 4;
-
+    log_header->swimming_pool_length = read32inc(data, &offset);
     log_header->first_fix_time = read16inc(data, &offset)*1000;
     log_header->battery_start = read8inc(data, &offset);
     log_header->battery_end = read8inc(data, &offset);
@@ -426,13 +486,16 @@
     return 0;
 }
 
-int libambit_pmem20_gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen)
+int libambit_pmem20_gps_orbit_write(libambit_pmem20_t *object, const uint8_t *data, size_t datalen, bool include_sha256_hash)
 {
-    int ret = -1;
-    uint8_t *bufptrs[2];
+    int i, ret = -1;
+    const uint8_t *bufptrs[2];
     size_t bufsizes[2];
+    uint8_t *tailbuf;
+    size_t tail_datalen = 8;
     uint8_t startheader[4];
-    uint8_t tailbuf[8];
+    sha256_ctx ctx;
+    uint8_t hash[32];
     uint32_t *_sizeptr = (uint32_t*)&startheader[0];
     uint32_t address = PMEM20_GPS_ORBIT_START;
     size_t offset = 0;
@@ -441,29 +504,45 @@
     bufptrs[0] = startheader;
     bufsizes[0] = 4;
     bufptrs[1] = data;
-    bufsizes[1] = object->pmem20.chunk_size - 4; // We assume that data is
-                                                 // always > chunk_size
+    bufsizes[1] = object->chunk_size - 4; // We assume that data is
+                                          // always > chunk_size
 
     // Write first chunk (including length)
-    ret = write_data_chunk(object, address, 2, bufptrs, bufsizes);
+    ret = write_data_chunk(object->ambit_object, address, 2, bufptrs, bufsizes);
     offset += bufsizes[1];
-    address += object->pmem20.chunk_size;
+    address += object->chunk_size;
 
     // Write rest of the chunks
     while (ret == 0 && offset < datalen) {
         bufptrs[0] = data + offset;
-        bufsizes[0] = (datalen - offset > object->pmem20.chunk_size ? object->pmem20.chunk_size : datalen - offset);
+        bufsizes[0] = (datalen - offset > object->chunk_size ? object->chunk_size : datalen - offset);
 
-        ret = write_data_chunk(object, address, 1, bufptrs, bufsizes);
+        ret = write_data_chunk(object->ambit_object, address, 1, bufptrs, bufsizes);
         offset += bufsizes[0];
         address += bufsizes[0];
     }
 
     // Write tail length (or what is really!?)
     if (ret == 0) {
-        *((uint32_t*)(&tailbuf[0])) = htole32(PMEM20_GPS_ORBIT_START);
-        *((uint32_t*)(&tailbuf[4])) = htole32(bufsizes[0]);
-        ret = libambit_protocol_command(object, ambit_command_data_tail_len, tailbuf, sizeof(tailbuf), NULL, NULL, 0);
+        // Handle hash (if wanted)
+        if (include_sha256_hash) {
+            sha256_init(&ctx);
+            sha256_update(&ctx, startheader, sizeof(startheader));
+            sha256_update(&ctx, data, datalen);
+            sha256_final(&ctx, hash);
+            tail_datalen += 64;
+        }
+        if ((tailbuf = malloc(tail_datalen + 1)) != NULL) {
+            *((uint32_t*)(&tailbuf[0])) = htole32(PMEM20_GPS_ORBIT_START);
+            *((uint32_t*)(&tailbuf[4])) = htole32(bufsizes[0]);
+            if (include_sha256_hash) {
+                for (i=0; i<32; i++) {
+                    sprintf((char*)tailbuf+8+i*2, "%02X", hash[i]);
+                }
+            }
+            ret = libambit_protocol_command(object->ambit_object, ambit_command_data_tail_len, tailbuf, tail_datalen, NULL, NULL, 0);
+            free(tailbuf);
+        }
     }
 
     return ret;
@@ -473,7 +552,7 @@
  * Parse the given sample
  * \return number of samples added (1 or 0)
  */
-static int parse_sample(uint8_t *buf, size_t offset, uint8_t **spec, ambit_log_entry_t *log_entry, size_t *sample_count)
+static int parse_sample(uint8_t *buf, size_t offset, uint8_t **spec, ambit_log_entry_t *log_entry, size_t *sample_count, int32_t *time_compensators)
 {
     int ret = 0;
     size_t int_offset = offset;
@@ -728,16 +807,51 @@
             log_entry->samples[*sample_count].u.time.minute = read8inc(buf, &int_offset);
             log_entry->samples[*sample_count].u.time.second = read8inc(buf, &int_offset);
             break;
+          case 0x14:
+            log_entry->samples[*sample_count].type = ambit_log_sample_type_swimming_turn;
+            int_offset += 1;
+            // Time compensation offset in 0.1 second format, convert to ms
+            time_compensators[*sample_count] = 0 - read16inc(buf, &int_offset) * 100;
+            int_offset += 1;
+            log_entry->samples[*sample_count].u.swimming_turn.distance = read32inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.swimming_turn.lengths = read16inc(buf, &int_offset);
+            int_offset += 18;
+            log_entry->samples[*sample_count].u.swimming_turn.classification[0] = read16inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.swimming_turn.classification[1] = read16inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.swimming_turn.classification[2] = read16inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.swimming_turn.classification[3] = read16inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.swimming_turn.style = read8inc(buf, &int_offset);
+            break;
+          case 0x15:
+            log_entry->samples[*sample_count].type = ambit_log_sample_type_swimming_stroke;
+            // Time compensation offset in 0.1 second format, convert to ms
+            time_compensators[*sample_count] = 0 - read16inc(buf, &int_offset) * 100;
+            break;
           case 0x18:
             log_entry->samples[*sample_count].type = ambit_log_sample_type_activity;
             log_entry->samples[*sample_count].u.activity.activitytype = read16inc(buf, &int_offset);
             log_entry->samples[*sample_count].u.activity.custommode = read32inc(buf, &int_offset);
             break;
+          case 0x1a:
+            log_entry->samples[*sample_count].type = ambit_log_sample_type_cadence_source;
+            log_entry->samples[*sample_count].u.cadence_source = read8inc(buf, &int_offset);
+            break;
           case 0x1b:
             log_entry->samples[*sample_count].type = ambit_log_sample_type_position;
             log_entry->samples[*sample_count].u.position.latitude = read32inc(buf, &int_offset);
             log_entry->samples[*sample_count].u.position.longitude = read32inc(buf, &int_offset);
             break;
+          case 0x1c:
+            log_entry->samples[*sample_count].type = ambit_log_sample_type_fwinfo;
+            memcpy(log_entry->samples[*sample_count].u.fwinfo.version, buf + int_offset, 4);
+            int_offset += 4;
+            log_entry->samples[*sample_count].u.fwinfo.build_date.year = read16inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.fwinfo.build_date.month = read8inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.fwinfo.build_date.day = read8inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.fwinfo.build_date.hour = read8inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.fwinfo.build_date.minute = read8inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.fwinfo.build_date.msec = read16inc(buf, &int_offset);
+            break;
           default:
             LOG_WARNING("Found unknown episodic sample type (0x%02x)", episodic_type);
             log_entry->samples[*sample_count].type = ambit_log_sample_type_unknown;
@@ -763,30 +877,129 @@
     return ret;
 }
 
-static int read_upto(ambit_object_t *object, uint32_t address, uint32_t length)
+static void correct_samples(ambit_log_entry_t *log_entry, int32_t *time_compensators)
+{
+    size_t sample_count, i;
+    ambit_log_sample_t *last_periodic = NULL, *utcsource = NULL, *altisource = NULL;
+    ambit_date_time_t utcbase;
+    uint32_t altisource_index = 0;
+    uint32_t last_base_lat = 0, last_base_long = 0;
+    uint32_t last_small_lat = 0, last_small_long = 0;
+    uint32_t last_ehpe = 0;
+    ambit_log_sample_t tmpsample;
+
+    for (sample_count = 0; sample_count < log_entry->header.samples_count; sample_count++) {
+        // Calculate times
+        if (log_entry->samples[sample_count].type == ambit_log_sample_type_periodic) {
+            last_periodic = &log_entry->samples[sample_count];
+        }
+        else if (last_periodic != NULL) {
+            log_entry->samples[sample_count].time += last_periodic->time;
+        }
+        else {
+            log_entry->samples[sample_count].time = 0;
+        }
+        // Correct with time_compensators
+        if (time_compensators[sample_count] < 0 && log_entry->samples[sample_count].time < (0 - time_compensators[sample_count])) {
+            // Avoid negative times, never set to less than 0
+            log_entry->samples[sample_count].time = 0;
+        }
+        else {
+            log_entry->samples[sample_count].time += time_compensators[sample_count];
+        }
+
+        if (utcsource == NULL && log_entry->samples[sample_count].type == ambit_log_sample_type_gps_base) {
+            utcsource = &log_entry->samples[sample_count];
+            // Calculate UTC base time
+            add_time(&utcsource->u.gps_base.utc_base_time, 0-utcsource->time, &utcbase);
+        }
+
+        // Calculate positions
+        if (log_entry->samples[sample_count].type == ambit_log_sample_type_gps_base) {
+            last_base_lat = log_entry->samples[sample_count].u.gps_base.latitude;
+            last_base_long = log_entry->samples[sample_count].u.gps_base.longitude;
+            last_small_lat = log_entry->samples[sample_count].u.gps_base.latitude;
+            last_small_long = log_entry->samples[sample_count].u.gps_base.longitude;
+            last_ehpe = log_entry->samples[sample_count].u.gps_base.ehpe;
+        }
+        else if (log_entry->samples[sample_count].type == ambit_log_sample_type_gps_small) {
+            log_entry->samples[sample_count].u.gps_small.latitude = last_base_lat + log_entry->samples[sample_count].u.gps_small.latitude*10;
+            log_entry->samples[sample_count].u.gps_small.longitude = last_base_long + log_entry->samples[sample_count].u.gps_small.longitude*10;
+            last_small_lat = log_entry->samples[sample_count].u.gps_small.latitude;
+            last_small_long = log_entry->samples[sample_count].u.gps_small.longitude;
+            last_ehpe = log_entry->samples[sample_count].u.gps_small.ehpe;
+        }
+        else if (log_entry->samples[sample_count].type == ambit_log_sample_type_gps_tiny) {
+            log_entry->samples[sample_count].u.gps_tiny.latitude = last_small_lat + log_entry->samples[sample_count].u.gps_tiny.latitude*10;
+            log_entry->samples[sample_count].u.gps_tiny.longitude = last_small_long + log_entry->samples[sample_count].u.gps_tiny.longitude*10;
+            log_entry->samples[sample_count].u.gps_tiny.ehpe = (last_ehpe > 700 ? 700 : last_ehpe);
+            last_small_lat = log_entry->samples[sample_count].u.gps_tiny.latitude;
+            last_small_long = log_entry->samples[sample_count].u.gps_tiny.longitude;
+        }
+
+        if (altisource == NULL && log_entry->samples[sample_count].type == ambit_log_sample_type_altitude_source) {
+            altisource = &log_entry->samples[sample_count];
+            altisource_index = sample_count;
+        }
+    }
+
+    // Loop through samples again and correct times etc
+    for (sample_count = 0; sample_count < log_entry->header.samples_count; sample_count++) {
+        // Set UTC times (if UTC source found)
+        if (utcsource != NULL) {
+            add_time(&utcbase, log_entry->samples[sample_count].time, &log_entry->samples[sample_count].utc_time);
+        }
+        // Correct altitude based on altitude offset in altitude source
+        if (altisource != NULL && log_entry->samples[sample_count].type == ambit_log_sample_type_periodic && sample_count < altisource_index) {
+            for (i=0; i<log_entry->samples[sample_count].u.periodic.value_count; i++) {
+                if (log_entry->samples[sample_count].u.periodic.values[i].type == ambit_log_sample_periodic_type_sealevelpressure) {
+                    log_entry->samples[sample_count].u.periodic.values[i].u.sealevelpressure += altisource->u.altitude_source.pressure_offset;
+                }
+                if (log_entry->samples[sample_count].u.periodic.values[i].type == ambit_log_sample_periodic_type_altitude) {
+                    log_entry->samples[sample_count].u.periodic.values[i].u.altitude += altisource->u.altitude_source.altitude_offset;
+                }
+            }
+        }
+    }
+
+    // Rearrange samples in respect to time values
+    for (sample_count = 1; sample_count < log_entry->header.samples_count; sample_count++) {
+        // Look for bad sorted samples
+        if (log_entry->samples[sample_count].time < log_entry->samples[sample_count-1].time) {
+            // Find out new position of sample
+            for (i = sample_count - 1; i > 0; i--) {
+                if (log_entry->samples[sample_count].time >= log_entry->samples[i-1].time) {
+                    break;
+                }
+            }
+            memcpy(&tmpsample, &log_entry->samples[sample_count], sizeof(ambit_log_sample_t));
+            memmove(&log_entry->samples[i+1], &log_entry->samples[i], sizeof(ambit_log_sample_t)*(sample_count-i));
+            memcpy(&log_entry->samples[i], &tmpsample, sizeof(ambit_log_sample_t));
+        }
+    }
+}
+
+static int read_upto(libambit_pmem20_t *object, uint32_t address, uint32_t length)
 {
-    uint32_t start_address = address - ((address - PMEM20_LOG_START) % object->pmem20.chunk_size);
+    uint32_t start_address = address - ((address - object->log.mem_start) % object->chunk_size);
 
     while (start_address < address + length) {
-        if (object->pmem20.log.chunks_read[(start_address - PMEM20_LOG_START)/object->pmem20.chunk_size] == 0) {
-            if (read_log_chunk(object, start_address) != 0) {
+        if (object->log.chunks_read[(start_address - object->log.mem_start)/object->chunk_size] == 0) {
+            if (read_log_chunk(object, start_address, object->chunk_size, object->log.buffer + (start_address - object->log.mem_start)) != 0) {
                 return -1;
             }
-            object->pmem20.log.chunks_read[(start_address - PMEM20_LOG_START)/object->pmem20.chunk_size] = 1;
+            object->log.chunks_read[(start_address - object->log.mem_start)/object->chunk_size] = 1;
         }
-        start_address += object->pmem20.chunk_size;
+        start_address += object->chunk_size;
     }
 
     return 0;
 }
 
-static int read_log_chunk(ambit_object_t *object, uint32_t address)
+static int read_log_chunk(libambit_pmem20_t *object, uint32_t address, uint32_t length, uint8_t *buffer)
 {
     int ret = -1;
 
-    uint8_t *buffer = object->pmem20.log.buffer + (address - PMEM20_LOG_START);
-    uint32_t length = object->pmem20.chunk_size;
-
     uint8_t *reply = NULL;
     size_t replylen = 0;
 
@@ -794,14 +1007,14 @@
     uint32_t *_address = (uint32_t*)&send_data[0];
     uint32_t *_length = (uint32_t*)&send_data[4];
 
-    if ((address + object->pmem20.chunk_size) > (PMEM20_LOG_START + PMEM20_LOG_SIZE)) {
-        length = PMEM20_LOG_START + PMEM20_LOG_SIZE - address;
+    if ((address + object->chunk_size) > (object->log.mem_start + object->log.mem_size)) {
+        length = object->log.mem_start + object->log.mem_size - address;
     }
 
     *_address = htole32(address);
     *_length = htole32(length);
 
-    if (libambit_protocol_command(object, ambit_command_log_read, send_data, sizeof(send_data), &reply, &replylen, 0) == 0 &&
+    if (libambit_protocol_command(object->ambit_object, ambit_command_log_read, send_data, sizeof(send_data), &reply, &replylen, 0) == 0 &&
         replylen == length + 8) {
         memcpy(buffer, reply + 8, length);
         ret = 0;
@@ -812,7 +1025,7 @@
     return ret;
 }
 
-static int write_data_chunk(ambit_object_t *object, uint32_t address, size_t buffer_count, uint8_t **buffers, size_t *buffer_sizes)
+static int write_data_chunk(ambit_object_t *object, uint32_t address, size_t buffer_count, const uint8_t **buffers, const size_t *buffer_sizes)
 {
     int ret = -1;
 
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/pmem20.h ../openambit.git/src/libambit/pmem20.h
--- ./src/libambit/pmem20.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/pmem20.h	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,60 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __PMEM20_H__
+#define __PMEM20_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include "libambit.h"
+
+typedef struct libambit_pmem20_s {
+    uint16_t chunk_size;
+    struct {
+        bool initialized;
+        uint32_t mem_start;
+        uint32_t mem_size;
+        uint32_t first_entry;
+        uint32_t last_entry;
+        uint32_t entries;
+        uint32_t next_free_address;
+        struct {
+            uint32_t current;
+            uint32_t next;
+            uint32_t prev;
+        } current;
+        uint8_t *buffer;
+        uint8_t *chunks_read;
+    } log;
+    ambit_object_t *ambit_object;
+} libambit_pmem20_t;
+
+int libambit_pmem20_init(libambit_pmem20_t *object, ambit_object_t *ambit_object, uint16_t chunk_size);
+int libambit_pmem20_deinit(libambit_pmem20_t *object);
+int libambit_pmem20_log_init(libambit_pmem20_t *object, uint32_t mem_start, uint32_t mem_size);
+int libambit_pmem20_log_deinit(libambit_pmem20_t *object);
+int libambit_pmem20_log_next_header(libambit_pmem20_t *object, ambit_log_header_t *log_header);
+ambit_log_entry_t *libambit_pmem20_log_read_entry(libambit_pmem20_t *object);
+ambit_log_entry_t *libambit_pmem20_log_read_entry_address(libambit_pmem20_t *object, uint32_t address, uint32_t length);
+int libambit_pmem20_log_parse_header(uint8_t *data, size_t datalen, ambit_log_header_t *log_header);
+int libambit_pmem20_gps_orbit_write(libambit_pmem20_t *object, const uint8_t *data, size_t datalen, bool include_sha256_hash);
+
+#endif /* __PMEM20_H__ */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/protocol.c ../openambit.git/src/libambit/protocol.c
--- ./src/libambit/protocol.c	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/libambit/protocol.c	2014-11-05 21:53:14.000000000 +0100
@@ -19,8 +19,10 @@
  * Contributors:
  *
  */
-#include "libambit.h"
+#include "protocol.h"
 #include "libambit_int.h"
+#include "crc16.h"
+
 #include "hidapi/hidapi.h"
 
 #include <stdlib.h>
@@ -104,8 +106,8 @@
     msg->MP = 0x5d;
     msg->parts_seq = htole16(packet_count);
     msg->command = htobe16(command);
-    msg->send_recv = htole16(legacy_format ? 1 : 5);
-    msg->format = htole16(legacy_format ? 0 : 9); // TODO!!!
+    msg->send_recv = htole16(legacy_format == 1 ? 1 : legacy_format == 2 ? 0x15 : 5);
+    msg->format = htole16(legacy_format == 1 ? 0 : 9);
     msg->sequence = htole16(object->sequence_no);
     msg->payload_len = htole32(datalen);
     packet_payload_len = fmin(42, datalen);
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/protocol.h ../openambit.git/src/libambit/protocol.h
--- ./src/libambit/protocol.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/protocol.h	2015-03-20 20:47:45.908512152 +0100
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __PROTOCOL_H__
+#define __PROTOCOL_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include "libambit.h"
+
+enum ambit_commands_e {
+    ambit_command_device_info           = 0x0000,
+    ambit_command_time                  = 0x0300,
+    ambit_command_date                  = 0x0302,
+    ambit_command_status                = 0x0306,
+    ambit_command_personal_settings     = 0x0b00,
+    ambit_command_unknown2              = 0x0b02,
+    ambit_command_unknown1              = 0x0b04,
+    ambit_command_log_count             = 0x0b06,
+    ambit_command_log_head_first        = 0x0b07,
+    ambit_command_log_head_peek         = 0x0b08,
+    ambit_command_log_head_step         = 0x0b0a,
+    ambit_command_log_head              = 0x0b0b,
+    ambit_command_gps_orbit_head        = 0x0b15,
+    ambit_command_data_write            = 0x0b16,
+    ambit_command_log_read              = 0x0b17,
+    ambit_command_data_tail_len         = 0x0b18,
+    ambit_command_lock_check            = 0x0b19,
+    ambit_command_lock_set              = 0x0b1a,
+    ambit_command_write_start           = 0x0b1b, // Really!? Just a guess...
+    ambit_command_ambit3_memory_map     = 0x0b21,
+    ambit_command_ambit3_settings       = 0x1100,
+    ambit_command_ambit3_settings_write = 0x1101,
+    ambit_command_ambit3_log_headers    = 0x1200,
+    ambit_command_ambit3_log_synced     = 0x1201
+};
+
+/**
+ * Write command to device
+ * \param legacy_format 0=normal, 1=legacy, 2=version 2
+ */
+int libambit_protocol_command(ambit_object_t *object, uint16_t command, uint8_t *data, size_t datalen, uint8_t **reply_data, size_t *replylen, uint8_t legacy_format);
+void libambit_protocol_free(uint8_t *data);
+
+#endif /* __PROTOCOL_H__ */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/sbem0102.c ../openambit.git/src/libambit/sbem0102.c
--- ./src/libambit/sbem0102.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/sbem0102.c	2015-05-03 10:54:35.522551177 +0200
@@ -0,0 +1,249 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include "sbem0102.h"
+#include "protocol.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Local definitions
+ */
+
+
+/*
+ * Static functions
+ */
+
+
+/*
+ * Static data
+ */
+
+
+/*
+ * Public functions
+ */
+int libambit_sbem0102_init(libambit_sbem0102_t *object, ambit_object_t *ambit_object, uint16_t chunk_size)
+{
+    object->ambit_object = ambit_object;
+    object->chunk_size = chunk_size;
+
+    return 0;
+}
+
+int libambit_sbem0102_deinit(libambit_sbem0102_t *object)
+{
+    return 0;
+}
+
+int libambit_sbem0102_write(libambit_sbem0102_t *object, uint16_t command, libambit_sbem0102_data_t *data)
+{
+    int ret = -1;
+    uint8_t *send_data;
+    size_t offset = 0;
+    uint8_t *reply = NULL;
+    size_t replylen = 0;
+    static uint8_t header[] = { 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 'S', 'B', 'E', 'M', '0', '1', '0', '2' };
+
+    // TODO: We have no idea how to deal with multiple packets at the moment,
+    // just fail for now
+    if (data != NULL && data->size > object->chunk_size) {
+        return -1;
+    }
+
+    // Calculate size of buffer, and allocate it
+    send_data = malloc(sizeof(header) + (data != NULL ? data->size : 0));
+    if (send_data == NULL) {
+        return -1;
+    }
+
+    // Prepare initial header
+    memcpy(send_data, header, sizeof(header));
+    offset += sizeof(header);
+
+    if (data != NULL && data->data != NULL && data->size > 0) {
+        memcpy(send_data+offset, data->data, data->size);
+        offset += data->size;
+    }
+
+    ret = libambit_protocol_command(object->ambit_object, command, send_data, offset, &reply, &replylen, 0);
+
+    free(send_data);
+    libambit_protocol_free(reply);
+
+    return ret;
+}
+
+int libambit_sbem0102_command_request(libambit_sbem0102_t *object, uint16_t command, libambit_sbem0102_data_t *data_objects, libambit_sbem0102_data_t *reply_data)
+{
+    int ret = -1;
+    uint8_t *send_data = NULL;
+    size_t offset = 0;
+    uint8_t *reply = NULL;
+    size_t replylen = 0;
+
+    static uint8_t header[] = { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 'S', 'B', 'E', 'M', '0', '1', '0', '2' };
+    static uint8_t special_header[] = { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0a, 0x00, 'S', 'B', 'E', 'M', '0', '1', '0', '2' };
+
+    // TODO: We have no idea how to deal with multiple packets at the moment,
+    // just fail for now
+    if (data_objects != NULL && data_objects->size > object->chunk_size) {
+        return -1;
+    }
+
+    // Calculate size of buffer, and allocate it
+    // TODO: log headers seems to have a different format than the rest, treat
+    // it here until the mystery of the 2 extra bytes is really solved
+    if (command == ambit_command_ambit3_log_headers) {
+        send_data = malloc(sizeof(special_header) + (data_objects != NULL ? data_objects->size : 0));
+        if (send_data == NULL) {
+            return -1;
+        }
+        memcpy(send_data, special_header, sizeof(special_header));
+        offset += sizeof(special_header);
+    }
+    else {
+        send_data = malloc(sizeof(header) + (data_objects != NULL ? data_objects->size : 0));
+        if (send_data == NULL) {
+            return -1;
+        }
+        memcpy(send_data, header, sizeof(header));
+        offset += sizeof(header);
+    }
+
+    // Add data objects
+    if (data_objects != NULL && data_objects->data != NULL && data_objects->size > 0) {
+        memcpy(send_data+offset, data_objects->data, data_objects->size);
+        offset += data_objects->size;
+    }
+
+    // Reset reply data before starting to fill it
+    libambit_sbem0102_data_free(reply_data);
+
+    if (libambit_protocol_command(object->ambit_object, command, send_data, offset, &reply, &replylen, 0) == 0) {
+        // Check that the reply contains an SBEM0102 header
+        if (replylen >= sizeof(header) && memcmp(reply + 6, header + 6, 8) == 0) {
+            if (replylen > sizeof(header)) {
+                // Copy message to reply_data object
+                reply_data->data = malloc(replylen - sizeof(header));
+                memcpy(reply_data->data, reply + sizeof(header), replylen - sizeof(header));
+                reply_data->size = replylen - sizeof(header);
+
+                // Check if this reply was just a part (5th byte is the current
+                // guess on how to determine)
+                while (reply[4] != 0x01) {
+                    // Guess number 2: first 4 bytes seems to be copied from
+                    // the reply when asking for more data, what the f*ck does
+                    // they represent!?
+                    memcpy(send_data, reply, 4);
+
+                    // Free old reply before calling again
+                    libambit_protocol_free(reply);
+
+                    if (libambit_protocol_command(object->ambit_object, command, send_data, offset, &reply, &replylen, 0) != 0 ||
+                        replylen < 6) {
+                        libambit_sbem0102_data_free(reply_data);
+                        break;
+                    }
+
+                    if (replylen > 6) {
+                        reply_data->data = realloc(reply_data->data, reply_data->size + replylen - 6);
+                        memcpy(reply_data->data + reply_data->size, reply + 6, replylen - 6);
+                        reply_data->size += replylen - 6;
+                    }
+                }
+            }
+
+            ret = 0;
+        }
+
+        libambit_protocol_free(reply);
+    }
+
+    free(send_data);
+
+    return ret;
+}
+
+int libambit_sbem0102_command_request_raw(libambit_sbem0102_t *object, uint16_t command, uint8_t *data, size_t datalen, libambit_sbem0102_data_t *reply_data)
+{
+    int ret = -1;
+    uint8_t *reply = NULL;
+    size_t replylen = 0;
+
+    static uint8_t header[] = { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 'S', 'B', 'E', 'M', '0', '1', '0', '2' };
+
+    // Reset reply data before starting to fill it
+    libambit_sbem0102_data_free(reply_data);
+
+    if (libambit_protocol_command(object->ambit_object, command, data, datalen, &reply, &replylen, 0) == 0) {
+        // Check that the reply contains an SBEM0102 header
+        if (replylen >= sizeof(header) && memcmp(reply + 6, header + 6, 8) == 0) {
+            if (replylen > sizeof(header)) {
+                // Copy message to reply_data object
+                reply_data->data = malloc(replylen - sizeof(header));
+                memcpy(reply_data->data, reply + sizeof(header), replylen - sizeof(header));
+                reply_data->size = replylen - sizeof(header);
+            }
+
+            ret = 0;
+        }
+
+        libambit_protocol_free(reply);
+    }
+
+    return ret;
+}
+
+void libambit_sbem0102_data_init(libambit_sbem0102_data_t *data)
+{
+    if (data != NULL) {
+        memset(data, 0, sizeof(libambit_sbem0102_data_t));
+    }
+}
+
+void libambit_sbem0102_data_free(libambit_sbem0102_data_t *data)
+{
+    if (data != NULL) {
+        if (data->data != NULL) {
+            free(data->data);
+        }
+        memset(data, 0, sizeof(libambit_sbem0102_data_t));
+    }
+}
+
+void libambit_sbem0102_data_add(libambit_sbem0102_data_t *object, uint8_t id, uint8_t *data, uint8_t datalen)
+{
+    if (object != NULL) {
+        object->data = realloc(object->data, object->size + 2 + datalen);
+        if (object->data != NULL) {
+            object->data[object->size] = id;
+            object->data[object->size+1] = datalen;
+            if (datalen > 0 && data != NULL) {
+                memcpy(object->data+2+object->size, data, datalen);
+            }
+            object->size += 2 + datalen;
+        }
+    }
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/sbem0102.h ../openambit.git/src/libambit/sbem0102.h
--- ./src/libambit/sbem0102.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/sbem0102.h	2015-03-20 20:47:45.908512152 +0100
@@ -0,0 +1,173 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __SBEM0102_H__
+#define __SBEM0102_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include "libambit.h"
+
+typedef struct libambit_sbem0102_s {
+    uint16_t chunk_size;
+    ambit_object_t *ambit_object;
+} libambit_sbem0102_t;
+
+typedef struct libambit_sbem0102_data_s {
+    uint8_t *data;
+    size_t size;
+    uint8_t *read_ptr;
+} libambit_sbem0102_data_t;
+
+
+/**
+ * Initialize SBEM0102 object
+ * \param object Object to intialize
+ * \param ambit_object Corresponding ambit_object
+ * \param chunk_size Maximum chunk size of messages
+ * \return 0 on success, else -1
+ */
+int libambit_sbem0102_init(libambit_sbem0102_t *object, ambit_object_t *ambit_object, uint16_t chunk_size);
+
+/**
+ * Deinitialize SBEM0102 object
+ * \object Object to deintialize
+ * \return 0 on success, else -1
+ */
+int libambit_sbem0102_deinit(libambit_sbem0102_t *object);
+
+/**
+ * Write data to device in SBEM0102 format
+ * \param object libambit object
+ * \param command Command to send
+ * \param data data objects to append to request
+ * \return 0 on success, else -1
+ */
+int libambit_sbem0102_write(libambit_sbem0102_t *object, uint16_t command, libambit_sbem0102_data_t *data);
+
+/**
+ * Request read of complete SBEM0102 message from device
+ * \param object libambit object
+ * \param command Command to send
+ * \param data_objects objects to append to request
+ * \param reply_data Data in reply. After data in object has been used, user
+ * should call libambit_sbem0102_data_free()
+ * \return 0 on success, else -1
+ */
+int libambit_sbem0102_command_request(libambit_sbem0102_t *object, uint16_t command, libambit_sbem0102_data_t *data_objects, libambit_sbem0102_data_t *reply_data);
+
+/**
+ * Request read of complete SBEM0102 message from device, but without SBEM data
+ * in request
+ * \param object libambit object
+ * \param command Command to send
+ * \param data raw data to append to request
+ * \param reply_data Data in reply. After data in object has been used, user
+ * should call libambit_sbem0102_data_free()
+ * \return 0 on success, else -1
+ */
+int libambit_sbem0102_command_request_raw(libambit_sbem0102_t *object, uint16_t command, uint8_t *data, size_t datalen, libambit_sbem0102_data_t *reply_data);
+
+/**
+ * Free content of data objects
+ * NOTE! The object itself is not freed
+ * \param data Data object of which to free data in
+ */
+void libambit_sbem0102_data_init(libambit_sbem0102_data_t *data);
+
+/**
+ * Free content of data objects
+ * NOTE! The object itself is not freed
+ * \param data Data object of which to free data in
+ */
+void libambit_sbem0102_data_free(libambit_sbem0102_data_t *data);
+
+/**
+ * Append id:data pair to data object
+ * \param object Data object to append value to
+ * \param id data id to add
+ * \param data data buffer to add
+ * \param datalen length of databuffer
+ */
+void libambit_sbem0102_data_add(libambit_sbem0102_data_t *object, uint8_t id, uint8_t *data, uint8_t datalen);
+
+/**
+ * Reset internal read iterator
+ * \param object Object to iterate over
+ */
+static inline void libambit_sbem0102_data_reset(libambit_sbem0102_data_t *object)
+{
+    object->read_ptr = NULL;
+}
+
+/**
+ * Get data id of current element in iteration
+ * \param object Object to iterate over
+ * \return Current elements id
+ */
+static inline uint8_t libambit_sbem0102_data_id(libambit_sbem0102_data_t *object)
+{
+    return object->read_ptr[0];
+}
+
+/**
+ * Get data length of current element in iteration
+ * \param object Object to iterate over
+ * \return Current elements data length
+ */
+static inline uint8_t libambit_sbem0102_data_len(libambit_sbem0102_data_t *object)
+{
+    return object->read_ptr[1];
+}
+
+/**
+ * Get data pointer of current element in iteration
+ * \param object Object to iterate over
+ * \return Current elements data pointer
+ */
+static inline const uint8_t *libambit_sbem0102_data_ptr(libambit_sbem0102_data_t *object)
+{
+    return &object->read_ptr[2];
+}
+
+
+/**
+ * Iterate to next data entry
+ * \param object Object to iterate over
+ * \return 0 on success, else -1
+ */
+static inline int libambit_sbem0102_data_next(libambit_sbem0102_data_t *object)
+{
+    // Initial state
+    if (object->read_ptr == NULL) {
+        object->read_ptr = object->data;
+        return 0;
+    }
+    // Loop state
+    if (object->data + object->size > object->read_ptr + 2 + libambit_sbem0102_data_len(object)) {
+        object->read_ptr += 2 + libambit_sbem0102_data_len(object);
+        return 0;
+    }
+    // Exit state
+    return -1;
+}
+
+#endif /* __SBEM0102_H__ */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/sha256.c ../openambit.git/src/libambit/sha256.c
--- ./src/libambit/sha256.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/sha256.c	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,176 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include <string.h>
+
+#include "sha256.h"
+
+/*
+ * Local definitions
+ */
+#define ROTLEFT(a,b)  (((a) << (b)) | ((a) >> (32-(b))))
+#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))
+#define CH(x,y,z)     (((x) & (y)) ^ (~(x) & (z)))
+#define MAJ(x,y,z)    (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
+#define EP0(x)        (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
+#define EP1(x)        (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
+#define SIG0(x)       (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
+#define SIG1(x)       (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))
+
+
+/*
+ * Static functions
+ */
+static void sha256_transform(sha256_ctx *ctx, const uint8_t *data);
+
+/*
+ * Static variables
+ */
+static const uint32_t h[8] = {
+    0x6a09e667,
+    0xbb67ae85,
+    0x3c6ef372,
+    0xa54ff53a,
+    0x510e527f,
+    0x9b05688c,
+    0x1f83d9ab,
+    0x5be0cd19
+};
+
+static const uint32_t k[SHA256_BLOCK_SIZE] = {
+    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
+    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
+    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
+    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
+    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
+    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
+    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
+    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
+};
+
+/*
+ * Public functions
+ */
+void sha256(const uint8_t *data, size_t len, uint8_t *hash)
+{
+    sha256_ctx ctx;
+
+    sha256_init(&ctx);
+    sha256_update(&ctx, data, len);
+    sha256_final(&ctx, hash);
+}
+
+void sha256_init(sha256_ctx *ctx)
+{
+    size_t i;
+    ctx->datalen = 0;
+    ctx->bitlen = 0;
+    for (i=0; i<8; i++) {
+        ctx->h[i] = h[i];
+    }
+}
+
+void sha256_update(sha256_ctx *ctx, const uint8_t *data, size_t len)
+{
+    size_t i;
+
+    for (i=0; i<len; i++) {
+        ctx->data[ctx->datalen++] = data[i];
+        if (ctx->datalen == SHA256_BLOCK_SIZE) {
+            sha256_transform(ctx, ctx->data);
+            ctx->bitlen += 512;
+            ctx->datalen = 0;
+        }
+    }
+}
+
+void sha256_final(sha256_ctx *ctx, uint8_t *hash)
+{
+    uint32_t i;
+
+    i = ctx->datalen;
+
+    // Pad data left in buffer
+    if (i < 56) {
+        // There is room for the appending length in this chunk, pad up until 56 byte
+        ctx->data[i++] = 0x80;
+        while (i < 56) {
+            ctx->data[i++] = 0x00;
+        }
+    }
+    else {
+        // No room for length, transform this chunk and use an empty one for length
+        ctx->data[i++] = 0x80;
+        while (i < 64) {
+            ctx->data[i++] = 0x00;
+        }
+        sha256_transform(ctx, ctx->data);
+        memset(ctx->data, 0, 56);
+    }
+
+    // Append total length to last buffer
+    ctx->bitlen += ctx->datalen << 3;
+    for (i=0; i<8; i++) {
+        ctx->data[63-i] = ctx->bitlen >> (8*i);
+    }
+    sha256_transform(ctx, ctx->data);
+
+    // Get hash (stored as 8 (4-byte) words)
+    for (i=0; i<8; i++) {
+        hash[(i<<2)]   = ctx->h[i] >> 24;
+        hash[(i<<2)+1] = ctx->h[i] >> 16;
+        hash[(i<<2)+2] = ctx->h[i] >> 8;
+        hash[(i<<2)+3] = ctx->h[i];
+    }
+}
+
+static void sha256_transform(sha256_ctx *ctx, const uint8_t *data)
+{
+    size_t i;
+    uint32_t m[64];
+    uint32_t th[8];
+    uint32_t t1, t2;
+
+    for (i=0; i<16; i++) {
+        m[i] = (data[(i<<2)] << 24) | (data[(i<<2)+1] << 16) | (data[(i<<2)+2] << 8) | (data[(i<<2)+3]);
+    }
+    for (i=16; i<64; i++) {
+        m[i] = SIG1(m[i-2]) + m[i-7] + SIG0(m[i-15]) + m[i-16];
+    }
+    for (i=0; i<8; i++) {
+        th[i] = ctx->h[i];
+    }
+    for (i=0; i<64; i++) {
+        t1 = th[7] + EP1(th[4]) + CH(th[4], th[5], th[6]) + k[i] + m[i];
+        t2 = EP0(th[0]) + MAJ(th[0], th[1], th[2]);
+        th[7] = th[6];
+        th[6] = th[5];
+        th[5] = th[4];
+        th[4] = th[3] + t1;
+        th[3] = th[2];
+        th[2] = th[1];
+        th[1] = th[0];
+        th[0] = t1 + t2;
+    }
+    for (i=0; i<8; i++) {
+        ctx->h[i] += th[i];
+    }
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/sha256.h ../openambit.git/src/libambit/sha256.h
--- ./src/libambit/sha256.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/sha256.h	2014-11-05 21:53:14.000000000 +0100
@@ -0,0 +1,42 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __SHA256_H__
+#define __SHA256_H__
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define SHA256_BLOCK_SIZE (512 / 8)
+
+typedef struct {
+    uint8_t  data[SHA256_BLOCK_SIZE];
+    uint32_t datalen;
+    uint64_t bitlen;
+    uint32_t h[8];
+} sha256_ctx;
+
+void sha256(const uint8_t *data, size_t len, uint8_t *hash);
+void sha256_init(sha256_ctx *ctx);
+void sha256_update(sha256_ctx *ctx, const uint8_t *data, size_t len);
+void sha256_final(sha256_ctx *ctx, uint8_t *hash);
+
+#endif /* __SHA256_H__ */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/utils.c ../openambit.git/src/libambit/utils.c
--- ./src/libambit/utils.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/utils.c	2015-03-20 20:47:45.908512152 +0100
@@ -0,0 +1,205 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include "utils.h"
+#include "debug.h"
+
+#include <ctype.h>
+#include <errno.h>
+#include <iconv.h>
+#include <limits.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+static int date_get_num(const char **pp, int n_min, int n_max, int len_max)
+{
+    int i, val, c;
+    const char *p;
+    p = *pp;
+    val = 0;
+    for(i = 0; i < len_max; i++) {
+        c = *p;
+        if (!isdigit(c))
+            break;
+        val = (val * 10) + c - '0';
+        p++;
+    }
+    /* no number read ? */
+    if (p == *pp)
+        return -1;
+    if (val < n_min || val > n_max)
+        return -1;
+    *pp = p;
+    return val;
+}
+char *libambit_strptime(const char *p, const char *fmt, struct tm *dt)
+{
+    int c, val;
+    for(;;) {
+        /* consume time string until a non whitespace char is found */
+        while (isspace(*fmt)) {
+            while (isspace(*p)) {
+                p++;
+            }
+            fmt++;
+        }
+        c = *fmt++;
+        if (c == '\0') {
+            return (char *)p;
+        } else if (c == '%') {
+            c = *fmt++;
+            switch(c) {
+              case 'H':
+              case 'J':
+                val = date_get_num(&p, 0, c == 'H' ? 23 : INT_MAX, 2);
+                if (val == -1)
+                    return NULL;
+                dt->tm_hour = val;
+                break;
+              case 'M':
+                val = date_get_num(&p, 0, 59, 2);
+                if (val == -1)
+                    return NULL;
+                dt->tm_min = val;
+                break;
+              case 'S':
+                val = date_get_num(&p, 0, 59, 2);
+                if (val == -1)
+                    return NULL;
+                dt->tm_sec = val;
+                break;
+              case 'Y':
+                val = date_get_num(&p, 0, 9999, 4);
+                if (val == -1)
+                    return NULL;
+                dt->tm_year = val - 1900;
+                break;
+              case 'm':
+                val = date_get_num(&p, 1, 12, 2);
+                if (val == -1)
+                    return NULL;
+                dt->tm_mon = val - 1;
+                break;
+              case 'd':
+                val = date_get_num(&p, 1, 31, 2);
+                if (val == -1)
+                    return NULL;
+                dt->tm_mday = val;
+                break;
+              case '%':
+                goto match;
+              default:
+                return NULL;
+            }
+        } else {
+          match:
+            if (c != *p)
+                return NULL;
+            p++;
+        }
+    }
+}
+
+/* return number representation of hex, or on error 0xff */
+static uint8_t hextob(char ch)
+{
+    if (ch >= '0' && ch <= '9')
+        return (ch - '0');
+    else if (ch >= 'A' && ch <= 'F')
+        return (ch - 'A' + 10);
+    else if (ch >= 'a' && ch <= 'f')
+        return (ch - 'a' + 10);
+    else
+        return 0xff;
+}
+int libambit_htob(const char *hex_string, uint8_t *binary, size_t binary_size)
+{
+    int i = 0;
+    uint8_t ch;
+    size_t bytes_written = 0;
+
+    if (hex_string[0] == '\0' || strlen(hex_string) % 2 != 0) {
+        return -1;
+    }
+
+    while (bytes_written < binary_size && *hex_string != '\0') {
+        if ((ch = hextob(*(hex_string++))) == 0xff)
+            return -1;
+        binary[i] = ch << 4;
+        if ((ch = hextob(*(hex_string++))) == 0xff)
+            return -1;
+        binary[i++] |= ch;
+    }
+
+    return i;
+}
+
+char * utf8memconv(const char *src, size_t n, const char *encoding)
+{
+    char *rv = NULL;
+    iconv_t cd = (iconv_t) -1;
+
+    if (src) {
+        cd = iconv_open("UTF-8", (encoding ? encoding : "ASCII"));
+        if ((iconv_t) -1 == cd) {
+            LOG_ERROR("iconv_open: %s", strerror(errno));
+        }
+        else {
+            size_t ilen = n;
+            size_t olen = n * 4 + 1;
+            char  *ibuf = (char *)src;
+            char  *obuf = (char *)malloc(olen * sizeof(char));
+
+            if (obuf) {
+                size_t n = olen;
+                size_t sz;
+
+                rv = obuf;
+                sz = iconv(cd, &ibuf, &ilen, &obuf, &olen);
+
+                if ((size_t) -1 == sz) {
+                    LOG_ERROR("iconv: %s", strerror(errno));
+                    free(rv);
+                    rv = NULL;
+                }
+                else {      /* we're good, terminate string */
+                    rv[n - olen] = '\0';
+                    rv = realloc(rv, strlen(rv) + 1);
+                }
+            }
+        }
+    }
+
+    if ((iconv_t) -1 != cd) {
+        iconv_close(cd);
+    }
+
+    return rv;
+}
+
+char * utf8wcsconv(const wchar_t *src)
+{
+    size_t len = wcslen(src) * sizeof(wchar_t);
+
+    return utf8memconv((char *)src, len, "WCHAR_T");
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/libambit/utils.h ../openambit.git/src/libambit/utils.h
--- ./src/libambit/utils.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/utils.h	2015-03-20 20:47:45.912512150 +0100
@@ -0,0 +1,94 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __UTILS_H__
+#define __UTILS_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include <time.h>
+#include <wchar.h>
+
+/**
+ * Reduced implementation of the Unix specific strptime
+ */
+char *libambit_strptime(const char *p, const char *fmt, struct tm *dt);
+
+/**
+ * Hex string to binary conversion
+ * \param Hex string to parse
+ * \param binary Buffer to store parsed hex data
+ * \param binary_size Length of buffer
+ * \return Number of converted bytes, or -1 if error occured
+ */
+int libambit_htob(const char *hex_string, uint8_t *binary, size_t binary_size);
+
+/**
+ * Converts \a n octets to a UTF-8 encoded string.
+ *
+ * The caller gets to manage the memory associated with the returned
+ * string.  In case \a encoding is \c NULL, ASCII will be assumed.
+ */
+char * utf8memconv(const char *src, size_t n, const char *encoding);
+
+/**
+ * Converts a wide character string to a UTF-8 encoded one.
+ *
+ * The caller get s to manage the memory associated with the returned
+ * string.
+ */
+char * utf8wcsconv(const wchar_t *src);
+
+// static helpers
+static inline uint8_t read8(const uint8_t *buf, size_t offset)
+{
+    return buf[offset];
+}
+
+static inline uint16_t read16(const uint8_t *buf, size_t offset)
+{
+    return (buf[offset] | (buf[offset+1] << 8));
+}
+
+static inline uint32_t read32(const uint8_t *buf, size_t offset)
+{
+    return (buf[offset] | (buf[offset+1] << 8) | (buf[offset+2] << 16) | (buf[offset+3] << 24));
+}
+
+static inline uint8_t read8inc(const uint8_t *buf, size_t *offset)
+{
+    *offset += 1;
+    return buf[(*offset)-1];
+}
+
+static inline uint16_t read16inc(const uint8_t *buf, size_t *offset)
+{
+    *offset += 2;
+    return (buf[(*offset)-2] | (buf[(*offset)-1] << 8));
+}
+
+static inline uint32_t read32inc(const uint8_t *buf, size_t *offset)
+{
+    *offset += 4;
+    return (buf[(*offset)-4] | (buf[(*offset)-3] << 8) | (buf[(*offset)-2] << 16) | (buf[(*offset)-1] << 24));
+}
+
+#endif /* __UTILS_H__ */
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/cmake/Findlibambit.cmake ../openambit.git/src/openambit/cmake/Findlibambit.cmake
--- ./src/openambit/cmake/Findlibambit.cmake	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/cmake/Findlibambit.cmake	2015-03-20 20:47:45.912512150 +0100
@@ -6,19 +6,14 @@
 # LIBAMBIT_LIBS - the libambit libraries
 
 find_path(LIBAMBIT_INCLUDE_DIR NAMES libambit.h
-  PATHS
-  ../libambit
-)
-
-find_library(LIBAMBIT_LIBS_PATH NAMES libambit.so
-  PATHS
-  ../../libambit-build
+  PATHS ${CMAKE_SOURCE_DIR}/../libambit NO_DEFAULT_PATH
 )
+find_path(LIBAMBIT_INCLUDE_DIR NAMES libambit.h)
 
 find_library(LIBAMBIT_LIBS NAMES ambit
-  PATHS
-  ../../libambit-build
+  PATHS ${CMAKE_BINARY_DIR}/../libambit-build NO_DEFAULT_PATH
 )
+find_library(LIBAMBIT_LIBS NAMES ambit)
 
 if(LIBAMBIT_INCLUDE_DIR AND LIBAMBIT_LIBS)
   set(LIBAMBIT_FOUND TRUE CACHE INTERNAL "libambit found")
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/CMakeLists.txt ../openambit.git/src/openambit/CMakeLists.txt
--- ./src/openambit/CMakeLists.txt	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/CMakeLists.txt	2015-03-20 20:47:45.912512150 +0100
@@ -1,7 +1,7 @@
 cmake_minimum_required(VERSION 2.8.5)
-project (OPENAMBIT)
+project (OPENAMBIT CXX)
 
-set (OPENAMBIT_VERSION 0.3)
+set (OPENAMBIT_VERSION HEAD)
 
 # Where to lookup modules
 set(CMAKE_MODULE_PATH "${OPENAMBIT_SOURCE_DIR}/cmake")
@@ -30,26 +30,30 @@
 )
 
 set ( openambit_HDRS
+  deviceinfo.h
   logentry.h
 )
 
 set ( openambit_SRCS
+  confirmbetadialog.cpp
+  deviceinfo.cpp
+  devicemanager.cpp
+  logentry.cpp
+  logstore.cpp
+  logview.cpp
   main.cpp
   mainwindow.cpp
-  devicemanager.cpp
-  settingsdialog.cpp
   settings.cpp
-  logstore.cpp
-  logentry.cpp
-  udevlistener.cpp
-  confirmbetadialog.cpp
+  settingsdialog.cpp
+  signalhandler.cpp
   single_application.cpp
+  udevlistener.cpp
 )
 
 set ( openambit_UIS
+  confirmbetadialog.ui
   mainwindow.ui
   settingsdialog.ui
-  confirmbetadialog.ui
 )
 
 set ( openambit_RSCS
@@ -57,42 +61,63 @@
 )
 
 set ( openambit_MOCS
-  mainwindow.h
+  confirmbetadialog.h
   devicemanager.h
-  settingsdialog.h
-  settings.h
   logstore.h
-  udevlistener.h
-  confirmbetadialog.h
+  logview.h
+  mainwindow.h
+  settings.h
+  settingsdialog.h
+  signalhandler.h
   single_application.h
+  udevlistener.h
 )
 
-set ( APP_ICON ${PROJECT_SOURCE_DIR}/icons/icon_disconnected.png )
+set (FILES_TO_TRANSLATE ${openambit_SRCS} ${openambit_UIS} ${openambit_HDRS} ${openambit_MOCS})
 
-set ( CMAKE_INSTALL_UDEVRULESDIR /lib/udev/rules.d
-      CACHE PATH "Where to install udev rules"
-)
-mark_as_advanced ( CMAKE_INSTALL_UDEVRULESDIR )
+set ( APP_ICON ${PROJECT_SOURCE_DIR}/icons/icon_disconnected.png )
 
 add_subdirectory("${PROJECT_SOURCE_DIR}/movescount")
 
+######### Translations
+file (GLOB TRANSLATIONS_FILES translations/*.ts)
+
+option (UPDATE_TRANSLATIONS "Update source translation translations/*.ts")
+if (UPDATE_TRANSLATIONS)
+  qt4_create_translation(QM_FILES ${FILES_TO_TRANSLATE} ${TRANSLATIONS_FILES})
+else (UPDATE_TRANSLATIONS)
+  qt4_add_translation(QM_FILES ${TRANSLATIONS_FILES})
+endif (UPDATE_TRANSLATIONS)
+
+# Create translations QRC file - ts.qrc
+set(TRANSLATIONS_QRC "${CMAKE_CURRENT_BINARY_DIR}/ts.qrc")
+file(WRITE ${TRANSLATIONS_QRC} "<RCC>\n\t<qresource prefix=\"/translations\">")
+foreach(QM_FILE ${QM_FILES})
+    get_filename_component(QM_FILE_NAME ${QM_FILE} NAME)
+    file(APPEND ${TRANSLATIONS_QRC} "\n\t\t<file alias=\"${QM_FILE_NAME}\">${QM_FILE_NAME}</file>")
+endforeach()
+file(APPEND ${TRANSLATIONS_QRC} "\n\t</qresource>\n</RCC>")
+list(APPEND openambit_RSCS ${TRANSLATIONS_QRC})
+
+# prevent the generated files from being deleted during make clean
+set_directory_properties(PROPERTIES CLEAN_NO_CUSTOM true)
+
+######### Translations
+
 QT4_WRAP_UI(UIS ${openambit_UIS})
 QT4_ADD_RESOURCES(RSCS ${openambit_RSCS})
 QT4_WRAP_CPP(MOCS ${openambit_MOCS})
 
 add_definitions( -DAPP_VERSION="${OPENAMBIT_VERSION}" )
 
-add_executable ( openambit ${openambit_SRCS} ${UIS} ${RSCS} ${TRS} ${MOCS} )
+add_executable ( openambit ${openambit_SRCS} ${UIS} ${RSCS} ${MOCS} )
 
 target_link_libraries ( openambit  ${QT_QTCORE_LIBRARY} ${QT_QTGUI_LIBRARY} ${QT_QTNETWORK_LIBRARY} ${LIBAMBIT_LIBS} ${UDEV_LIBS} ${ZLIB_LIBRARY} ${QJSON_LIBRARIES} )
 
 install ( TARGETS openambit DESTINATION ${CMAKE_INSTALL_BINDIR} )
-install ( FILES ${OPENAMBIT_SOURCE_DIR}/deployment/99-suunto-ambit.rules
-          DESTINATION ${CMAKE_INSTALL_UDEVRULESDIR}
-          COMPONENT system
-)
 install ( FILES ${OPENAMBIT_SOURCE_DIR}/deployment/openambit.desktop
           DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/applications )
 install ( FILES ${APP_ICON}
           DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/icons/hicolor/64x64/apps
           RENAME openambit.png )
+
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/deployment/99-suunto-ambit.rules ../openambit.git/src/openambit/deployment/99-suunto-ambit.rules
--- ./src/openambit/deployment/99-suunto-ambit.rules	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/deployment/99-suunto-ambit.rules	1970-01-01 01:00:00.000000000 +0100
@@ -1,22 +0,0 @@
-#
-# Suunto Ambit / Ambit 2 UDEV rules
-# Change the permissions for devices to 0666 (work readable/writeable)
-#
-
-# Bluebird (a.k.a Suunto Ambit)
-SUBSYSTEMS=="usb", ATTRS{idVendor}=="1493", ATTRS{idProduct}=="0010", MODE="0666"
-
-# Duck (a.k.a Suunto Ambit2)
-SUBSYSTEMS=="usb", ATTRS{idVendor}=="1493", ATTRS{idProduct}=="0019", MODE="0666"
-
-# Colibri (a.k.a Suunto Ambit2 S)
-SUBSYSTEMS=="usb", ATTRS{idVendor}=="1493", ATTRS{idProduct}=="001a", MODE="0666"
-
-# Emu (a.k.a Suunto Ambit3 Peak)
-SUBSYSTEMS=="usb", ATTRS{idVendor}=="1493", ATTRS{idProduct}=="001b", MODE="0666"
-
-# Finch (a.k.a Suunto Ambit3 Sport)
-SUBSYSTEMS=="usb", ATTRS{idVendor}=="1493", ATTRS{idProduct}=="001c", MODE="0666"
-
-# Greentit (a.k.a Suunto Ambit2 R)
-SUBSYSTEMS=="usb", ATTRS{idVendor}=="1493", ATTRS{idProduct}=="001d", MODE="0666"
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/deployment/openambit.desktop ../openambit.git/src/openambit/deployment/openambit.desktop
--- ./src/openambit/deployment/openambit.desktop	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/deployment/openambit.desktop	2015-03-20 20:47:45.912512150 +0100
@@ -1,9 +1,9 @@
 [Desktop Entry]
-Version=0.3
+Version=1.0
 Type=Application
 Name=Openambit
 Comment=Open source synchronization for Suunto Ambit series
 TryExec=openambit
 Exec=openambit
 Icon=openambit
-Categories=Utility;Education;Sports
+Categories=Utility;Education;Sports;
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/deviceinfo.cpp ../openambit.git/src/openambit/deviceinfo.cpp
--- ./src/openambit/deviceinfo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/deviceinfo.cpp	2015-03-20 20:47:45.912512150 +0100
@@ -0,0 +1,42 @@
+/*
+ * (C) Copyright 2014 Olaf Meeuwissen
+ *
+ * This file is part of Openambit.
+ *
+ * Openambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include "deviceinfo.h"
+
+DeviceInfo&
+DeviceInfo::operator=(const ambit_device_info_t& devinfo)
+{
+    this->name   = QString::fromUtf8(devinfo.name);
+    this->model  = QString::fromUtf8(devinfo.model);
+    this->serial = QString::fromUtf8(devinfo.serial);
+
+    this->fw_version[0] = devinfo.fw_version[0];
+    this->fw_version[1] = devinfo.fw_version[1];
+    this->fw_version[2] = devinfo.fw_version[2] | (devinfo.fw_version[3] << 8);
+    this->hw_version[0] = devinfo.hw_version[0];
+    this->hw_version[1] = devinfo.hw_version[1];
+    this->hw_version[2] = devinfo.hw_version[2] | (devinfo.hw_version[3] << 8);
+
+    this->access_status = devinfo.access_status;
+    this->is_supported  = devinfo.is_supported;
+
+    return *this;
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/deviceinfo.h ../openambit.git/src/openambit/deviceinfo.h
--- ./src/openambit/deviceinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/deviceinfo.h	2015-03-20 20:47:45.912512150 +0100
@@ -0,0 +1,44 @@
+/*
+ * (C) Copyright 2014 Olaf Meeuwissen
+ *
+ * This file is part of Openambit.
+ *
+ * Openambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef DEVICEINFO_H
+#define DEVICEINFO_H
+
+#include <QString>
+
+#include <libambit.h>
+
+struct DeviceInfo
+{
+    QString name;
+    QString model;
+    QString serial;
+
+    int fw_version[3];
+    int hw_version[3];
+
+    int access_status;
+    bool is_supported;
+
+    DeviceInfo& operator= (const ambit_device_info_t& devinfo);
+};
+
+#endif // DEVICEINFO_H
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/devicemanager.cpp ../openambit.git/src/openambit/devicemanager.cpp
--- ./src/openambit/devicemanager.cpp	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/devicemanager.cpp	2015-03-20 20:47:45.912512150 +0100
@@ -59,15 +59,17 @@
     mutex.lock();
     if (this->deviceObject != NULL) {
         libambit_close(this->deviceObject);
+        this->deviceObject = NULL;
+        emit deviceRemoved();
     }
-    this->deviceObject = libambit_detect();
 
-    if (this->deviceObject != NULL && (res = libambit_device_info_get(this->deviceObject, &this->currentDeviceInfo)) == 0) {
-        emit deviceDetected(this->currentDeviceInfo, libambit_device_supported(this->deviceObject));
-    }
-    else {
-        emit deviceRemoved();
+    ambit_device_info_t *devinfo = libambit_enumerate();
+    if (devinfo) {
+        this->currentDeviceInfo = *devinfo;
+        emit deviceDetected(this->currentDeviceInfo);
+        this->deviceObject = libambit_new(devinfo);
     }
+    libambit_free_enumeration(devinfo);
     mutex.unlock();
 
     if (res == 0) {
@@ -171,7 +173,7 @@
 int DeviceManager::log_skip_cb(void *ref, ambit_log_header_t *log_header)
 {
     DeviceManager *manager = static_cast<DeviceManager*> (ref);
-    if (manager->logStore.logExists(QString(manager->currentDeviceInfo.serial), log_header)) {
+    if (manager->logStore.logExists(manager->currentDeviceInfo.serial, log_header)) {
         return 0;
     }
     return 1;
@@ -180,7 +182,7 @@
 void DeviceManager::log_push_cb(void *ref, ambit_log_entry_t *log_entry)
 {
     DeviceManager *manager = static_cast<DeviceManager*> (ref);
-    LogEntry *entry = manager->logStore.store(&manager->currentDeviceInfo, &manager->currentPersonalSettings, log_entry);
+    LogEntry *entry = manager->logStore.store(manager->currentDeviceInfo, &manager->currentPersonalSettings, log_entry);
     if (entry != NULL) {
         //! TODO: make this optional, only used for debugging
         manager->movesCountXML.writeLog(entry);
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/devicemanager.h ../openambit.git/src/openambit/devicemanager.h
--- ./src/openambit/devicemanager.h	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/devicemanager.h	2015-03-20 20:47:45.912512150 +0100
@@ -46,7 +46,7 @@
     ~DeviceManager();
     void start();
 signals:
-    void deviceDetected(ambit_device_info_t deviceInfo, bool supported);
+    void deviceDetected(const DeviceInfo& deviceInfo);
     void deviceRemoved(void);
     void deviceCharge(quint8 percent);
     void syncFinished(bool success);
@@ -67,7 +67,7 @@
     ambit_object_t *deviceObject;
     UdevListener *udevListener;
 
-    ambit_device_info_t currentDeviceInfo;
+    DeviceInfo currentDeviceInfo;
     ambit_personal_settings_t currentPersonalSettings;
 
     int syncParts;
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/logentry.cpp ../openambit.git/src/openambit/logentry.cpp
--- ./src/openambit/logentry.cpp	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/logentry.cpp	2015-03-20 20:47:45.912512150 +0100
@@ -22,7 +22,6 @@
 #include "logentry.h"
 
 LogEntry::LogEntry() :
-    deviceInfo(NULL),
     personalSettings(NULL),
     logEntry(NULL)
 {
@@ -35,14 +34,7 @@
     device = other.device;
     time = other.time;
     movescountId = other.movescountId;
-
-    if (other.deviceInfo != NULL) {
-        deviceInfo = (ambit_device_info_t*)malloc(sizeof(ambit_device_info_t));
-        memcpy(deviceInfo, other.deviceInfo, sizeof(ambit_device_info_t));
-    }
-    else {
-        deviceInfo = NULL;
-    }
+    deviceInfo = other.deviceInfo;
 
     if (other.personalSettings != NULL) {
         personalSettings = (ambit_personal_settings_t*)malloc(sizeof(ambit_personal_settings_t));
@@ -55,6 +47,9 @@
     if (other.logEntry != NULL) {
         logEntry = (ambit_log_entry_t*)malloc(sizeof(ambit_log_entry_t));
         memcpy(logEntry, other.logEntry, sizeof(ambit_log_entry_t));
+        if (other.logEntry->header.activity_name) {
+            logEntry->header.activity_name = strdup(other.logEntry->header.activity_name);
+        }
         if (other.logEntry->samples != NULL) {
             logEntry->samples = (ambit_log_sample_t*)malloc(sizeof(ambit_log_sample_t)*other.logEntry->samples_count);
             memcpy(logEntry->samples, other.logEntry->samples, sizeof(ambit_log_sample_t)*other.logEntry->samples_count);
@@ -100,11 +95,6 @@
 {
     u_int32_t i;
 
-    if (deviceInfo != NULL) {
-        free(deviceInfo);
-        deviceInfo = NULL;
-    }
-
     if (personalSettings != NULL) {
         free(personalSettings);
         personalSettings = NULL;
@@ -143,37 +133,3 @@
     }
     return true;
 }
-
-QString LogEntry::toHtml(){
-    QString log_html;
-
-    log_html += "<h1>" + QString::fromLatin1(this->logEntry->header.activity_name) + "</h1>";
-    if (this->isUploaded()){
-        log_html += "<a href='http://www.movescount.com/moves/move" + this->movescountId + "'>see on movescount.com</a>";
-    }
-    else {
-        log_html += "Not uploaded yet";
-    }
-    log_html += "<h2>Details</h2>";
-    log_html += "<h4>" + this->time.toString() + "</h4>";
-    log_html += "<h4>Duration: " + QTime(0, 0, 0,0 ).addMSecs(this->logEntry->header.duration).toString("HH:mm:ss") + "</h4>";
-    log_html += "<h4>Distance: " + QString::number(this->logEntry->header.distance) + " m</h4>";
-    log_html += "<h2>Training values</h2>";
-    log_html += "<h4>Avg HR: " + QString::number(this->logEntry->header.heartrate_avg) + " bpm</h4>";
-    log_html += "<h4>Max HR: " + QString::number(this->logEntry->header.heartrate_max) + " bpm</h4>";
-    log_html += "<h4>Min HR: " + QString::number(this->logEntry->header.heartrate_min) + " bpm</h4>";
-    log_html += "<h4>PTE: " + QString::number(this->logEntry->header.peak_training_effect/10.0) + "</h4>";
-    log_html += "<h2>Device</h2>";
-    log_html += "<h4>Name: " + QString(this->deviceInfo->name) + "</h4>";
-    log_html += "<h4>Variant: " + QString(this->deviceInfo->model) + "</h4>";
-    log_html += "<h4>Serial: " + QString(this->deviceInfo->serial) + "</h4>";
-    //log_string += "Device info: " + QString::number(this->deviceInfo->fw_version) + "\n";
-    //log_string += "Device info: " + QString::number(this->deviceInfo->hw_version) + "\n";
-
-    //log_string += "Personal Settings: " + this->personalSettings + "\n";
-
-
-    return log_html;
-}
-
-
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/logentry.h ../openambit.git/src/openambit/logentry.h
--- ./src/openambit/logentry.h	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/logentry.h	2015-03-20 20:47:45.912512150 +0100
@@ -25,6 +25,8 @@
 #include <QDateTime>
 #include <libambit.h>
 
+#include "deviceinfo.h"
+
 class LogEntry
 {
 public:
@@ -34,13 +36,12 @@
 
     LogEntry& operator=(const LogEntry &rhs);
 
-    QString toHtml();
     bool isUploaded();
 
     QString device;
     QDateTime time;
     QString movescountId;
-    ambit_device_info_t *deviceInfo;
+    DeviceInfo deviceInfo;
     ambit_personal_settings_t *personalSettings;
     ambit_log_entry_t *logEntry;
 signals:
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/logstore.cpp ../openambit.git/src/openambit/logstore.cpp
--- ./src/openambit/logstore.cpp	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/logstore.cpp	2015-03-20 20:47:45.928512158 +0100
@@ -46,8 +46,12 @@
     { ambit_log_sample_type_gps_small, "gps-small" },
     { ambit_log_sample_type_gps_tiny, "gps-tiny" },
     { ambit_log_sample_type_time, "time" },
+    { ambit_log_sample_type_swimming_turn, "swimming-turn" },
+    { ambit_log_sample_type_swimming_stroke, "swimming-stroke" },
     { ambit_log_sample_type_activity, "activity" },
+    { ambit_log_sample_type_cadence_source, "cadence-source" },
     { ambit_log_sample_type_position, "position" },
+    { ambit_log_sample_type_fwinfo, "fwinfo" },
     { ambit_log_sample_type_unknown, "unknown" },
     { (ambit_log_sample_type_t)0, "" }
 };
@@ -58,8 +62,12 @@
 } sample_distance_source_name_t;
 
 static sample_distance_source_name_t sampleDistanceSourceNames[] = {
+    { 0x00, "Bikepod" },
+    { 0x01, "Footpod" },
     { 0x02, "GPS" },
     { 0x03, "Wrist" },
+    { 0x04, "Indoorswimming" },
+    { 0x05, "Outdoorswimming" },
     { 0, "" }
 };
 
@@ -89,18 +97,43 @@
     { 0, "" }
 };
 
+typedef struct sample_cadence_source_name_s {
+    u_int8_t source_id;
+    QString XMLName;
+} sample_cadence_source_name_t;
+
+static sample_cadence_source_name_t sampleCadenceSourceNames[] = {
+    { 0x40, "Wrist" },
+    { 0, "" }
+};
+
+typedef struct sample_swimming_style_name_s {
+    u_int8_t source_id;
+    QString XMLName;
+} sample_swimming_style_name_t;
+
+static sample_swimming_style_name_t sampleSwimmingStyleNames[] = {
+    { 0x00, "Other" },
+    { 0x01, "Butterfly" },
+    { 0x02, "Backstroke" },
+    { 0x03, "Breaststroke" },
+    { 0x04, "Freestyle" },
+    { 0x05, "Drill" },
+    { 0, "" }
+};
+
 LogStore::LogStore(QObject *parent) :
     QObject(parent)
 {
     storagePath = QString(getenv("HOME")) + "/.openambit";
 }
 
-LogEntry *LogStore::store(ambit_device_info_t *deviceInfo, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry)
+LogEntry *LogStore::store(const DeviceInfo& deviceInfo, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry)
 {
     QDateTime dateTime(QDate(logEntry->header.date_time.year, logEntry->header.date_time.month, logEntry->header.date_time.day),
                        QTime(logEntry->header.date_time.hour, logEntry->header.date_time.minute, logEntry->header.date_time.msec/1000));
 
-    return storeInternal(QString(deviceInfo->serial), dateTime, deviceInfo, personalSettings, logEntry);
+    return storeInternal(deviceInfo.serial, dateTime, deviceInfo, personalSettings, logEntry);
 }
 
 LogEntry *LogStore::store(LogEntry *entry)
@@ -178,7 +211,7 @@
     return storagePath + "/log_" + device + "_" + time.toString("yyyy_MM_dd_hh_mm_ss") + ".log";
 }
 
-LogEntry *LogStore::storeInternal(QString serial, QDateTime dateTime, ambit_device_info_t *deviceInfo, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry, QString movescountId)
+LogEntry *LogStore::storeInternal(QString serial, QDateTime dateTime, const DeviceInfo& deviceInfo, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry, QString movescountId)
 {
     LogEntry *retEntry = new LogEntry();
 
@@ -190,6 +223,9 @@
     logfile.open(QIODevice::ReadOnly);
     XMLReader reader(retEntry);
     if (!reader.read(&logfile)) {
+        if (retEntry->logEntry && retEntry->logEntry->header.activity_name) {
+            free(retEntry->logEntry->header.activity_name);
+        }
         delete retEntry;
         retEntry = NULL;
     }
@@ -304,35 +340,28 @@
 
     Q_ASSERT(xml.isStartElement() && xml.name() == "DeviceInfo");
 
-    if (logEntry->deviceInfo == NULL) {
-        logEntry->deviceInfo = (ambit_device_info_t*)malloc(sizeof(ambit_device_info_t));
-        memset(logEntry->deviceInfo, 0, sizeof(ambit_device_info_t));
-    }
-
     while (xml.readNextStartElement()) {
         if (xml.name() == "Serial") {
-            strcpy(logEntry->deviceInfo->serial, xml.readElementText().toLatin1().data());
+            logEntry->deviceInfo.serial = xml.readElementText().toUtf8();
         }
         else if (xml.name() == "Model") {
-            strcpy(logEntry->deviceInfo->model, xml.readElementText().toLatin1().data());
+            logEntry->deviceInfo.model = xml.readElementText().toUtf8();
         }
         else if (xml.name() == "Name") {
-            strcpy(logEntry->deviceInfo->name, xml.readElementText().toLatin1().data());
+            logEntry->deviceInfo.name = xml.readElementText().toUtf8();
         }
         else if (xml.name() == "FWVersion") {
             if (versionRX.indexIn(xml.readElementText()) >= 0) {
-                logEntry->deviceInfo->fw_version[0] = versionRX.cap(1).toInt();
-                logEntry->deviceInfo->fw_version[1] = versionRX.cap(2).toInt();
-                logEntry->deviceInfo->fw_version[2] = versionRX.cap(3).toInt() & 0xff;
-                logEntry->deviceInfo->fw_version[3] = (versionRX.cap(3).toInt() >> 8) & 0xff;
+                logEntry->deviceInfo.fw_version[0] = versionRX.cap(1).toInt();
+                logEntry->deviceInfo.fw_version[1] = versionRX.cap(2).toInt();
+                logEntry->deviceInfo.fw_version[2] = versionRX.cap(3).toInt();
             }
         }
         else if (xml.name() == "HWVersion") {
             if (versionRX.indexIn(xml.readElementText()) >= 0) {
-                logEntry->deviceInfo->hw_version[0] = versionRX.cap(1).toInt();
-                logEntry->deviceInfo->hw_version[1] = versionRX.cap(2).toInt();
-                logEntry->deviceInfo->hw_version[2] = versionRX.cap(3).toInt() & 0xff;
-                logEntry->deviceInfo->hw_version[3] = (versionRX.cap(3).toInt() >> 8) & 0xff;
+                logEntry->deviceInfo.hw_version[0] = versionRX.cap(1).toInt();
+                logEntry->deviceInfo.hw_version[1] = versionRX.cap(2).toInt();
+                logEntry->deviceInfo.hw_version[2] = versionRX.cap(3).toInt();
             }
         }
         else {
@@ -470,6 +499,9 @@
         else if (xml.name() == "AltiBaroMode") {
             logEntry->personalSettings->alti_baro_mode = xml.readElementText().toUInt();
         }
+        else if (xml.name() == "StormAlarm") {
+            logEntry->personalSettings->storm_alarm = xml.readElementText().toUInt();
+        }
         else if (xml.name() == "FusedAltiDisabled") {
             logEntry->personalSettings->fused_alti_disabled = xml.readElementText().toUInt();
         }
@@ -488,6 +520,12 @@
         else if (xml.name() == "AutomaticBikePowerCalibration") {
             logEntry->personalSettings->automatic_bikepower_calib = xml.readElementText().toUInt();
         }
+        else if (xml.name() == "AutomaticFootPODCalibration") {
+            logEntry->personalSettings->automatic_footpod_calib = xml.readElementText().toUInt();
+        }
+        else if (xml.name() == "TrainingProgram") {
+            logEntry->personalSettings->training_program = xml.readElementText().toUInt();
+        }
         else {
             xml.skipCurrentElement();
         }
@@ -627,10 +665,9 @@
             logEntry->logEntry->header.activity_type = xml.readElementText().toUInt();
         }
         else if (xml.name() == "Activity") {
-            QByteArray ba = xml.readElementText().toLatin1();
+            QByteArray ba = xml.readElementText().toUtf8();
             const char *c_str = ba.data();
-            strncpy(logEntry->logEntry->header.activity_name, c_str, 16);
-            logEntry->logEntry->header.activity_name[16] = 0;
+            logEntry->logEntry->header.activity_name = strdup(c_str);
         }
         else if (xml.name() == "Temperature") {
             while (xml.readNextStartElement()) {
@@ -672,6 +709,19 @@
         else if (xml.name() == "DistanceBeforeCalibrationChange") {
             logEntry->logEntry->header.distance_before_calib = xml.readElementText().toUInt();
         }
+        else if (xml.name() == "Swimming") {
+            while (xml.readNextStartElement()) {
+                if (xml.name() == "PoolLengths") {
+                    logEntry->logEntry->header.swimming_pool_lengths = xml.readElementText().toUInt();
+                }
+                else if (xml.name() == "PoolLength") {
+                    logEntry->logEntry->header.swimming_pool_length = xml.readElementText().toUInt();
+                }
+                else {
+                    xml.skipCurrentElement();
+                }
+            }
+        }
         else if (xml.name() == "Unknown1") {
             QByteArray val = xml.readElementText().toLocal8Bit();
             const char *c_str = val.data();
@@ -695,7 +745,7 @@
                 sscanf(c_str, "%2hhx", &logEntry->logEntry->header.cadence_avg);
                 c_str += 2 * sizeof(char);
             }
-            for (int i=0; i<4 && i<val.length()/2; i++) {
+            for (int i=0; i<2 && i<val.length()/2; i++) {
                 sscanf(c_str, "%2hhx", &logEntry->logEntry->header.unknown3[i]);
                 c_str += 2 * sizeof(char);
             }
@@ -714,10 +764,6 @@
                 }
                 logEntry->logEntry->header.cadence_max_time = cadence_max_time;
             }
-            for (int i=0; i<4 && i<val.length()/2; i++) {
-                sscanf(c_str, "%2hhx", &logEntry->logEntry->header.unknown4[i]);
-                c_str += 2 * sizeof(char);
-            }
         }
         else if (xml.name() == "Unknown5") {
             QByteArray val = xml.readElementText().toLocal8Bit();
@@ -993,6 +1039,39 @@
                             xml.skipCurrentElement();
                         }
                         break;
+                    case ambit_log_sample_type_swimming_turn:
+                        if (xml.name() == "Distance") {
+                            logEntry->logEntry->samples[sampleCount].u.swimming_turn.distance = xml.readElementText().toInt();
+                        }
+                        else if (xml.name() == "Lengths") {
+                            logEntry->logEntry->samples[sampleCount].u.swimming_turn.lengths = xml.readElementText().toInt();
+                        }
+                        else if (xml.name() == "Classification") {
+                            int itemCount = 0;
+                            while(xml.readNextStartElement()) {
+                                if (xml.name() == "Item" && itemCount < (int)(sizeof(logEntry->logEntry->samples[sampleCount].u.swimming_turn.classification)/sizeof(logEntry->logEntry->samples[sampleCount].u.swimming_turn.classification[0]))) {
+                                    logEntry->logEntry->samples[sampleCount].u.swimming_turn.classification[itemCount++] = xml.readElementText().toInt();
+                                }
+                                else {
+                                    /* Should not get here! */
+                                    xml.skipCurrentElement();
+                                }
+                            }
+                        }
+                        else if (xml.name() == "Style") {
+                            int styleId = xml.attributes().value("id").toString().toUInt();
+                            logEntry->logEntry->samples[sampleCount].u.swimming_turn.style = styleId;
+                            xml.skipCurrentElement();
+                        }
+                        else {
+                            /* Should not get here! */
+                            xml.skipCurrentElement();
+                        }
+                        break;
+                    case ambit_log_sample_type_swimming_stroke:
+                        /* Should not get here! */
+                        xml.skipCurrentElement();
+                        break;
                     case ambit_log_sample_type_activity:
                         if (xml.name() == "ActivityType") {
                             logEntry->logEntry->samples[sampleCount].u.activity.activitytype = xml.readElementText().toUInt();
@@ -1005,6 +1084,17 @@
                             xml.skipCurrentElement();
                         }
                         break;
+                    case ambit_log_sample_type_cadence_source:
+                        if (xml.name() == "CadenceSource") {
+                            int cadenceId = xml.attributes().value("id").toString().toUInt();
+                            logEntry->logEntry->samples[sampleCount].u.cadence_source = cadenceId;
+                            xml.skipCurrentElement();
+                        }
+                        else {
+                            /* Should not get here! */
+                            xml.skipCurrentElement();
+                        }
+                        break;
                     case ambit_log_sample_type_position:
                         if (xml.name() == "Latitude") {
                             logEntry->logEntry->samples[sampleCount].u.position.latitude = xml.readElementText().toInt();
@@ -1017,6 +1107,33 @@
                             xml.skipCurrentElement();
                         }
                         break;
+                    case ambit_log_sample_type_fwinfo:
+                    {
+                        QRegExp versionRX("([0-9]+)\\.([0-9]+)\\.([0-9]+)");
+
+                        if (xml.name() == "Version") {
+                            if (versionRX.indexIn(xml.readElementText()) >= 0) {
+                                logEntry->logEntry->samples[sampleCount].u.fwinfo.version[0] = versionRX.cap(1).toInt();
+                                logEntry->logEntry->samples[sampleCount].u.fwinfo.version[1] = versionRX.cap(2).toInt();
+                                logEntry->logEntry->samples[sampleCount].u.fwinfo.version[2] = versionRX.cap(3).toInt() & 0xff;
+                                logEntry->logEntry->samples[sampleCount].u.fwinfo.version[3] = (versionRX.cap(3).toInt() >> 8) & 0xff;
+                            }
+                        }
+                        else if (xml.name() == "BuildDate") {
+                            QDateTime datetime = QDateTime::fromString(xml.readElementText(), Qt::ISODate);
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.year = datetime.date().year();
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.month = datetime.date().month();
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.day = datetime.date().day();
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.hour = datetime.time().hour();
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.minute = datetime.time().minute();
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.msec = datetime.time().second()*1000 + datetime.time().msec();
+                        }
+                        else {
+                            /* Should not get here! */
+                            xml.skipCurrentElement();
+                        }
+                        break;
+                    }
                     case ambit_log_sample_type_unknown:
                         if (xml.name() == "Data") {
                             QByteArray val = xml.readElementText().toLocal8Bit();
@@ -1027,6 +1144,7 @@
                                     sscanf(c_str, "%2hhx", &logEntry->logEntry->samples[sampleCount].u.unknown.data[i]);
                                     c_str += 2 * sizeof(char);
                                 }
+                                logEntry->logEntry->samples[sampleCount].u.unknown.datalen = val.length()/2;
                             }
                         }
                         else {
@@ -1234,7 +1352,7 @@
 }
 
 
-LogStore::XMLWriter::XMLWriter(ambit_device_info_t *deviceInfo, QDateTime time, QString movescountId, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry) :
+LogStore::XMLWriter::XMLWriter(const DeviceInfo& deviceInfo, QDateTime time, QString movescountId, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry) :
     deviceInfo(deviceInfo), time(time), movescountId(movescountId), personalSettings(personalSettings), logEntry(logEntry)
 {
     xml.setAutoFormatting(true);
@@ -1251,7 +1369,7 @@
     xml.writeStartElement("openambitlog");
     xml.writeAttribute("version", "1.0");
 
-    xml.writeTextElement("SerialNumber", QString("%1").arg(deviceInfo->serial));
+    xml.writeTextElement("SerialNumber", deviceInfo.serial);
     xml.writeTextElement("Time", time.toString(Qt::ISODate));
     xml.writeTextElement("MovescountId", QString("%1").arg(movescountId));
     ret = writeDeviceInfo();
@@ -1268,11 +1386,11 @@
 bool LogStore::XMLWriter::writeDeviceInfo()
 {
     xml.writeStartElement("DeviceInfo");
-    xml.writeTextElement("Serial", QString("%1").arg(deviceInfo->serial));
-    xml.writeTextElement("Model", QString("%1").arg(deviceInfo->model));
-    xml.writeTextElement("Name", QString("%1").arg(deviceInfo->name));
-    xml.writeTextElement("FWVersion", QString("%1.%2.%3").arg((int)deviceInfo->fw_version[0]).arg((int)deviceInfo->fw_version[1]).arg((int)deviceInfo->fw_version[2] | ((int)deviceInfo->fw_version[3] << 8)));
-    xml.writeTextElement("HWVersion", QString("%1.%2.%3").arg((int)deviceInfo->hw_version[0]).arg((int)deviceInfo->hw_version[1]).arg((int)deviceInfo->hw_version[2] | ((int)deviceInfo->hw_version[3] << 8)));
+    xml.writeTextElement("Serial", deviceInfo.serial);
+    xml.writeTextElement("Model", deviceInfo.model);
+    xml.writeTextElement("Name", deviceInfo.name);
+    xml.writeTextElement("FWVersion", QString("%1.%2.%3").arg(deviceInfo.fw_version[0]).arg(deviceInfo.fw_version[1]).arg(deviceInfo.fw_version[2]));
+    xml.writeTextElement("HWVersion", QString("%1.%2.%3").arg(deviceInfo.hw_version[0]).arg(deviceInfo.hw_version[1]).arg(deviceInfo.hw_version[2]));
     xml.writeEndElement();
 
     return true;
@@ -1321,12 +1439,15 @@
     xml.writeTextElement("IsMale", QString("%1").arg(personalSettings->is_male));
     xml.writeTextElement("Length", QString("%1").arg(personalSettings->length));
     xml.writeTextElement("AltiBaroMode", QString("%1").arg(personalSettings->alti_baro_mode));
+    xml.writeTextElement("StormAlarm", QString("%1").arg(personalSettings->storm_alarm));
     xml.writeTextElement("FusedAltiDisabled", QString("%1").arg(personalSettings->fused_alti_disabled));
     xml.writeTextElement("BikePODCalibration", QString("%1").arg(personalSettings->bikepod_calibration));
     xml.writeTextElement("BikePODCalibration2", QString("%1").arg(personalSettings->bikepod_calibration2));
     xml.writeTextElement("BikePODCalibration3", QString("%1").arg(personalSettings->bikepod_calibration3));
     xml.writeTextElement("FootPODCalibration", QString("%1").arg(personalSettings->footpod_calibration));
     xml.writeTextElement("AutomaticBikePowerCalibration", QString("%1").arg(personalSettings->automatic_bikepower_calib));
+    xml.writeTextElement("AutomaticFootPODCalibration", QString("%1").arg(personalSettings->automatic_footpod_calib));
+    xml.writeTextElement("TrainingProgram", QString("%1").arg(personalSettings->training_program));
 
     xml.writeEndElement();
 
@@ -1372,7 +1493,7 @@
     xml.writeEndElement();
     xml.writeTextElement("PeakTrainingEffect", QString("%1").arg(logEntry->header.peak_training_effect));
     xml.writeTextElement("ActivityType", QString("%1").arg(logEntry->header.activity_type));
-    xml.writeTextElement("Activity", QString::fromLatin1(logEntry->header.activity_name));
+    xml.writeTextElement("Activity", QString::fromUtf8(logEntry->header.activity_name));
     xml.writeStartElement("Temperature");
     xml.writeTextElement("Max", QString("%1").arg(logEntry->header.temperature_max));
     xml.writeTextElement("Min", QString("%1").arg(logEntry->header.temperature_min));
@@ -1386,6 +1507,10 @@
     xml.writeTextElement("BatteryChargeAtStart", QString("%1").arg(logEntry->header.battery_start));
     xml.writeTextElement("BatteryCharge", QString("%1").arg(logEntry->header.battery_end));
     xml.writeTextElement("DistanceBeforeCalibrationChange", QString("%1").arg(logEntry->header.distance_before_calib));
+    xml.writeStartElement("Swimming");
+    xml.writeTextElement("PoolLengths", QString("%1").arg(logEntry->header.swimming_pool_lengths));
+    xml.writeTextElement("PoolLength", QString("%1").arg(logEntry->header.swimming_pool_length));
+    xml.writeEndElement();
 
     QString hexstring;
     hexstring = hexstring.sprintf("%02x%02x%02x%02x%02x", logEntry->header.unknown1[0],
@@ -1396,16 +1521,9 @@
     xml.writeTextElement("Unknown1", hexstring);
     hexstring = hexstring.sprintf("%02x", logEntry->header.unknown2);
     xml.writeTextElement("Unknown2", hexstring);
-    hexstring = hexstring.sprintf("%02x%02x%02x%02x", logEntry->header.unknown3[0],
-                                                      logEntry->header.unknown3[1],
-                                                      logEntry->header.unknown3[2],
-                                                      logEntry->header.unknown3[3]);
+    hexstring = hexstring.sprintf("%02x%02x", logEntry->header.unknown3[0],
+                                              logEntry->header.unknown3[1]);
     xml.writeTextElement("Unknown3", hexstring);
-    hexstring = hexstring.sprintf("%02x%02x%02x%02x", logEntry->header.unknown4[0],
-                                                      logEntry->header.unknown4[1],
-                                                      logEntry->header.unknown4[2],
-                                                      logEntry->header.unknown4[3]);
-    xml.writeTextElement("Unknown4", hexstring);
     hexstring = hexstring.sprintf("%02x%02x%02x%02x", logEntry->header.unknown5[0],
                                                       logEntry->header.unknown5[1],
                                                       logEntry->header.unknown5[2],
@@ -1455,6 +1573,8 @@
     sample_distance_source_name_t *distance_source_name;
     sample_altitude_source_name_t *altitude_source_name;
     sample_lap_event_type_t *lap_type_name;
+    sample_cadence_source_name_t *cadence_source_name;
+    sample_swimming_style_name_t *swimming_style_name;
     int i;
 
     xml.writeStartElement("Sample");
@@ -1583,14 +1703,60 @@
         xml.writeTextElement("TimeRef", timeref.toString(Qt::ISODate));
         break;
     }
+    case ambit_log_sample_type_swimming_turn:
+    {
+        xml.writeTextElement("Distance", QString("%1").arg(sample->u.swimming_turn.distance));
+        xml.writeTextElement("Lengths", QString("%1").arg(sample->u.swimming_turn.lengths));
+        xml.writeStartElement("Classification");
+        for (size_t i=0; i<(sizeof(sample->u.swimming_turn.classification)/sizeof(sample->u.swimming_turn.classification[0])); i++) {
+            xml.writeTextElement("Item", QString("%1").arg(sample->u.swimming_turn.classification[i]));
+        }
+        xml.writeEndElement();
+        xml.writeStartElement("Style");
+        xml.writeAttribute("id", QString("%1").arg(sample->u.swimming_turn.style));
+        for (swimming_style_name = &sampleSwimmingStyleNames[0]; swimming_style_name->XMLName != ""; swimming_style_name++) {
+            if (swimming_style_name->source_id == sample->u.swimming_turn.style) {
+                xml.writeCharacters(QString(swimming_style_name->XMLName));
+                break;
+            }
+        }
+        xml.writeEndElement();
+        break;
+    }
+    case ambit_log_sample_type_swimming_stroke:
+        break;
     case ambit_log_sample_type_activity:
+    {
         xml.writeTextElement("ActivityType", QString("%1").arg(sample->u.activity.activitytype));
         xml.writeTextElement("CustomModeId", QString("%1").arg(sample->u.activity.custommode));
         break;
+    }
+    case ambit_log_sample_type_cadence_source:
+    {
+        xml.writeStartElement("CadenceSource");
+        xml.writeAttribute("id", QString("%1").arg(sample->u.cadence_source));
+        for (cadence_source_name = &sampleCadenceSourceNames[0]; cadence_source_name->XMLName != ""; cadence_source_name++) {
+            if (cadence_source_name->source_id == sample->u.cadence_source) {
+                xml.writeCharacters(QString(cadence_source_name->XMLName));
+                break;
+            }
+        }
+        xml.writeEndElement();
+        break;
+    }
     case ambit_log_sample_type_position:
+    {
         xml.writeTextElement("Latitude", QString("%1").arg(sample->u.position.latitude));
         xml.writeTextElement("Longitude", QString("%1").arg(sample->u.position.longitude));
         break;
+    }
+    case ambit_log_sample_type_fwinfo:
+    {
+        xml.writeTextElement("Version", QString("%1.%2.%3").arg((int)sample->u.fwinfo.version[0]).arg((int)sample->u.fwinfo.version[1]).arg((int)sample->u.fwinfo.version[2] | ((int)sample->u.fwinfo.version[3] << 8)));
+        QDateTime dateTime(QDate(sample->u.fwinfo.build_date.year, sample->u.fwinfo.build_date.month, sample->u.fwinfo.build_date.day), QTime(sample->u.fwinfo.build_date.hour, sample->u.fwinfo.build_date.minute, 0).addMSecs(sample->u.fwinfo.build_date.msec));
+        xml.writeTextElement("BuildDate", dateTime.toString(Qt::ISODate));
+        break;
+    }
     case ambit_log_sample_type_unknown:
     {
         QString data = "";
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/logstore.h ../openambit.git/src/openambit/logstore.h
--- ./src/openambit/logstore.h	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/logstore.h	2015-03-20 20:47:45.928512158 +0100
@@ -30,6 +30,7 @@
 #include <QXmlStreamWriter>
 #include <libambit.h>
 
+#include "deviceinfo.h"
 #include "logentry.h"
 
 class LogStore : public QObject
@@ -45,7 +46,7 @@
     };
 
     explicit LogStore(QObject *parent = 0);
-    LogEntry *store(ambit_device_info_t *deviceInfo, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry);
+    LogEntry *store(const DeviceInfo& deviceInfo, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry);
     LogEntry *store(LogEntry *entry);
     void storeMovescountId(QString device, QDateTime time, QString movescountId);
     bool logExists(QString device, ambit_log_header_t *logHeader);
@@ -59,7 +60,7 @@
 
 private:
     QString logEntryPath(QString device, QDateTime time);
-    LogEntry *storeInternal(QString serial, QDateTime dateTime, ambit_device_info_t *deviceInfo, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry, QString movescountId = "");
+    LogEntry *storeInternal(QString serial, QDateTime dateTime, const DeviceInfo& deviceInfo, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry, QString movescountId = "");
     LogEntry *readInternal(QString path);
 
     QString storagePath;
@@ -89,7 +90,7 @@
     class XMLWriter
     {
     public:
-        XMLWriter(ambit_device_info_t *deviceInfo, QDateTime time, QString movescountId, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry);
+        XMLWriter(const DeviceInfo& deviceInfo, QDateTime time, QString movescountId, ambit_personal_settings_t *personalSettings, ambit_log_entry_t *logEntry);
         bool write(QIODevice *device);
 
     private:
@@ -99,7 +100,7 @@
         bool writeLogSample(ambit_log_sample_t *sample);
         bool writePeriodicSample(ambit_log_sample_t *sample);
 
-        ambit_device_info_t *deviceInfo;
+        DeviceInfo deviceInfo;
         QDateTime time;
         QString movescountId;
         QXmlStreamWriter xml;
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/logview.cpp ../openambit.git/src/openambit/logview.cpp
--- ./src/openambit/logview.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/logview.cpp	2015-03-20 20:47:45.928512158 +0100
@@ -0,0 +1,54 @@
+#include "logview.h"
+
+LogView::LogView(QWidget *parent):
+    QTextBrowser(parent)
+{
+}
+
+void LogView::showLog(LogEntry *entry)
+{
+    QString log_html;
+
+    if (entry != NULL && entry->logEntry != NULL) {
+        log_html += "<h1>" + QString::fromUtf8(entry->logEntry->header.activity_name) + "</h1>";
+        if (entry->isUploaded()){
+            log_html += "<a href='http://www.movescount.com/moves/move" + entry->movescountId + "'>" + tr("see on movescount.com") + "</a>";
+        }
+        else {
+            log_html += tr("Not uploaded yet");
+        }
+        log_html += "<h2>" + tr("Details") + "</h2>";
+        log_html += "<h4>" + entry->time.toString() + "</h4>";
+        log_html += "<h4>" + tr("Duration: %1").arg(msecToHHMMSS(entry->logEntry->header.duration)) + "</h4>";
+        log_html += "<h4>" + tr("Distance: %1 m").arg(QString::number(entry->logEntry->header.distance)) + "</h4>";
+        log_html += "<h2>" + tr("Training values") + "</h2>";
+        log_html += "<h4>" + tr("Avg HR: %1 bpm").arg(QString::number(entry->logEntry->header.heartrate_avg)) + "</h4>";
+        log_html += "<h4>" + tr("Max HR: %1 bpm").arg(QString::number(entry->logEntry->header.heartrate_max)) + "</h4>";
+        log_html += "<h4>" + tr("Min HR: %1 bpm").arg(QString::number(entry->logEntry->header.heartrate_min)) + "</h4>";
+        log_html += "<h4>" + tr("PTE: %1").arg(QString::number(entry->logEntry->header.peak_training_effect/10.0)) + "</h4>";
+        log_html += "<h2>" + tr("Device") + "</h2>";
+        log_html += "<h4>" + tr("Name: %1").arg(entry->deviceInfo.name) + "</h4>";
+        log_html += "<h4>" + tr("Variant: %1").arg(entry->deviceInfo.model) + "</h4>";
+        log_html += "<h4>" + tr("Serial: %1").arg(entry->deviceInfo.serial) + "</h4>";
+
+        this->setHtml(log_html);
+    }
+}
+
+void LogView::hideLog()
+{
+    this->setHtml("");
+}
+
+QString LogView::msecToHHMMSS(quint32 msec)
+{
+    quint32 hours;
+    quint8 minutes;
+    quint8 seconds;
+
+    hours = msec / (3600000);
+    minutes = (msec - hours*3600000) / 60000;
+    seconds = (msec - hours*3600000 - minutes*60000) / 1000;
+
+    return QString("%1:%2:%3").arg(hours, 2, 10, QChar('0')).arg(minutes, 2, 10, QChar('0')).arg(seconds, 2, 10, QChar('0'));
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/logview.h ../openambit.git/src/openambit/logview.h
--- ./src/openambit/logview.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/logview.h	2015-03-20 20:47:45.928512158 +0100
@@ -0,0 +1,26 @@
+#ifndef LOGVIEW_H
+#define LOGVIEW_H
+
+#include <QTextBrowser>
+
+#include "logentry.h"
+
+class LogView : public QTextBrowser
+{
+    Q_OBJECT
+public:
+    explicit LogView(QWidget *parent = 0);
+
+    void showLog(LogEntry *entry);
+    void hideLog();
+
+signals:
+
+public slots:
+
+private:
+    QString msecToHHMMSS(quint32 msec);
+
+};
+
+#endif // LOGVIEW_H
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/main.cpp ../openambit.git/src/openambit/main.cpp
--- ./src/openambit/main.cpp	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/main.cpp	2015-03-20 20:47:45.928512158 +0100
@@ -19,13 +19,43 @@
  * Contributors:
  *
  */
+#include <unistd.h>
 #include "mainwindow.h"
 #include <QSettings>
+#include <QTranslator>
+#include <QLibraryInfo>
 
 #include "single_application.h"
+#include "signalhandler.h"
+
+static void initTranslations(void);
 
 int main(int argc, char *argv[])
 {
+    // Handle foreground arguments
+    // NOTE: It would be preferable to handle all arguments at the same place,
+    // but fork needs to be done before Qt initialize it seems
+    bool background = true;
+    for (int i=0; i<argc; i++) {
+        if (strcmp(argv[i], "-f") == 0) {
+            background = false;
+            break;
+        }
+    }
+    if (background) {
+#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) && !defined(__CYGWIN__)
+        // Windows
+#else
+        // Fork for background running
+        if ( fork() > 0 ) {
+            // Exit the parent process
+            return 0;
+        }
+        // Set the child to the new process group leader
+        setsid();
+#endif
+    }
+
     SingleApplication a(argc, argv, "openambit_single_application_lock");
 
     if (a.isRunning()) {
@@ -38,12 +68,50 @@
     QCoreApplication::setOrganizationName("Openambit");
     QCoreApplication::setApplicationName("Openambit");
 
+    // Handle forced localisation / translation
+    Q_FOREACH(QString argu, a.arguments()) {
+        const static QString localeParam = "-locale:";
+        if (argu.startsWith(localeParam)) {
+           QLocale::setDefault(QLocale(argu.mid(sizeof(localeParam))));
+           break;
+        }
+    }
+
+    // Initialize translations
+    initTranslations();
+
     MainWindow w;
 
     // Connect single application message bus
     QObject::connect(&a, SIGNAL(messageAvailable(QString)), &w, SLOT(singleApplicationMsgRecv(QString)));
 
+    // Handle signals
+    SignalHandler sigHandler;
+    QObject::connect(&sigHandler, SIGNAL(signalReceived(int)), &w, SLOT(closeRequested()));
+
     w.show();
     
     return a.exec();
 }
+
+static void initTranslations(void)
+{
+    QLocale locale;
+    QTranslator *qtTranslator = new QTranslator();
+    qtTranslator->load("qt_" + locale.name(), QLibraryInfo::location(QLibraryInfo::TranslationsPath));
+    if (qtTranslator->isEmpty()) {
+        delete qtTranslator;
+    }
+    else {
+        qApp->installTranslator(qtTranslator);
+    }
+
+    QTranslator *openambitTranslator = new QTranslator();
+    openambitTranslator->load(":/translations/openambit_" + locale.name());
+    if (openambitTranslator->isEmpty()) {
+        delete openambitTranslator;
+    }
+    else {
+        qApp->installTranslator(openambitTranslator);
+    }
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/mainwindow.cpp ../openambit.git/src/openambit/mainwindow.cpp
--- ./src/openambit/mainwindow.cpp	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/mainwindow.cpp	2015-03-20 20:47:45.932512160 +0100
@@ -91,8 +91,8 @@
     // Setup device manager
     deviceManager = new DeviceManager();
     deviceManager->moveToThread(&deviceWorkerThread);
-    qRegisterMetaType<ambit_device_info_t>("ambit_device_info_t");
-    connect(deviceManager, SIGNAL(deviceDetected(ambit_device_info_t,bool)), this, SLOT(deviceDetected(ambit_device_info_t,bool)), Qt::QueuedConnection);
+    qRegisterMetaType<DeviceInfo>("DeviceInfo");
+    connect(deviceManager, SIGNAL(deviceDetected(const DeviceInfo&)), this, SLOT(deviceDetected(const DeviceInfo&)), Qt::QueuedConnection);
     connect(deviceManager, SIGNAL(deviceRemoved()), this, SLOT(deviceRemoved()), Qt::QueuedConnection);
     connect(deviceManager, SIGNAL(deviceCharge(quint8)), this, SLOT(deviceCharge(quint8)), Qt::QueuedConnection);
     connect(deviceManager, SIGNAL(syncFinished(bool)), this, SLOT(syncFinished(bool)), Qt::QueuedConnection);
@@ -171,7 +171,13 @@
 
 void MainWindow::closeEvent(QCloseEvent *event)
 {
-    if (!sysTraySupported() || forceClose) {
+    //check if there is a settings for running in background
+    settings.beginGroup("generalSettings");
+    bool RunInBg;
+    RunInBg = settings.value("runningBackground", true).toBool();
+    settings.endGroup();
+
+    if (!sysTraySupported() || forceClose || !RunInBg) {
         trayIcon->setVisible(false);
         event->accept();
     }
@@ -230,12 +236,19 @@
     startSync();
 }
 
-void MainWindow::deviceDetected(ambit_device_info_t deviceInfo, bool supported)
+void MainWindow::deviceDetected(const DeviceInfo& deviceInfo)
 {
+    if (0 != deviceInfo.access_status) {
+        ui->labelNotSupported->setText(strerror(deviceInfo.access_status));
+    }
+    else {
+        // FIXME Should be gotten from the UI file, really
+        ui->labelNotSupported->setText(tr("Device not supported yet!"));
+    }
     ui->labelDeviceDetected->setText(deviceInfo.name);
     ui->labelSerial->setText(deviceInfo.serial);
     trayIcon->setIcon(QIcon(":/icon_connected"));
-    if (!supported) {
+    if (0 != deviceInfo.access_status || !deviceInfo.is_supported) {
         ui->labelNotSupportedIcon->setHidden(false);
         ui->labelNotSupported->setHidden(false);
         ui->labelMovescountAuthIcon->setHidden(true);
@@ -264,12 +277,12 @@
 
         movesCountSetup();
         if (movesCount != NULL) {
-            movesCount->setDevice(&deviceInfo);
+            movesCount->setDevice(deviceInfo);
             settings.beginGroup("movescountSettings");
             if (settings.value("checkNewVersions", true).toBool()) {
                 movesCount->checkLatestFirmwareVersion();
             }
-            if (settings.value("movescountEnable", true).toBool()) {
+            if (settings.value("movescountEnable", false).toBool()) {
                 movesCount->getDeviceSettings();
             }
             settings.endGroup();
@@ -366,7 +379,7 @@
 
 void MainWindow::newerFirmwareExists(QByteArray fw_version)
 {
-    ui->labelNewFirmware->setText(QString(tr("Newer firmware exists (%1.%2.%3)")).arg((int)fw_version[0]).arg((int)fw_version[1]).arg((int)(fw_version[2] | ((int)fw_version[3] << 8))));
+    ui->labelNewFirmware->setText(QString(tr("Newer firmware exists (%1.%2.%3)")).arg((int)fw_version[0]).arg((int)fw_version[1]).arg((int)(fw_version[2])));
     ui->labelNewFirmware->setHidden(false);
     ui->labelNewFirmwareIcon->setHidden(false);
 }
@@ -386,7 +399,7 @@
     if (current != NULL) {
         logEntry = logStore.read(current->data(Qt::UserRole).toString());
         if (logEntry != NULL) {
-            ui->logDetail->setHtml(logEntry->toHtml());
+            ui->logDetail->showLog(logEntry);
         }
 
         delete logEntry;
@@ -449,7 +462,7 @@
     syncOrbit = settings.value("syncOrbit", true).toBool();
     settings.endGroup();
     settings.beginGroup("movescountSettings");
-    syncMovescount = settings.value("movescountEnable", true).toBool();
+    syncMovescount = settings.value("movescountEnable", false).toBool();
     settings.endGroup();
 
     trayIcon->setIcon(QIcon(":/icon_syncing"));
@@ -466,11 +479,11 @@
     bool movescountEnable = false;
 
     settings.beginGroup("syncSettings");
-    syncOrbit = settings.value("syncOrbit").toBool();
+    syncOrbit = settings.value("syncOrbit", true).toBool();
     settings.endGroup();
 
     settings.beginGroup("movescountSettings");
-    movescountEnable = settings.value("movescountEnable").toBool();
+    movescountEnable = settings.value("movescountEnable", false).toBool();
     if (syncOrbit || movescountEnable) {
         if (movesCount == NULL) {
             movesCount = MovesCount::instance();
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/mainwindow.h ../openambit.git/src/openambit/mainwindow.h
--- ./src/openambit/mainwindow.h	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/mainwindow.h	2015-03-20 20:47:45.932512160 +0100
@@ -22,6 +22,7 @@
 #ifndef MAINWINDOW_H
 #define MAINWINDOW_H
 
+#include "deviceinfo.h"
 #include "devicemanager.h"
 #include "settingsdialog.h"
 #include "confirmbetadialog.h"
@@ -50,6 +51,7 @@
 
 public slots:
     void singleApplicationMsgRecv(QString msg);
+    void closeRequested();
 
 protected:
     void changeEvent(QEvent *event);
@@ -58,7 +60,6 @@
     void closeEvent(QCloseEvent *event);
 
 private slots:
-    void closeRequested();
     void showHideWindow();
     void trayIconClicked(QSystemTrayIcon::ActivationReason reason);
 
@@ -68,7 +69,7 @@
 
     void syncNowClicked();
 
-    void deviceDetected(ambit_device_info_t deviceInfo, bool supported);
+    void deviceDetected(const DeviceInfo& deviceInfo);
     void deviceRemoved();
     void deviceCharge(quint8 percent);
     void syncFinished(bool success);
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/mainwindow.ui ../openambit.git/src/openambit/mainwindow.ui
--- ./src/openambit/mainwindow.ui	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/mainwindow.ui	2014-11-05 21:53:14.000000000 +0100
@@ -30,7 +30,7 @@
      </widget>
     </item>
     <item>
-     <widget class="QTextBrowser" name="logDetail">
+     <widget class="LogView" name="logDetail">
       <property name="openExternalLinks">
        <bool>true</bool>
       </property>
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/movescount/CMakeLists.txt ../openambit.git/src/openambit/movescount/CMakeLists.txt
--- ./src/openambit/movescount/CMakeLists.txt	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/movescount/CMakeLists.txt	2014-11-05 21:53:14.000000000 +0100
@@ -2,9 +2,9 @@
   ${openambit_SRCS}
   ${CMAKE_CURRENT_SOURCE_DIR}/movescount.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountjson.cpp
+  ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogchecker.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogdirentry.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountxml.cpp
-  ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogchecker.cpp
   PARENT_SCOPE
 )
 
@@ -12,8 +12,10 @@
   ${openambit_MOCS}
   ${CMAKE_CURRENT_SOURCE_DIR}/movescount.h
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountjson.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogchecker.h
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogdirentry.h
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountxml.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogchecker.h
   PARENT_SCOPE
 )
+
+set (FILES_TO_TRANSLATE ${FILES_TO_TRANSLATE} ${openambit_SRCS} ${openambit_MOCS} PARENT_SCOPE)
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/movescount/movescount.cpp ../openambit.git/src/openambit/movescount/movescount.cpp
--- ./src/openambit/movescount/movescount.cpp	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/movescount/movescount.cpp	2015-03-20 20:47:45.932512160 +0100
@@ -102,9 +102,9 @@
     return retString;
 }
 
-void MovesCount::setDevice(ambit_device_info_t *device_info)
+void MovesCount::setDevice(const DeviceInfo& device_info)
 {
-    memcpy(&this->device_info, device_info, sizeof(ambit_device_info_t));
+    this->device_info = device_info;
 }
 
 bool MovesCount::isAuthorized()
@@ -209,7 +209,7 @@
 
 void MovesCount::firmwareReplyFinished()
 {
-    u_int8_t fw_version[4];
+    u_int8_t fw_version[3];
 
     if (firmwareCheckReply != NULL) {
         if (firmwareCheckReply->error() == QNetworkReply::NoError) {
@@ -217,8 +217,8 @@
             if (jsonParser.parseFirmwareVersionReply(data, fw_version) == 0) {
                 if (fw_version[0] > device_info.fw_version[0] ||
                     (fw_version[0] == device_info.fw_version[0] && (fw_version[1] > device_info.fw_version[1] ||
-                     (fw_version[1] == device_info.fw_version[1] && ((fw_version[2] | (fw_version[3] << 8)) > (device_info.fw_version[2] | (device_info.fw_version[3] << 8))))))) {
-                    emit newerFirmwareExists(QByteArray((const char*)fw_version, 4));
+                     (fw_version[1] == device_info.fw_version[1] && (fw_version[2] > device_info.fw_version[2]))))) {
+                    emit newerFirmwareExists(QByteArray((const char*)fw_version, 3));
                 }
             }
         }
@@ -274,7 +274,7 @@
 {
     QNetworkReply *reply;
 
-    reply = syncGET("/userdevices/" + QString("%1").arg(device_info.serial), "", true);
+    reply = syncGET("/userdevices/" + device_info.serial, "", true);
 
     if (checkReplyAuthorization(reply)) {
         QByteArray _data = reply->readAll();
@@ -315,7 +315,7 @@
                                       .arg(device_info.model)
                                       .arg(device_info.hw_version[0])
                                       .arg(device_info.hw_version[1])
-                                      .arg(device_info.hw_version[3] << 8 | device_info.hw_version[2]), "", false);
+                                      .arg(device_info.hw_version[2]), "", false);
         connect(firmwareCheckReply, SIGNAL(finished()), this, SLOT(firmwareReplyFinished()));
     }
 }
@@ -333,6 +333,11 @@
 
     jsonParser.generateLogData(logEntry, output);
 
+#ifdef QT_DEBUG
+    // Write json data to storage
+    writeJsonToStorage("log-" + logEntry->device + "-" + logEntry->time.toString("yyyy-MM-ddThh_mm_ss") + ".json", output);
+#endif
+
     reply = syncPOST("/moves/", "", output, true);
 
     if (reply->error() == QNetworkReply::NoError) {
@@ -440,3 +445,17 @@
 
     return reply;
 }
+
+#ifdef QT_DEBUG
+#include <QDir>
+void MovesCount::writeJsonToStorage(QString filename, QByteArray &data)
+{
+    QString storagePath = QString(getenv("HOME")) + "/.openambit/movescount";
+    if (QDir().mkpath(storagePath)) {
+        QFile logfile(storagePath + "/" + filename);
+        logfile.open(QIODevice::WriteOnly | QIODevice::Truncate);
+        logfile.write(data);
+        logfile.close();
+    }
+}
+#endif
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/movescount/movescount.h ../openambit.git/src/openambit/movescount/movescount.h
--- ./src/openambit/movescount/movescount.h	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/movescount/movescount.h	2015-03-20 20:47:45.932512160 +0100
@@ -31,6 +31,7 @@
 
 #include <libambit.h>
 
+#include "deviceinfo.h"
 #include "logentry.h"
 #include "logstore.h"
 #include "movescountjson.h"
@@ -49,7 +50,7 @@
     void setUsername(QString username);
     void setUserkey(QString userkey);
     QString generateUserkey();
-    void setDevice(ambit_device_info_t *device_info);
+    void setDevice(const DeviceInfo& device_info);
 
     bool isAuthorized();
     int getOrbitalData(u_int8_t **data);
@@ -95,6 +96,10 @@
     QNetworkReply *asyncPOST(QString path, QString additionalHeaders, QByteArray &postData, bool auth);
     QNetworkReply *syncPOST(QString path, QString additionalHeaders, QByteArray &postData, bool auth);
 
+#ifdef QT_DEBUG
+    void writeJsonToStorage(QString filename, QByteArray &data);
+#endif
+
     bool exiting;
     bool authorized;
 
@@ -104,7 +109,7 @@
     QString userkey;
     QString model;
     QString serial;
-    ambit_device_info_t device_info;
+    DeviceInfo device_info;
 
     QNetworkAccessManager *manager;
     QNetworkReply *firmwareCheckReply;
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/movescount/movescountjson.cpp ../openambit.git/src/openambit/movescount/movescountjson.cpp
--- ./src/openambit/movescount/movescountjson.cpp	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/movescount/movescountjson.cpp	2015-03-20 20:47:45.932512160 +0100
@@ -34,7 +34,7 @@
 {
 }
 
-int MovesCountJSON::parseFirmwareVersionReply(QByteArray &input, u_int8_t fw_version[4])
+int MovesCountJSON::parseFirmwareVersionReply(QByteArray &input, u_int8_t fw_version[3])
 {
     QJson::Parser parser;
     bool ok;
@@ -50,8 +50,7 @@
         if (rx.indexIn(result["LatestFirmwareVersion"].toString()) >= 0) {
             fw_version[0] = rx.cap(1).toInt();
             fw_version[1] = rx.cap(2).toInt();
-            fw_version[2] = rx.cap(3).toInt() & 0xff;
-            fw_version[3] = (rx.cap(3).toInt() >> 8) & 0xff;
+            fw_version[2] = rx.cap(3).toInt();
             return 0;
         }
     }
@@ -103,10 +102,24 @@
     return -1;
 }
 
+/**
+ * @brief MovesCountJSON::generateLogData
+ * @param logEntry
+ * @param output
+ * @return
+ * @note Fucked up facts about movescount:
+ *  - The periodic samples timestamps are truncated to 10th of milliseconds by movescount
+ *  - That would be fine, if it wasn't for the swimming logs where the periodic entries
+ *    are matched to the time of entries in the marksContent list (which has ms precision).
+ *  - Some of the entries that should match in marksContent are virtual created entries,
+ *    generated here. This can lead to time collisions.
+ *  - To compensate for the collisions, samples might need to be shifted in time,
+ *    hence the fuzz with dateTimeCompensate
+ */
 int MovesCountJSON::generateLogData(LogEntry *logEntry, QByteArray &output)
 {
     QJson::Serializer serializer;
-    bool ok;
+    bool ok, inPause = false;
     QVariantMap content;
     QVariantList IBIContent;
     QVariantList marksContent;
@@ -114,6 +127,8 @@
     QVariantList GPSSamplesContent;
     QByteArray uncompressedData, compressedData;
     ambit_log_sample_t *sample;
+    QDateTime prevMarksDateTime;
+    QDateTime prevPeriodicSamplesDateTime;
 
     QDateTime localBaseTime(QDate(logEntry->logEntry->header.date_time.year,
                                   logEntry->logEntry->header.date_time.month,
@@ -123,14 +138,15 @@
 
     // Loop through content
     QList<int> order = rearrangeSamples(logEntry);
-    foreach(int index, order) {
-        sample = &logEntry->logEntry->samples[index];
+    for (int i=0; i<order.length(); i++) {
+        sample = &logEntry->logEntry->samples[order[i]];
 
         switch(sample->type) {
         case ambit_log_sample_type_periodic:
         {
             QVariantMap tmpMap;
-            tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
+            prevPeriodicSamplesDateTime = dateTimeRound(dateTimeCompensate(dateTimeRound(localBaseTime.addMSecs(sample->time), 10), prevPeriodicSamplesDateTime, 0), 10);
+            tmpMap.insert("LocalTime", dateTimeString(prevPeriodicSamplesDateTime));
             writePeriodicSample(sample, tmpMap);
             periodicSamplesContent.append(tmpMap);
             break;
@@ -178,7 +194,13 @@
             case 0x00: /* autolap = 5 */
             {
                 QVariantMap tmpMap;
-                tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
+                if (sample->time > 0) {
+                    prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+                }
+                else {
+                    prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+                }
+                tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
                 tmpMap.insert("Type", 5);
                 marksContent.append(tmpMap);
                 break;
@@ -186,45 +208,162 @@
             case 0x01: /* manual = 0 */
             case 0x16: /* interval = 0 */
             {
-                QVariantMap tmpMap;
-                tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
-                tmpMap.insert("Type", 0);
-                marksContent.append(tmpMap);
+                // Try to remove strange manual lap events at end after pause/stop
+                // A lap during a pause doesn't make sense anyway?
+                if (!inPause) {
+                    QVariantMap tmpMap;
+                    if (sample->time > 0) {
+                        prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+                    }
+                    else {
+                        prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+                    }
+                    tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
+                    tmpMap.insert("Type", 0);
+                    marksContent.append(tmpMap);
+                }
                 break;
             }
             case 0x1f: /* start = 1 */
             {
                 QVariantMap tmpMap;
-                tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
                 if (sample->time > 0) {
+                    prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+                    tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
                     tmpMap.insert("Type", 1);
                 }
+                else {
+                    prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+                    tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
+                }
                 marksContent.append(tmpMap);
+
+                inPause = false;
                 break;
             }
             case 0x1e: /* pause = 2 */
             {
                 QVariantMap tmpMap;
-                tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
+                if (sample->time > 0) {
+                    prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+                }
+                else {
+                    prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+                }
+                tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
                 tmpMap.insert("Type", 2);
                 marksContent.append(tmpMap);
+
+                inPause = true;
                 break;
             }
             case 0x14: /* high interval = 3 */
             case 0x15: /* low interval = 3 */
             {
                 QVariantMap tmpMap;
-                tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
+                if (sample->time > 0) {
+                    prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+                }
+                else {
+                    prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+                }
+                tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
                 tmpMap.insert("Type", 3);
                 marksContent.append(tmpMap);
                 break;
             }
             };
             break;
+        case ambit_log_sample_type_swimming_turn:
+        {
+            int nextIndex;
+            ambit_log_sample_t *next_swimming_turn = NULL;
+            uint8_t style = 0;
+            QDateTime sampleDateTime;
+            if (sample->time > 0) {
+                sampleDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+            }
+            else {
+                sampleDateTime = localBaseTime.addMSecs(sample->time);
+            }
+
+            // Find next swimming turn, to check what marks to generate
+            for (nextIndex=i+1; nextIndex<order.length(); nextIndex++) {
+                next_swimming_turn = &logEntry->logEntry->samples[order[nextIndex]];
+                if (next_swimming_turn->type == ambit_log_sample_type_swimming_turn) {
+                    break;
+                }
+            }
+            if (nextIndex == order.length()) {
+                next_swimming_turn = NULL;
+            }
+            if (next_swimming_turn == NULL || sample->u.swimming_turn.style != next_swimming_turn->u.swimming_turn.style) {
+                QVariantMap tmpMap;
+                QVariantList calibration;
+                tmpMap.insert("LocalTime", dateTimeString(sampleDateTime));
+                tmpMap.insert("Type", 7);
+                tmpMap.insert("SwimmingStyle", sample->u.swimming_turn.style);
+                for (size_t k=0; k<sizeof(sample->u.swimming_turn.classification)/sizeof(sample->u.swimming_turn.classification[0]); k++) {
+                    calibration.append(sample->u.swimming_turn.classification[k]);
+                }
+                tmpMap.insert("SwimmingStyleCalibration", calibration);
+                marksContent.append(tmpMap);
+
+                if (next_swimming_turn != NULL) {
+                    style = next_swimming_turn->u.swimming_turn.style;
+                }
+                else {
+                    style = 0;
+                }
+
+                // Add some time to timestamp
+                sampleDateTime = sampleDateTime.addMSecs(5);
+            }
+            else {
+                style = sample->u.swimming_turn.style;
+            }
+
+            sampleDateTime = dateTimeRound(dateTimeCompensate(dateTimeCompensate(dateTimeRound(sampleDateTime, 10), prevMarksDateTime, 0), prevPeriodicSamplesDateTime, 0), 10);
+
+            QVariantMap tmpMap, attribMap;
+            QVariantList attributes;
+            tmpMap.insert("LocalTime", dateTimeString(sampleDateTime));
+            tmpMap.insert("Type", 5);
+            tmpMap.insert("SwimmingStyle", style);
+            attribMap.insert("Name", "type");
+            attribMap.insert("Value", "swimmingturn");
+            attributes.append(attribMap);
+            tmpMap.insert("Attributes", attributes);
+            marksContent.append(tmpMap);
+
+            QVariantMap periodicMap;
+            periodicMap.insert("Distance", sample->u.swimming_turn.distance / 100);
+            periodicMap.insert("LocalTime", dateTimeString(sampleDateTime));
+            periodicSamplesContent.append(periodicMap);
+
+            prevPeriodicSamplesDateTime = prevMarksDateTime = sampleDateTime;
+
+            break;
+        }
+        case ambit_log_sample_type_swimming_stroke:
+        {
+            QVariantMap tmpMap;
+            prevPeriodicSamplesDateTime = dateTimeRound(dateTimeCompensate(dateTimeRound(localBaseTime.addMSecs(sample->time), 10), prevPeriodicSamplesDateTime, 0), 10);
+            tmpMap.insert("LocalTime", dateTimeString(prevPeriodicSamplesDateTime));
+            tmpMap.insert("SwimmingStrokeType", 0);
+            periodicSamplesContent.append(tmpMap);
+            break;
+        }
         case ambit_log_sample_type_activity:
         {
             QVariantMap tmpMap;
-            tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
+            if (sample->time > 0) {
+                prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+            }
+            else {
+                prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+            }
+            tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
             tmpMap.insert("NextActivityID", sample->u.activity.activitytype);
             tmpMap.insert("Type", 8);
             marksContent.append(tmpMap);
@@ -246,8 +385,8 @@
     content.insert("AvgSpeed", (double)logEntry->logEntry->header.speed_avg/3600.0);
     content.insert("DescentAltitude", (double)logEntry->logEntry->header.descent);
     content.insert("DescentTime", (double)logEntry->logEntry->header.descent_time/1000.0);
-    content.insert("DeviceName", logEntry->deviceInfo->model);
-    content.insert("DeviceSerialNumber", logEntry->deviceInfo->serial);
+    content.insert("DeviceName", logEntry->deviceInfo.model);
+    content.insert("DeviceSerialNumber", logEntry->deviceInfo.serial);
     content.insert("Distance", logEntry->logEntry->header.distance);
     content.insert("Duration", (double)logEntry->logEntry->header.duration/1000.0);
     content.insert("Energy", logEntry->logEntry->header.energy_consumption);
@@ -434,7 +573,9 @@
             }
             break;
         case ambit_log_sample_periodic_type_sealevelpressure:
-            output.insert("SeaLevelPressure", (int)round((double)value->u.sealevelpressure/10.0));
+            if (value->u.sealevelpressure >= 8500 && value->u.sealevelpressure <= 11000) {
+                output.insert("SeaLevelPressure", (int)round((double)value->u.sealevelpressure/10.0));
+            }
             break;
         case ambit_log_sample_periodic_type_verticalspeed:
             output.insert("VerticalSpeed", (double)value->u.verticalspeed/100.0);
@@ -595,3 +736,21 @@
         return dateTime.toString("yyyy-MM-ddThh:mm:ss");
     }
 }
+
+QDateTime MovesCountJSON::dateTimeRound(QDateTime dateTime, int msecRoundFactor)
+{
+    if (msecRoundFactor != 1) {
+        return dateTime.addMSecs(qRound(1.0*dateTime.time().msec()/msecRoundFactor)*msecRoundFactor - dateTime.time().msec());
+    }
+    else {
+        return dateTime;
+    }
+}
+
+QDateTime MovesCountJSON::dateTimeCompensate(QDateTime dateTime, QDateTime prevDateTime, int minOffset)
+{
+    if (dateTime <= prevDateTime) {
+        return prevDateTime.addMSecs(minOffset);
+    }
+    return dateTime;
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/movescount/movescountjson.h ../openambit.git/src/openambit/movescount/movescountjson.h
--- ./src/openambit/movescount/movescountjson.h	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/movescount/movescountjson.h	2015-03-20 20:47:45.932512160 +0100
@@ -36,7 +36,7 @@
 public:
     explicit MovesCountJSON(QObject *parent = 0);
 
-    int parseFirmwareVersionReply(QByteArray &input, u_int8_t fw_version[4]);
+    int parseFirmwareVersionReply(QByteArray &input, u_int8_t fw_version[3]);
     int parseLogReply(QByteArray &input, QString &moveId);
     int parseLogDirReply(QByteArray &input, QList<MovesCountLogDirEntry> &entries);
 
@@ -52,6 +52,8 @@
     int compressData(QByteArray &content, QByteArray &output);
     QList<int> rearrangeSamples(LogEntry *logEntry);
     QString dateTimeString(QDateTime dateTime);
+    QDateTime dateTimeRound(QDateTime dateTime, int msecRoundFactor);
+    QDateTime dateTimeCompensate(QDateTime dateTime, QDateTime prevDateTime, int minOffset);
 };
 
 #endif // MOVESCOUNTJSON_H
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/movescount/movescountxml.cpp ../openambit.git/src/openambit/movescount/movescountxml.cpp
--- ./src/openambit/movescount/movescountxml.cpp	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/movescount/movescountxml.cpp	2015-03-20 20:47:45.932512160 +0100
@@ -241,7 +241,7 @@
         xml.writeTextElement("PeakTrainingEffect", QString::number((double)logEntry->logEntry->header.peak_training_effect/10.0, 'g', 16));
     }
     xml.writeTextElement("ActivityType", QString("%1").arg(logEntry->logEntry->header.activity_type));
-    xml.writeTextElement("Activity", QString::fromLatin1(logEntry->logEntry->header.activity_name));
+    xml.writeTextElement("Activity", QString::fromUtf8(logEntry->logEntry->header.activity_name));
     xml.writeStartElement("Temperature");
     xml.writeTextElement("Max", QString::number((double)logEntry->logEntry->header.temperature_max/10.0 + 273.15, 'g', 16));
     xml.writeTextElement("Min", QString::number((double)logEntry->logEntry->header.temperature_min/10.0 + 273.15, 'g', 16));
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/settingsdialog.cpp ../openambit.git/src/openambit/settingsdialog.cpp
--- ./src/openambit/settingsdialog.cpp	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/settingsdialog.cpp	2014-11-05 21:53:14.000000000 +0100
@@ -69,6 +69,7 @@
 {
     settings.beginGroup("generalSettings");
     ui->checkBoxSkipBetaCheck->setChecked(settings.value("skipBetaCheck", false).toBool());
+    ui->checkBoxRunningBackground->setChecked(settings.value("runningBackground", true).toBool());
     settings.endGroup();
 
     settings.beginGroup("syncSettings");
@@ -89,6 +90,7 @@
 {
     settings.beginGroup("generalSettings");
     settings.setValue("skipBetaCheck", ui->checkBoxSkipBetaCheck->isChecked());
+    settings.setValue("runningBackground", ui->checkBoxRunningBackground->isChecked());
     settings.endGroup();
 
     settings.beginGroup("syncSettings");
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/settingsdialog.ui ../openambit.git/src/openambit/settingsdialog.ui
--- ./src/openambit/settingsdialog.ui	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/src/openambit/settingsdialog.ui	2015-03-20 20:47:45.932512160 +0100
@@ -105,6 +105,13 @@
                 </property>
                </widget>
               </item>
+              <item row="1" column="0">
+               <widget class="QCheckBox" name="checkBoxRunningBackground">
+                <property name="text">
+                 <string>Continue running in background when Openambit main window is closed</string>
+                </property>
+               </widget>
+              </item>
              </layout>
             </widget>
            </item>
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/signalhandler.cpp ../openambit.git/src/openambit/signalhandler.cpp
--- ./src/openambit/signalhandler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/signalhandler.cpp	2015-03-20 20:47:45.932512160 +0100
@@ -0,0 +1,172 @@
+#include "signalhandler.h"
+#include "assert.h"
+
+#ifdef SIGNALHANDLER_POSIX
+#include <csignal>
+#include <sys/socket.h>
+#include <unistd.h>
+#endif
+#ifdef SIGNALHANDLER_WIN32
+#include <windows.h>
+#endif //SIGNALHANDLER_WIN32
+
+#ifdef SIGNALHANDLER_POSIX
+int SignalHandler::POSIX_fd[2];
+#endif //SIGNALHANDLER_POSIX
+
+// Singleton construction
+SignalHandler* sig_handler(NULL);
+
+SignalHandler::SignalHandler(QObject *parent, int mask) :
+    QObject(parent), _mask(mask)
+{
+    assert(sig_handler == NULL);
+    sig_handler = this;
+
+#ifdef SIGNALHANDLER_WIN32
+    SetConsoleCtrlHandler(WIN32_handleFunc, TRUE);
+#endif
+#ifdef SIGNALHANDLER_POSIX
+    // Setup unix singal handling
+    if (socketpair(AF_LOCAL, SOCK_STREAM, 0, POSIX_fd)) {
+        qFatal("Failed to create POSIX Signal handling sockets");
+    }
+    POSIX_ntf = new QSocketNotifier(POSIX_fd[1], QSocketNotifier::Read, this);
+    connect(POSIX_ntf, SIGNAL(activated(int)), this, SLOT(POSIX_socketRecv()));
+#endif //SIGNALHANDLER_POSIX
+
+    for (int i=0; i<signalsCount; i++) {
+        int sigval = 1 << i;
+        if (_mask & sigval) {
+#ifdef SIGNALHANDLER_WIN32
+            sig_registry.insert(sigval);
+#endif
+#ifdef SIGNALHANDLER_POSIX
+            int sig = POSIX_logicalToPhysical(sigval);
+            assert(signal(sig, SignalHandler::POSIX_handleFunc) != SIG_ERR);
+#endif //SIGNALHANDLER_POSIX
+        }
+    }
+}
+
+SignalHandler::~SignalHandler()
+{
+#ifdef SIGNALHANDLER_WIN32
+    SetConsoleCtrlHandler(WIN32_handleFunc, FALSE);
+#endif
+#ifdef SIGNALHANDLER_POSIX
+    for (int i=0;i<signalsCount;i++) {
+        int sigval = 1 << i;
+        if (_mask & sigval) {
+            signal(POSIX_logicalToPhysical(sigval), SIG_DFL);
+        }
+    }
+#endif //SIGNALHANDLER_POSIX
+}
+
+bool SignalHandler::handleSignal(int signal)
+{
+    emit this->signalReceived(signal);
+
+    return true;
+}
+
+#ifdef SIGNALHANDLER_WIN32
+DWORD SignalHandler::WIN32_logicalToPhysical(int signal)
+{
+    switch (signal) {
+        case SignalHandler::SIG_INT: return CTRL_C_EVENT;
+        case SignalHandler::SIG_TERM: return CTRL_BREAK_EVENT;
+        case SignalHandler::SIG_CLOSE: return CTRL_CLOSE_EVENT;
+        default:
+            return ~(unsigned int)0; // SIG_ERR = -1
+    }
+}
+#endif
+#ifdef SIGNALHANDLER_POSIX
+int SignalHandler::POSIX_logicalToPhysical(int signal)
+{
+    switch (signal) {
+        case SignalHandler::SIG_INT: return SIGINT;
+        case SignalHandler::SIG_TERM: return SIGTERM;
+        // In case the client asks for a SIG_CLOSE handler, accept and
+        // bind it to a SIGTERM. Anyway the signal will never be raised
+        case SignalHandler::SIG_CLOSE: return SIGTERM;
+        case SignalHandler::SIG_RELOAD: return SIGHUP;
+        default:
+            return -1; // SIG_ERR = -1
+    }
+}
+#endif //SIGNALHANDLER_POSIX
+
+
+#ifdef SIGNALHANDLER_WIN32
+int SignalHandler::WIN32_physicalToLogical(DWORD signal)
+{
+    switch (signal) {
+        case CTRL_C_EVENT: return SignalHandler::SIG_INT;
+        case CTRL_BREAK_EVENT: return SignalHandler::SIG_TERM;
+        case CTRL_CLOSE_EVENT: return SignalHandler::SIG_CLOSE;
+        default:
+            return SignalHandler::SIG_UNHANDLED;
+    }
+}
+#endif
+#ifdef SIGNALHANDLER_POSIX
+int SignalHandler::POSIX_physicalToLogical(int signal)
+{
+    switch (signal) {
+        case SIGINT: return SignalHandler::SIG_INT;
+        case SIGTERM: return SignalHandler::SIG_TERM;
+        case SIGHUP: return SignalHandler::SIG_RELOAD;
+        default:
+            return SignalHandler::SIG_UNHANDLED;
+    }
+}
+#endif //SIGNALHANDLER_POSIX
+
+
+
+#ifdef SIGNALHANDLER_WIN32
+BOOL WINAPI SignalHandler::WIN32_handleFunc(DWORD signal)
+{
+    if (sig_handler) {
+        int signo = WIN32_physicalToLogical(signal);
+        // The std::set is thread-safe in const reading access and we never
+        // write to it after the program has started so we don't need to
+        // protect this search by a mutex
+        std::set<int>::const_iterator found = sig_registry.find(signo);
+        if (signo != -1 && found != g_registry.end()) {
+            return sig_handler->handleSignal(signo) ? TRUE : FALSE;
+        }
+        else {
+            return FALSE;
+        }
+    }
+    else {
+        return FALSE;
+    }
+}
+#endif
+#ifdef SIGNALHANDLER_POSIX
+void SignalHandler::POSIX_handleFunc(int signal)
+{
+    if (sig_handler) {
+        int signo = POSIX_physicalToLogical(signal);
+        write(POSIX_fd[0], &signo, sizeof(signo));
+    }
+}
+#endif //SIGNALHANDLER_POSIX
+
+#ifdef SIGNALHANDLER_POSIX
+void SignalHandler::POSIX_socketRecv()
+{
+    POSIX_ntf->setEnabled(false);
+
+    int signo;
+    read(POSIX_fd[1], &signo, sizeof(signo));
+    handleSignal(signo);
+
+    POSIX_ntf->setEnabled(true);
+}
+#endif //SIGNALHANDLER_POSIX
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/signalhandler.h ../openambit.git/src/openambit/signalhandler.h
--- ./src/openambit/signalhandler.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/signalhandler.h	2015-03-20 20:47:45.932512160 +0100
@@ -0,0 +1,63 @@
+#ifndef SIGNALHANDLER_H
+#define SIGNALHANDLER_H
+
+#include <QObject>
+#include <QSocketNotifier>
+
+#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) && !defined(__CYGWIN__)
+#define SIGNALHANDLER_WIN32
+#else
+#define SIGNALHANDLER_POSIX
+#endif
+
+class SignalHandler : public QObject
+{
+    Q_OBJECT
+public:
+    explicit SignalHandler(QObject *parent = 0, int mask = DEFAULT_SIGNALS);
+    virtual ~SignalHandler();
+
+    enum SIGNALS
+    {
+        SIG_UNHANDLED   = 0,    // Physical signal not supported by this class
+        SIG_NOOP        = 1,    // The application is requested to do a no-op (only a target that platform-specific signals map to when they can't be raised anyway)
+        SIG_INT         = 2,    // Control+C (should terminate but consider that it's a normal way to do so; can delay a bit)
+        SIG_TERM        = 4,    // Control+Break (should terminate now without regarding the consquences)
+        SIG_CLOSE       = 8,    // Container window closed (should perform normal termination, like Ctrl^C) [Windows only; on Linux it maps to SIG_TERM]
+        SIG_RELOAD      = 16,   // Reload the configuration [Linux only, physical signal is SIGHUP; on Windows it maps to SIG_NOOP]
+        DEFAULT_SIGNALS = SIG_INT | SIG_TERM | SIG_CLOSE,
+    };
+    static const int signalsCount = 6;
+
+    bool handleSignal(int signal);
+
+#ifdef SIGNALHANDLER_WIN32
+    static BOOL WINAPI WIN32_handleFunc(DWORD);
+    static int WIN32_physicalToLogical(DWORD);
+    static DWORD WIN32_logicalToPhysical(int);
+    static std::set<int> sig_registry;
+#endif
+#ifdef SIGNALHANDLER_POSIX
+    static void POSIX_handleFunc(int);
+    static int POSIX_physicalToLogical(int);
+    static int POSIX_logicalToPhysical(int);
+#endif //SIGNALHANDLER_POSIX
+
+signals:
+    void signalReceived(int signal);
+
+public slots:
+#ifdef SIGNALHANDLER_POSIX
+    void POSIX_socketRecv();
+#endif
+
+private:
+    int _mask;
+
+#ifdef SIGNALHANDLER_POSIX
+    static int POSIX_fd[2];
+    QSocketNotifier *POSIX_ntf;
+#endif
+};
+
+#endif // SIGNALHANDLER_H
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/translations/openambit_de.ts ../openambit.git/src/openambit/translations/openambit_de.ts
--- ./src/openambit/translations/openambit_de.ts	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/translations/openambit_de.ts	2015-03-20 20:47:45.932512160 +0100
@@ -0,0 +1,328 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE TS>
+<TS version="2.0" language="de_DE" sourcelanguage="en">
+<context>
+    <name>ConfirmBetaDialog</name>
+    <message>
+        <source>Openambit: Disclaimer</source>
+        <translation>Openambit: Disclaimer</translation>
+    </message>
+    <message>
+        <source>Don&apos;t ask me again, I really want to use Openambit</source>
+        <translation>Nicht nochmal fragen, ich mchte Openambit wirklich benutzen</translation>
+    </message>
+    <message>
+        <source>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</source>
+        <translation>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;FRHE BETA-SOFTWARE: &lt;a href=&quot;http://de.wikipedia.org/wiki/Hic_sunt_dracones&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;hic sunt dracones&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Diese Software ist noch in einem frhen Beta-Stadium. Sie ldt mglicherweise ungltige Log-Dateien zu Movescount hoch, die nicht berschrieben werden knnen oder andere unerwartete Effekte hervorrufen.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit ist freie Software: Du kannst sie weitergeben und verndern &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;entsprechend den Bedingungen der GNU General Public License, verffentlicht von der Free Software Foundation, in Version 3 oder (nach deiner Wahl) einer beliebigen spteren Version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Dieses Programm wird in der Hoffnung weitergegeben, ntzlich zu sein, aber OHNE JEGLICHE GEWHRLEISTUNG, insbesondere OHNE MNGELHAFTUNG oder die ZUSICHERUNG, dass es FR EINEN BESTIMMTEN ZWECK GEEIGNET ist. Fr weitere Details wird auf die GNU General Public License verwiesen.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Bitte benutze dieses Programm auf &lt;span style=&quot; text-decoration: underline;&quot;&gt;eigene Gefahr&lt;/span&gt; und nur, wenn du die damit verbundenen Risiken verstanden hast.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Wenn du dich entschlossen hast, Openambit zu benutzen, dann &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;melde bitte Fehler&lt;/span&gt;&lt;/a&gt;, damit wir das Programm weiter verbessern knnen.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Danke &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</translation>
+    </message>
+</context>
+<context>
+    <name>DeviceManager</name>
+    <message>
+        <source>Reading personal settings</source>
+        <translation>Lese persnliche Einstellungen</translation>
+    </message>
+    <message>
+        <source>Setting date/time</source>
+        <translation>Setze Datum und Zeit</translation>
+    </message>
+    <message>
+        <source>Reading log files</source>
+        <translation>Lese Log-Dateien</translation>
+    </message>
+    <message>
+        <source>Fetching orbital data</source>
+        <translation>Hole GPS-Bahndaten</translation>
+    </message>
+    <message>
+        <source>Writing orbital data</source>
+        <translation>Schreibe GPS-Bahndaten</translation>
+    </message>
+    <message>
+        <source>Failed to get orbital data</source>
+        <translation>Fehler beim Holen der GPS-Bahndaten</translation>
+    </message>
+    <message>
+        <source>Downloading log %1 of %2</source>
+        <translation>Lade Log %1 von %2 herunter</translation>
+    </message>
+</context>
+<context>
+    <name>LogView</name>
+    <message>
+        <source>see on movescount.com</source>
+        <translation>auf Movescount.com ansehen</translation>
+    </message>
+    <message>
+        <source>Not uploaded yet</source>
+        <translation>Noch nicht hochgeladen</translation>
+    </message>
+    <message>
+        <source>Details</source>
+        <translation>Details</translation>
+    </message>
+    <message>
+        <source>Duration: %1</source>
+        <translation>Dauer: %1</translation>
+    </message>
+    <message>
+        <source>Distance: %1 m</source>
+        <translation>Distanz: %1 m</translation>
+    </message>
+    <message>
+        <source>Training values</source>
+        <translation>Trainingswerte</translation>
+    </message>
+    <message>
+        <source>Avg HR: %1 bpm</source>
+        <translation>Durchschnittspuls: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Max HR: %1 bpm</source>
+        <translation>Maximalpuls: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Min HR: %1 bpm</source>
+        <translation>Minimalpuls: %1 bpm</translation>
+    </message>
+    <message>
+        <source>PTE: %1</source>
+        <translation>PTE: %1</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Gert</translation>
+    </message>
+    <message>
+        <source>Name: %1</source>
+        <translation>Name: %1</translation>
+    </message>
+    <message>
+        <source>Variant: %1</source>
+        <translation>Variante: %1</translation>
+    </message>
+    <message>
+        <source>Serial: %1</source>
+        <translation>Seriennummer: %1</translation>
+    </message>
+</context>
+<context>
+    <name>MainWindow</name>
+    <message>
+        <source>Openambit</source>
+        <translation>Openambit</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Gert</translation>
+    </message>
+    <message>
+        <source>No device detected</source>
+        <translation>Kein Gert gefunden</translation>
+    </message>
+    <message>
+        <source>Device not supported yet!</source>
+        <translation>Gert noch nicht untersttzt!</translation>
+    </message>
+    <message>
+        <source>Auth on &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</source>
+        <translation>Authorisieren bei &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</translation>
+    </message>
+    <message>
+        <source>Charge:</source>
+        <translation>Ladestand:</translation>
+    </message>
+    <message>
+        <source>Resync all</source>
+        <translation>Alle erneut synchronisieren</translation>
+    </message>
+    <message>
+        <source>Sync now</source>
+        <translation>Jetzt synchronisieren</translation>
+    </message>
+    <message>
+        <source>&amp;File</source>
+        <translation>&amp;Datei</translation>
+    </message>
+    <message>
+        <source>&amp;Help</source>
+        <translation>&amp;Hilfe</translation>
+    </message>
+    <message>
+        <source>About Openambit...</source>
+        <translation>ber Openambit...</translation>
+    </message>
+    <message>
+        <source>E&amp;xit</source>
+        <translation>B&amp;enden</translation>
+    </message>
+    <message>
+        <source>&amp;Settings</source>
+        <translation>&amp;Einstellungen</translation>
+    </message>
+    <message>
+        <source>Minimize</source>
+        <translation>Minimieren</translation>
+    </message>
+    <message>
+        <source>Restore</source>
+        <translation>Wiederherstellen</translation>
+    </message>
+    <message>
+        <source>About %1</source>
+        <translation>ber %1</translation>
+    </message>
+    <message>
+        <source>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Using Qt %3</source>
+        <translation>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Unter Verwendung von Qt %3</translation>
+    </message>
+    <message>
+        <source>Syncronization complete</source>
+        <translation>Synchronisierung abgeschlossen</translation>
+    </message>
+    <message>
+        <source>Syncronisation finished</source>
+        <translation>Synchronisierung beendet</translation>
+    </message>
+    <message>
+        <source>Syncronization failed</source>
+        <translation>Synchronisierung fehlgeschlagen</translation>
+    </message>
+    <message>
+        <source>Syncronisation failed</source>
+        <translation>Synchronisierung fehlgeschlagen</translation>
+    </message>
+    <message>
+        <source>Newer firmware exists (%1.%2.%3)</source>
+        <translation>Neuere Firmware verfgbar (%1.%2.%3)</translation>
+    </message>
+    <message>
+        <source>Context menu</source>
+        <translation>Kontextmen</translation>
+    </message>
+    <message>
+        <source>Write Movescount file</source>
+        <translation>Schreibe Movescount-Datei</translation>
+    </message>
+    <message>
+        <source>Syncronisation started</source>
+        <translation>Synchronisierung gestartet</translation>
+    </message>
+</context>
+<context>
+    <name>QObject</name>
+    <message>
+        <source>The file is not an openambit version 1.0 file.</source>
+        <translation>Die Datei hat nicht die Openambit-Version 1.0.</translation>
+    </message>
+    <message>
+        <source>%1
+Line %2, column %3</source>
+        <translation>%1
+Zeile %2, Spalte %3</translation>
+    </message>
+</context>
+<context>
+    <name>SettingsDialog</name>
+    <message>
+        <source>Dialog</source>
+        <translation>Dialog</translation>
+    </message>
+    <message>
+        <source>General</source>
+        <translation>Allgemein</translation>
+    </message>
+    <message>
+        <source>Device sync</source>
+        <translation>Gertesynchronisierung</translation>
+    </message>
+    <message>
+        <source>Movescount</source>
+        <translation>Movescount</translation>
+    </message>
+    <message>
+        <source>General settings</source>
+        <translation>Allgemeine Einstellungen</translation>
+    </message>
+    <message>
+        <source>Skip Beta check at startup</source>
+        <translation>Beta-Warnung beim Start nicht anzeigen </translation>
+    </message>
+    <message>
+        <source>Continue running in background when Openambit main window is closed</source>
+        <translation>Im Hintergrund weiter ausfhren wenn das Hauptfenster geschlossen wird</translation>
+    </message>
+    <message>
+        <source>Device syncronisation settings</source>
+        <translation>Einstellungen fr die Gertesynchronisierung</translation>
+    </message>
+    <message>
+        <source>Sync time from computer</source>
+        <translation>Zeit vom Computer synchronisieren</translation>
+    </message>
+    <message>
+        <source>Sync orbital data (from Movescount)</source>
+        <translation>GPS-Satellitenbahndaten (von Movescount) synchronisieren</translation>
+    </message>
+    <message>
+        <source>Start sync automatically when device connected</source>
+        <translation>Synchronisierung automatisch starten, wenn ein Gert angeschlossen ist</translation>
+    </message>
+    <message>
+        <source>Movescount connectivity</source>
+        <translation>Verbindung zu Movescount</translation>
+    </message>
+    <message>
+        <source>Check Movescount for new versions</source>
+        <translation>Auf Movescount nach neuen Versionen suchen</translation>
+    </message>
+    <message>
+        <source>Generate debug files (XMLs stored in ~/.openambit/movescount)</source>
+        <translation>Debug-Dateien erzeugen (XML-Dateien in ~/.openambit/movescount)</translation>
+    </message>
+    <message>
+        <source>Sync logs with Movescount</source>
+        <translation>Logs zu Movescount synchronisieren</translation>
+    </message>
+    <message>
+        <source>Email (Movescount account)</source>
+        <translation>Email des Movescount-Accounts</translation>
+    </message>
+</context>
+</TS>
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/translations/openambit_fr.ts ../openambit.git/src/openambit/translations/openambit_fr.ts
--- ./src/openambit/translations/openambit_fr.ts	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/translations/openambit_fr.ts	2015-03-20 20:47:45.932512160 +0100
@@ -0,0 +1,319 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE TS>
+<TS version="2.0" language="sv_SE">
+<context>
+    <name>ConfirmBetaDialog</name>
+    <message>
+        <source>Openambit: Disclaimer</source>
+        <translation>Openambit: Avertissement</translation>
+    </message>
+    <message>
+        <source>Don&apos;t ask me again, I really want to use Openambit</source>
+        <translation>Ne plus me poser cette question.</translation>
+    </message>
+    <message>
+        <source>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>DeviceManager</name>
+    <message>
+        <source>Reading personal settings</source>
+        <translation>Lser personliga instllningar</translation>
+    </message>
+    <message>
+        <source>Setting date/time</source>
+        <translation>Skriver datum &amp; tid</translation>
+    </message>
+    <message>
+        <source>Reading log files</source>
+        <translation>Lser logg-filer</translation>
+    </message>
+    <message>
+        <source>Fetching orbital data</source>
+        <translation>Hmtar GPS-data</translation>
+    </message>
+    <message>
+        <source>Writing orbital data</source>
+        <translation>Skriver GPS-data</translation>
+    </message>
+    <message>
+        <source>Failed to get orbital data</source>
+        <translation>GPS-data gick ej att hmta</translation>
+    </message>
+    <message>
+        <source>Downloading log %1 of %2</source>
+        <translation>Lser logg %1 av %2</translation>
+    </message>
+</context>
+<context>
+    <name>LogEntry</name>
+    <message>
+        <source>Device</source>
+        <translation type="obsolete">Priphrique</translation>
+    </message>
+</context>
+<context>
+    <name>LogView</name>
+    <message>
+        <source>see on movescount.com</source>
+        <translation>voir sur movescount.com</translation>
+    </message>
+    <message>
+        <source>Not uploaded yet</source>
+        <translation>Pas encore envoy</translation>
+    </message>
+    <message>
+        <source>Details</source>
+        <translation>Dtails</translation>
+    </message>
+    <message>
+        <source>Duration: %1</source>
+        <translation>Dure: %1</translation>
+    </message>
+    <message>
+        <source>Distance: %1 m</source>
+        <translation>Distance : %1 m</translation>
+    </message>
+    <message>
+        <source>Training values</source>
+        <translation>Paramtres physiologiques</translation>
+    </message>
+    <message>
+        <source>Avg HR: %1 bpm</source>
+        <translation>Frq. cardiaque moy. : %1 puls/mn</translation>
+    </message>
+    <message>
+        <source>Max HR: %1 bpm</source>
+        <translation>Frq. cardiaque maxi : %1 puls/mn
+</translation>
+    </message>
+    <message>
+        <source>Min HR: %1 bpm</source>
+        <translation>Frq. cardiaque mini : %1 puls/mn
+</translation>
+    </message>
+    <message>
+        <source>PTE: %1</source>
+        <translation>PTE : %1</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Priphrique</translation>
+    </message>
+    <message>
+        <source>Name: %1</source>
+        <translation>Nom: %1</translation>
+    </message>
+    <message>
+        <source>Variant: %1</source>
+        <translation>Variante: %1</translation>
+    </message>
+    <message>
+        <source>Serial: %1</source>
+        <translation>N/S: %1</translation>
+    </message>
+</context>
+<context>
+    <name>MainWindow</name>
+    <message>
+        <source>Sync now</source>
+        <translation>Synchroniser maintenant</translation>
+    </message>
+    <message>
+        <source>Minimize</source>
+        <translation>Minimiser</translation>
+    </message>
+    <message>
+        <source>Restore</source>
+        <translation>Restaurer</translation>
+    </message>
+    <message>
+        <source>About %1</source>
+        <translation> propos d&apos;%1</translation>
+    </message>
+    <message>
+        <source>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Using Qt %3</source>
+        <translation>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Qt %3</translation>
+    </message>
+    <message>
+        <source>No device detected</source>
+        <translation>Pas de priphrique dtect</translation>
+    </message>
+    <message>
+        <source>Syncronization complete</source>
+        <translation>Synchronisation complte</translation>
+    </message>
+    <message>
+        <source>Syncronisation finished</source>
+        <translation>Synchronisation termine</translation>
+    </message>
+    <message>
+        <source>Syncronization failed</source>
+        <translation>chec de synchronisation</translation>
+    </message>
+    <message>
+        <source>Syncronisation failed</source>
+        <translation>chec de synchronisation</translation>
+    </message>
+    <message>
+        <source>Newer firmware exists (%1.%2.%3)</source>
+        <translation>Nouveau micrologiciel (firmware) disponible (%1.%2.%3)</translation>
+    </message>
+    <message>
+        <source>Context menu</source>
+        <translation>Menu contextuel</translation>
+    </message>
+    <message>
+        <source>Write Movescount file</source>
+        <translation>crire le fichier Movescount</translation>
+    </message>
+    <message>
+        <source>Syncronisation started</source>
+        <translation>Dbut de synchronisation</translation>
+    </message>
+    <message>
+        <source>Openambit</source>
+        <translation>Openambit</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Priphrique</translation>
+    </message>
+    <message>
+        <source>Device not supported yet!</source>
+        <translation>Priphrique non gr</translation>
+    </message>
+    <message>
+        <source>Auth on &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</source>
+        <translation>S&apos;authentifier sur &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</translation>
+    </message>
+    <message>
+        <source>Charge:</source>
+        <translation>Charge:</translation>
+    </message>
+    <message>
+        <source>Resync all</source>
+        <translation>Tout resynchroniser</translation>
+    </message>
+    <message>
+        <source>&amp;File</source>
+        <translation>&amp;Fichier</translation>
+    </message>
+    <message>
+        <source>&amp;Help</source>
+        <translation>&amp;Aide</translation>
+    </message>
+    <message>
+        <source>About Openambit...</source>
+        <translation> propos d&apos;Openambit...</translation>
+    </message>
+    <message>
+        <source>E&amp;xit</source>
+        <translation>&amp;Quitter</translation>
+    </message>
+    <message>
+        <source>&amp;Settings</source>
+        <translation>&amp;Rglages</translation>
+    </message>
+</context>
+<context>
+    <name>QObject</name>
+    <message>
+        <source>The file is not an openambit version 1.0 file.</source>
+        <translation>Ce fichier n&apos;est pas un fichier Openambit version 1.0</translation>
+    </message>
+    <message>
+        <source>%1
+Line %2, column %3</source>
+        <translation>%1
+Ligne %2, colonne %3</translation>
+    </message>
+</context>
+<context>
+    <name>SettingsDialog</name>
+    <message>
+        <source>Dialog</source>
+        <translation>Dialogue</translation>
+    </message>
+    <message>
+        <source>General</source>
+        <translation>Gnral</translation>
+    </message>
+    <message>
+        <source>Device sync</source>
+        <translation>Synchronisation du priphrique</translation>
+    </message>
+    <message>
+        <source>Movescount</source>
+        <translation>Movescount</translation>
+    </message>
+    <message>
+        <source>General settings</source>
+        <translation>Rglages gnraux</translation>
+    </message>
+    <message>
+        <source>Skip Beta check at startup</source>
+        <translation>Ne pas signaler les versions beta au dmarrage</translation>
+    </message>
+    <message>
+        <source>Continue running in background when Openambit main window is closed</source>
+        <translation>Poursuivre le fonctionnement en tche de fond lorsque la fentre principale d&apos;Openambit est ferme</translation>
+    </message>
+    <message>
+        <source>Device syncronisation settings</source>
+        <translation>Rglages de synchronisation du priphrique</translation>
+    </message>
+    <message>
+        <source>Sync time from computer</source>
+        <translation>Synchroniser l&apos;heure avec l&apos;ordinateur</translation>
+    </message>
+    <message>
+        <source>Sync orbital data (from Movescount)</source>
+        <translation>Synchroniser les donnes orbitales des satellites (depuis Movescount)</translation>
+    </message>
+    <message>
+        <source>Start sync automatically when device connected</source>
+        <translation>Dmarrer automatiquement la synchronisation  la connexion du priphrique</translation>
+    </message>
+    <message>
+        <source>Movescount connectivity</source>
+        <translation>Connexion  Movescount</translation>
+    </message>
+    <message>
+        <source>Check Movescount for new versions</source>
+        <translation>Vrifier les nouvelles versions sur Movescount</translation>
+    </message>
+    <message>
+        <source>Generate debug files (XMLs stored in ~/.openambit/movescount)</source>
+        <translation>Crer des fichiers de dbogage (fichiers XML dans ~/.openambit/movescount)</translation>
+    </message>
+    <message>
+        <source>Sync logs with Movescount</source>
+        <translation>Synchroniser les informations avec Movescount</translation>
+    </message>
+    <message>
+        <source>Email (Movescount account)</source>
+        <translation>Adresse lectronique (du compte Movescount)</translation>
+    </message>
+</context>
+</TS>
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/translations/openambit_it.ts ../openambit.git/src/openambit/translations/openambit_it.ts
--- ./src/openambit/translations/openambit_it.ts	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/translations/openambit_it.ts	2015-03-20 20:47:45.932512160 +0100
@@ -0,0 +1,328 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE TS>
+<TS version="2.0" language="it" sourcelanguage="en">
+<context>
+    <name>ConfirmBetaDialog</name>
+    <message>
+        <source>Openambit: Disclaimer</source>
+        <translation>Openambit: Attenzione</translation>
+    </message>
+    <message>
+        <source>Don&apos;t ask me again, I really want to use Openambit</source>
+        <translation>Non mi chiedere piu, voglio veramente uasre Openambit</translation>
+    </message>
+    <message>
+        <source>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</source>
+        <translation>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;SOFTWARE BETA : &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;Si salvi chi pu&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Questo sogtware  molto giovane e potrebbe caricare dei log sbagliati, incancellabili, ecc su movescount&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Perfavore usa questo software &lt;span style=&quot; text-decoration: underline;&quot;&gt;a tuo&lt;/span&gt; rischio e pericolo solo se capisci i rischi implicati.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Se decidi di usare Openambit, perfavore &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;segnalaci eventuali bachi&lt;/span&gt;&lt;/a&gt; cosi da poterli riparare.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Grazie &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</translation>
+    </message>
+</context>
+<context>
+    <name>DeviceManager</name>
+    <message>
+        <source>Reading personal settings</source>
+        <translation>Leggendo impostazioni</translation>
+    </message>
+    <message>
+        <source>Setting date/time</source>
+        <translation>Impostando data/ora</translation>
+    </message>
+    <message>
+        <source>Reading log files</source>
+        <translation>Leggendo file di log</translation>
+    </message>
+    <message>
+        <source>Fetching orbital data</source>
+        <translation>Ottenendo dati orbitali</translation>
+    </message>
+    <message>
+        <source>Writing orbital data</source>
+        <translation>Scrivendo dati orbitali</translation>
+    </message>
+    <message>
+        <source>Failed to get orbital data</source>
+        <translation>Errore ottenendo dati orbitali</translation>
+    </message>
+    <message>
+        <source>Downloading log %1 of %2</source>
+        <translation>Sacricando log %1 di %2</translation>
+    </message>
+</context>
+<context>
+    <name>LogView</name>
+    <message>
+        <source>see on movescount.com</source>
+        <translation>Vedi su movescount.com</translation>
+    </message>
+    <message>
+        <source>Not uploaded yet</source>
+        <translation>Non ancora caricata</translation>
+    </message>
+    <message>
+        <source>Details</source>
+        <translation>Dettagli</translation>
+    </message>
+    <message>
+        <source>Duration: %1</source>
+        <translation>Durata: %1</translation>
+    </message>
+    <message>
+        <source>Distance: %1 m</source>
+        <translation>Distanza: %1</translation>
+    </message>
+    <message>
+        <source>Training values</source>
+        <translation>Valori d&apos;allenamento</translation>
+    </message>
+    <message>
+        <source>Avg HR: %1 bpm</source>
+        <translation>Frequenza cardicaca media: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Max HR: %1 bpm</source>
+        <translation>Frequenza cardicaca max: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Min HR: %1 bpm</source>
+        <translation>Frequenza cardicaca min: %1 bpm</translation>
+    </message>
+    <message>
+        <source>PTE: %1</source>
+        <translation>PTE: %1</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Orologio</translation>
+    </message>
+    <message>
+        <source>Name: %1</source>
+        <translation>Nome: %1</translation>
+    </message>
+    <message>
+        <source>Variant: %1</source>
+        <translation>Variante: %1</translation>
+    </message>
+    <message>
+        <source>Serial: %1</source>
+        <translation>Seriale: %1</translation>
+    </message>
+</context>
+<context>
+    <name>MainWindow</name>
+    <message>
+        <source>Openambit</source>
+        <translation>Openambit</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Orologio</translation>
+    </message>
+    <message>
+        <source>No device detected</source>
+        <translation>Nessun orologio trovato</translation>
+    </message>
+    <message>
+        <source>Device not supported yet!</source>
+        <translation>Orologio non ancora supportato!</translation>
+    </message>
+    <message>
+        <source>Auth on &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</source>
+        <translation>Autorizza su &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</translation>
+    </message>
+    <message>
+        <source>Charge:</source>
+        <translation>Carica:</translation>
+    </message>
+    <message>
+        <source>Resync all</source>
+        <translation>Resincronizza tutto</translation>
+    </message>
+    <message>
+        <source>Sync now</source>
+        <translation>Sincronizza ora</translation>
+    </message>
+    <message>
+        <source>&amp;File</source>
+        <translation>&amp;File</translation>
+    </message>
+    <message>
+        <source>&amp;Help</source>
+        <translation>&amp;Aiuto</translation>
+    </message>
+    <message>
+        <source>About Openambit...</source>
+        <translation>A proposito di Openambit...</translation>
+    </message>
+    <message>
+        <source>E&amp;xit</source>
+        <translation>E&amp;sci</translation>
+    </message>
+    <message>
+        <source>&amp;Settings</source>
+        <translation>&amp;Impostazioni</translation>
+    </message>
+    <message>
+        <source>Minimize</source>
+        <translation>Minimizza</translation>
+    </message>
+    <message>
+        <source>Restore</source>
+        <translation>Ripristina</translation>
+    </message>
+    <message>
+        <source>About %1</source>
+        <translation>A proposito %1</translation>
+    </message>
+    <message>
+        <source>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Using Qt %3</source>
+        <translation>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Versione %2&lt;/b&gt;&lt;br /&gt;Usando Qt %3</translation>
+    </message>
+    <message>
+        <source>Syncronization complete</source>
+        <translation>Sincronizzazione completa</translation>
+    </message>
+    <message>
+        <source>Syncronisation finished</source>
+        <translation>Sincronizzazione completa</translation>
+    </message>
+    <message>
+        <source>Syncronization failed</source>
+        <translation>Sincronizzazione fallita</translation>
+    </message>
+    <message>
+        <source>Syncronisation failed</source>
+        <translation>Sincronizzazione fallita</translation>
+    </message>
+    <message>
+        <source>Newer firmware exists (%1.%2.%3)</source>
+        <translation>Nuovo firmware disponibile (%1.%2.%3)</translation>
+    </message>
+    <message>
+        <source>Context menu</source>
+        <translation>Menu contestuale</translation>
+    </message>
+    <message>
+        <source>Write Movescount file</source>
+        <translation>Scrivi file Movescount</translation>
+    </message>
+    <message>
+        <source>Syncronisation started</source>
+        <translation>Sincronizzazione iniziata</translation>
+    </message>
+</context>
+<context>
+    <name>QObject</name>
+    <message>
+        <source>The file is not an openambit version 1.0 file.</source>
+        <translation>Il file non  un file openambit versione 1.0.</translation>
+    </message>
+    <message>
+        <source>%1
+Line %2, column %3</source>
+        <translation>%1
+riga %2, colonna %3</translation>
+    </message>
+</context>
+<context>
+    <name>SettingsDialog</name>
+    <message>
+        <source>Dialog</source>
+        <translation>Dialogo</translation>
+    </message>
+    <message>
+        <source>General</source>
+        <translation>Generale</translation>
+    </message>
+    <message>
+        <source>Device sync</source>
+        <translation>Sincronizzazione orologio</translation>
+    </message>
+    <message>
+        <source>Movescount</source>
+        <translation>Movescount</translation>
+    </message>
+    <message>
+        <source>General settings</source>
+        <translation>Impostazioni generali</translation>
+    </message>
+    <message>
+        <source>Skip Beta check at startup</source>
+        <translation>Salta il controllo beta all&apos;accensione</translation>
+    </message>
+    <message>
+        <source>Continue running in background when Openambit main window is closed</source>
+        <translation>RImani in background anche chiudendo la finestra pincipale</translation>
+    </message>
+    <message>
+        <source>Device syncronisation settings</source>
+        <translation>Impostazioi sincronizzazione</translation>
+    </message>
+    <message>
+        <source>Sync time from computer</source>
+        <translation>Sincronizzazione completa</translation>
+    </message>
+    <message>
+        <source>Sync orbital data (from Movescount)</source>
+        <translation>Syicronizza dati orbitali (da movescount.com)</translation>
+    </message>
+    <message>
+        <source>Start sync automatically when device connected</source>
+        <translation>Sincronizza auomaticamente quando si connette un orologio</translation>
+    </message>
+    <message>
+        <source>Movescount connectivity</source>
+        <translation>Connessione Movescount</translation>
+    </message>
+    <message>
+        <source>Check Movescount for new versions</source>
+        <translation>Cerca nuove versioni su movescount</translation>
+    </message>
+    <message>
+        <source>Generate debug files (XMLs stored in ~/.openambit/movescount)</source>
+        <translation>Genera files di debug (XMLs stored in ~/.openambit/movescount)</translation>
+    </message>
+    <message>
+        <source>Sync logs with Movescount</source>
+        <translation>Syicronizza dati con movescount.com</translation>
+    </message>
+    <message>
+        <source>Email (Movescount account)</source>
+        <translation>Email (Account Movescount)</translation>
+    </message>
+</context>
+</TS>
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/translations/openambit_pl.ts ../openambit.git/src/openambit/translations/openambit_pl.ts
--- ./src/openambit/translations/openambit_pl.ts	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/translations/openambit_pl.ts	2015-03-20 20:47:45.932512160 +0100
@@ -0,0 +1,328 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE TS>
+<TS version="2.0" language="pl_PL">
+<context>
+    <name>ConfirmBetaDialog</name>
+    <message>
+        <source>Openambit: Disclaimer</source>
+        <translation>Openambit: Zastrzeenia</translation>
+    </message>
+    <message>
+        <source>Don&apos;t ask me again, I really want to use Openambit</source>
+        <translation>Nie pytaj ponownie, na prawd chc uy Openambit</translation>
+    </message>
+    <message>
+        <source>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</source>
+        <translation>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</translation>
+    </message>
+</context>
+<context>
+    <name>DeviceManager</name>
+    <message>
+        <source>Reading personal settings</source>
+        <translation>Odczytywanie ustawie osobistych</translation>
+    </message>
+    <message>
+        <source>Setting date/time</source>
+        <translation>Ustawianie daty/czasu</translation>
+    </message>
+    <message>
+        <source>Reading log files</source>
+        <translation>Odczytywanie logw</translation>
+    </message>
+    <message>
+        <source>Fetching orbital data</source>
+        <translation>Pobieranie ustawie satelitw</translation>
+    </message>
+    <message>
+        <source>Writing orbital data</source>
+        <translation>Zapisywnie danych satelitw</translation>
+    </message>
+    <message>
+        <source>Failed to get orbital data</source>
+        <translation>Nieudane pobranie ustawie satelitw</translation>
+    </message>
+    <message>
+        <source>Downloading log %1 of %2</source>
+        <translation>Pobieranie logu %1 z %2</translation>
+    </message>
+</context>
+<context>
+    <name>LogView</name>
+    <message>
+        <source>see on movescount.com</source>
+        <translation>Zobacz na movescount.com</translation>
+    </message>
+    <message>
+        <source>Not uploaded yet</source>
+        <translation>Jeszcze nie przesano</translation>
+    </message>
+    <message>
+        <source>Details</source>
+        <translation>Szczegy</translation>
+    </message>
+    <message>
+        <source>Duration: %1</source>
+        <translation>Czas trwania: %1</translation>
+    </message>
+    <message>
+        <source>Distance: %1 m</source>
+        <translation>Dystans: %1 m</translation>
+    </message>
+    <message>
+        <source>Training values</source>
+        <translation>Czegy treningu</translation>
+    </message>
+    <message>
+        <source>Avg HR: %1 bpm</source>
+        <translation>rednie ttno: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Max HR: %1 bpm</source>
+        <translation>Maksymalne ttno: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Min HR: %1 bpm</source>
+        <translation>Minimalne ttno: %1 bpm</translation>
+    </message>
+    <message>
+        <source>PTE: %1</source>
+        <translation>PTE: %1</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Urzdzenie</translation>
+    </message>
+    <message>
+        <source>Name: %1</source>
+        <translation>Nazwa: %1</translation>
+    </message>
+    <message>
+        <source>Variant: %1</source>
+        <translation type="unfinished">Wariant: %1</translation>
+    </message>
+    <message>
+        <source>Serial: %1</source>
+        <translation type="unfinished">Seria: %1</translation>
+    </message>
+</context>
+<context>
+    <name>MainWindow</name>
+    <message>
+        <source>Openambit</source>
+        <translation>Openambit</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Urzdzenie</translation>
+    </message>
+    <message>
+        <source>No device detected</source>
+        <translation>Nie znaleziono urzdzenia</translation>
+    </message>
+    <message>
+        <source>Device not supported yet!</source>
+        <translation>Urzdzenie jeszcze nie obsugiwane!</translation>
+    </message>
+    <message>
+        <source>Auth on &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</source>
+        <translation>Autentykacja na &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</translation>
+    </message>
+    <message>
+        <source>Charge:</source>
+        <translation>adowanie:</translation>
+    </message>
+    <message>
+        <source>Resync all</source>
+        <translation>Synchronizuj wszystko ponownie</translation>
+    </message>
+    <message>
+        <source>Sync now</source>
+        <translation>Synchronizuj teraz</translation>
+    </message>
+    <message>
+        <source>&amp;File</source>
+        <translation>&amp;Plik</translation>
+    </message>
+    <message>
+        <source>&amp;Help</source>
+        <translation>P&amp;omoc</translation>
+    </message>
+    <message>
+        <source>About Openambit...</source>
+        <translation>O Openambit...</translation>
+    </message>
+    <message>
+        <source>E&amp;xit</source>
+        <translation>&amp;Wyjcie</translation>
+    </message>
+    <message>
+        <source>&amp;Settings</source>
+        <translation>&amp;Ustawienia</translation>
+    </message>
+    <message>
+        <source>Minimize</source>
+        <translation>Zminimalizuj</translation>
+    </message>
+    <message>
+        <source>Restore</source>
+        <translation>Przywr</translation>
+    </message>
+    <message>
+        <source>About %1</source>
+        <translation>O %1</translation>
+    </message>
+    <message>
+        <source>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Using Qt %3</source>
+        <translation>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Wersja %2&lt;/b&gt;&lt;br /&gt;Uywa Qt %3</translation>
+    </message>
+    <message>
+        <source>Syncronization complete</source>
+        <translation>Synchronizacja zakoczona</translation>
+    </message>
+    <message>
+        <source>Syncronisation finished</source>
+        <translation>Synchronizacja zakoczona</translation>
+    </message>
+    <message>
+        <source>Syncronization failed</source>
+        <translation>Synchronizacja nieudana</translation>
+    </message>
+    <message>
+        <source>Syncronisation failed</source>
+        <translation>Synchronizacja nieudana</translation>
+    </message>
+    <message>
+        <source>Newer firmware exists (%1.%2.%3)</source>
+        <translation>Istnieje nowa wersja oprogramowania (%1.%2.%3)</translation>
+    </message>
+    <message>
+        <source>Context menu</source>
+        <translation>Menu kontekstowe</translation>
+    </message>
+    <message>
+        <source>Write Movescount file</source>
+        <translation>Zapisz plik Movescount</translation>
+    </message>
+    <message>
+        <source>Syncronisation started</source>
+        <translation>Synchronizacja rozpoczta</translation>
+    </message>
+</context>
+<context>
+    <name>QObject</name>
+    <message>
+        <source>The file is not an openambit version 1.0 file.</source>
+        <translation>To nie jest plik openambit w wersji 1.0.</translation>
+    </message>
+    <message>
+        <source>%1
+Line %2, column %3</source>
+        <translation>%1
+Linia %2, kolumna %3</translation>
+    </message>
+</context>
+<context>
+    <name>SettingsDialog</name>
+    <message>
+        <source>Dialog</source>
+        <translation type="unfinished">Dialog</translation>
+    </message>
+    <message>
+        <source>General</source>
+        <translation>Oglne</translation>
+    </message>
+    <message>
+        <source>Device sync</source>
+        <translation>Synchronizacja urzdzenia</translation>
+    </message>
+    <message>
+        <source>Movescount</source>
+        <translation>Movescount</translation>
+    </message>
+    <message>
+        <source>General settings</source>
+        <translation>Ustawienia oglne</translation>
+    </message>
+    <message>
+        <source>Skip Beta check at startup</source>
+        <translation>Pomi Beta sprawdzanie przy uruchomieniu</translation>
+    </message>
+    <message>
+        <source>Continue running in background when Openambit main window is closed</source>
+        <translation>Kontynuuj dziaanie w tle, gdy gwne okno Openambit jest zamknite</translation>
+    </message>
+    <message>
+        <source>Device syncronisation settings</source>
+        <translation>Synchronizacja ustawie urzdzenia</translation>
+    </message>
+    <message>
+        <source>Sync time from computer</source>
+        <translation>Synchronizuj czas z komputera</translation>
+    </message>
+    <message>
+        <source>Sync orbital data (from Movescount)</source>
+        <translation>Synchronizuj dane satelitw (z Movescount)</translation>
+    </message>
+    <message>
+        <source>Start sync automatically when device connected</source>
+        <translation>Rozpoczynij automatyczn synchronizacj, gdy urzdzenie jest podczone</translation>
+    </message>
+    <message>
+        <source>Movescount connectivity</source>
+        <translation>Poczenie z Movescount</translation>
+    </message>
+    <message>
+        <source>Check Movescount for new versions</source>
+        <translation>Sprawd now wersj w Movescount</translation>
+    </message>
+    <message>
+        <source>Generate debug files (XMLs stored in ~/.openambit/movescount)</source>
+        <translation>Generuj pliki debug (XMLe trzymane s w ~/.openambit/movescount)</translation>
+    </message>
+    <message>
+        <source>Sync logs with Movescount</source>
+        <translation>Synchronizuj treningi z Movescount</translation>
+    </message>
+    <message>
+        <source>Email (Movescount account)</source>
+        <translation>Email (konto Movescount)</translation>
+    </message>
+</context>
+</TS>
diff -Nur -x debian -x .git -x .gitignore -x .pc ./src/openambit/translations/openambit_sv.ts ../openambit.git/src/openambit/translations/openambit_sv.ts
--- ./src/openambit/translations/openambit_sv.ts	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/translations/openambit_sv.ts	2015-03-20 20:47:45.932512160 +0100
@@ -0,0 +1,317 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE TS>
+<TS version="2.0" language="sv_SE">
+<context>
+    <name>ConfirmBetaDialog</name>
+    <message>
+        <source>Openambit: Disclaimer</source>
+        <translation>Openambit: Varning</translation>
+    </message>
+    <message>
+        <source>Don&apos;t ask me again, I really want to use Openambit</source>
+        <translation>Frga mig inte igen</translation>
+    </message>
+    <message>
+        <source>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>DeviceManager</name>
+    <message>
+        <source>Reading personal settings</source>
+        <translation>Lser personliga instllningar</translation>
+    </message>
+    <message>
+        <source>Setting date/time</source>
+        <translation>Skriver datum &amp; tid</translation>
+    </message>
+    <message>
+        <source>Reading log files</source>
+        <translation>Lser logg-filer</translation>
+    </message>
+    <message>
+        <source>Fetching orbital data</source>
+        <translation>Hmtar GPS-data</translation>
+    </message>
+    <message>
+        <source>Writing orbital data</source>
+        <translation>Skriver GPS-data</translation>
+    </message>
+    <message>
+        <source>Failed to get orbital data</source>
+        <translation>GPS-data gick ej att hmta</translation>
+    </message>
+    <message>
+        <source>Downloading log %1 of %2</source>
+        <translation>Lser logg %1 av %2</translation>
+    </message>
+</context>
+<context>
+    <name>LogEntry</name>
+    <message>
+        <source>Device</source>
+        <translation type="obsolete">Enhet</translation>
+    </message>
+</context>
+<context>
+    <name>LogView</name>
+    <message>
+        <source>see on movescount.com</source>
+        <translation>se p movescount.com</translation>
+    </message>
+    <message>
+        <source>Not uploaded yet</source>
+        <translation>Ej uppladdad</translation>
+    </message>
+    <message>
+        <source>Details</source>
+        <translation>Detaljer</translation>
+    </message>
+    <message>
+        <source>Duration: %1</source>
+        <translation>Tid: %1</translation>
+    </message>
+    <message>
+        <source>Distance: %1 m</source>
+        <translation>Strcka: %1 m</translation>
+    </message>
+    <message>
+        <source>Training values</source>
+        <translation>Trningsdetaljer</translation>
+    </message>
+    <message>
+        <source>Avg HR: %1 bpm</source>
+        <translation>Snittpuls: %1 slag/min</translation>
+    </message>
+    <message>
+        <source>Max HR: %1 bpm</source>
+        <translation>Maxpuls: %1 slag/min</translation>
+    </message>
+    <message>
+        <source>Min HR: %1 bpm</source>
+        <translation>Minpuls: %1 slag/min</translation>
+    </message>
+    <message>
+        <source>PTE: %1</source>
+        <translation>PTE: %1</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Enhet</translation>
+    </message>
+    <message>
+        <source>Name: %1</source>
+        <translation>Modell: %1</translation>
+    </message>
+    <message>
+        <source>Variant: %1</source>
+        <translation>Variant: %1</translation>
+    </message>
+    <message>
+        <source>Serial: %1</source>
+        <translation>Serienummer: %1</translation>
+    </message>
+</context>
+<context>
+    <name>MainWindow</name>
+    <message>
+        <source>Sync now</source>
+        <translation>Synkronisera</translation>
+    </message>
+    <message>
+        <source>Minimize</source>
+        <translation>Minimera</translation>
+    </message>
+    <message>
+        <source>Restore</source>
+        <translation>terstll</translation>
+    </message>
+    <message>
+        <source>About %1</source>
+        <translation>Om %1</translation>
+    </message>
+    <message>
+        <source>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Using Qt %3</source>
+        <translation>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Qt %3</translation>
+    </message>
+    <message>
+        <source>No device detected</source>
+        <translation>Ingen enhet hittades</translation>
+    </message>
+    <message>
+        <source>Syncronization complete</source>
+        <translation>Synkroniseringen slutfrd</translation>
+    </message>
+    <message>
+        <source>Syncronisation finished</source>
+        <translation>Synkroniseringen slutfrd</translation>
+    </message>
+    <message>
+        <source>Syncronization failed</source>
+        <translation>Synkroniseringen misslyckades</translation>
+    </message>
+    <message>
+        <source>Syncronisation failed</source>
+        <translation>Synkroniseringen misslyckades</translation>
+    </message>
+    <message>
+        <source>Newer firmware exists (%1.%2.%3)</source>
+        <translation>Det finns en nyare firmware (%1.%2.%3)</translation>
+    </message>
+    <message>
+        <source>Context menu</source>
+        <translation>Snabbval</translation>
+    </message>
+    <message>
+        <source>Write Movescount file</source>
+        <translation>Skriv Movescount-fil</translation>
+    </message>
+    <message>
+        <source>Syncronisation started</source>
+        <translation>Synkronisering startad</translation>
+    </message>
+    <message>
+        <source>Openambit</source>
+        <translation>Openambit</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Enhet</translation>
+    </message>
+    <message>
+        <source>Device not supported yet!</source>
+        <translation>Enheten stds inte n!</translation>
+    </message>
+    <message>
+        <source>Auth on &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</source>
+        <translation>Tillt Openambit p &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</translation>
+    </message>
+    <message>
+        <source>Charge:</source>
+        <translation>Laddning:</translation>
+    </message>
+    <message>
+        <source>Resync all</source>
+        <translation>Omsynkronsiera allt</translation>
+    </message>
+    <message>
+        <source>&amp;File</source>
+        <translation>&amp;Arkiv</translation>
+    </message>
+    <message>
+        <source>&amp;Help</source>
+        <translation>&amp;Hjlp</translation>
+    </message>
+    <message>
+        <source>About Openambit...</source>
+        <translation>Om Openambit...</translation>
+    </message>
+    <message>
+        <source>E&amp;xit</source>
+        <translation>A&amp;vsluta</translation>
+    </message>
+    <message>
+        <source>&amp;Settings</source>
+        <translation>&amp;Instllningar</translation>
+    </message>
+</context>
+<context>
+    <name>QObject</name>
+    <message>
+        <source>The file is not an openambit version 1.0 file.</source>
+        <translation>Filen r inte i openambit version 1.0-format.</translation>
+    </message>
+    <message>
+        <source>%1
+Line %2, column %3</source>
+        <translation>%1
+Rad %2, kolumn %3</translation>
+    </message>
+</context>
+<context>
+    <name>SettingsDialog</name>
+    <message>
+        <source>Dialog</source>
+        <translation>Dialog</translation>
+    </message>
+    <message>
+        <source>General</source>
+        <translation>Generellt</translation>
+    </message>
+    <message>
+        <source>Device sync</source>
+        <translation>Synkronisering</translation>
+    </message>
+    <message>
+        <source>Movescount</source>
+        <translation>Movescount</translation>
+    </message>
+    <message>
+        <source>General settings</source>
+        <translation>Generella instllningar</translation>
+    </message>
+    <message>
+        <source>Skip Beta check at startup</source>
+        <translation>Visa inte beta-varning vid uppstart</translation>
+    </message>
+    <message>
+        <source>Continue running in background when Openambit main window is closed</source>
+        <translation>Lt Openambit fortstta kra i bakgrunden nr fnstret stngs</translation>
+    </message>
+    <message>
+        <source>Device syncronisation settings</source>
+        <translation>Synkroniseringsinstllningar</translation>
+    </message>
+    <message>
+        <source>Sync time from computer</source>
+        <translation>Synkronisera enhet med datorns tid</translation>
+    </message>
+    <message>
+        <source>Sync orbital data (from Movescount)</source>
+        <translation>Synkronisera GPS-data (frn Movescount)</translation>
+    </message>
+    <message>
+        <source>Start sync automatically when device connected</source>
+        <translation>Starta synkroniseringen automatiskt nr enhet ansluts</translation>
+    </message>
+    <message>
+        <source>Movescount connectivity</source>
+        <translation>Movescount-instllningar</translation>
+    </message>
+    <message>
+        <source>Check Movescount for new versions</source>
+        <translation>Leta efter firmware-uppdatering hos Movescount</translation>
+    </message>
+    <message>
+        <source>Generate debug files (XMLs stored in ~/.openambit/movescount)</source>
+        <translation>Generera felskningsfiler (XML-filer som sparas i ~/.openambit/movescount)</translation>
+    </message>
+    <message>
+        <source>Sync logs with Movescount</source>
+        <translation>Ladda upp loggar till Movescount</translation>
+    </message>
+    <message>
+        <source>Email (Movescount account)</source>
+        <translation>E-post (till ditt Movescount-konto)</translation>
+    </message>
+</context>
+</TS>
diff -Nur -x debian -x .git -x .gitignore -x .pc ./tools/movescountXmlDiff.pl ../openambit.git/tools/movescountXmlDiff.pl
--- ./tools/movescountXmlDiff.pl	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/tools/movescountXmlDiff.pl	2014-11-05 21:53:14.000000000 +0100
@@ -1,157 +1,140 @@
-#!/usr/bin/perl
+#!/usr/bin/perl -w
 
-#use strict;
-#use warnings;
+use strict;
+use warnings;
 
-my $diffText = `diff -w $ARGV[0] $ARGV[1]`;
-
-my @lines = split /\n/, $diffText;
+if ( $#ARGV != 1 ) {
+        die "$0 FILE1 FILE2\n";
+}
 
 my @records;
-my $currentRecordLine;
-my $currentRecordRemoveLines;
-my $currentRecordAddLines;
-my $currentRecordStarted = 0;
-
-foreach my $line (@lines) {
-    if ($line =~ m/[0-9,\-]+[c|d|a][0-9,\-]+/g) {
-        if ($currentRecordStarted == 1) {
-            my %currentRecord = ( "LinesText" => $currentRecordLine,
-                                  "RemoveLines" => $currentRecordRemoveLines,
-                                  "AddLines" => $currentRecordAddLines
-                );
-            push(@records, \%currentRecord);
-        }
-        $currentRecordLine = $line;
-        $currentRecordRemoveLines = [];
-        $currentRecordAddLines = [];
-        $currentRecordStarted = 1;
-    }
-    elsif ($line =~ m/^</g) {
-        push(@{$currentRecordRemoveLines}, $line);
-    }
-    elsif ($line =~ m/^>/g) {
-        push(@{$currentRecordAddLines}, $line);
-    }
+{
+        my @lines = `diff -w $ARGV[0] $ARGV[1]`;
+        chomp @lines;
+        my $currentRecordLine;
+        my $currentRecordRemoveLines;
+        my $currentRecordAddLines;
+        my $currentRecordStarted = 0;
+
+        foreach (@lines) {
+                if ( m/[0-9,\-]+[c|d|a][0-9,\-]+/g) {
+                        if ( $currentRecordStarted ) {
+                                push @records, { 'LinesText' => $currentRecordLine, 'RemoveLines' => $currentRecordRemoveLines, 'AddLines' => $currentRecordAddLines, };
+                        }
+                        $currentRecordLine = $_;
+                        $currentRecordRemoveLines = [];
+                        $currentRecordAddLines = [];
+                        $currentRecordStarted = 1;
+                } elsif ( m/^</g) {
+                        push(@{$currentRecordRemoveLines}, $_);
+                } elsif ( m/^>/g) {
+                        push(@{$currentRecordAddLines}, $_);
+                }
+        }
 }
 
-foreach my $entry (@records) {
+my @matchRemove;
+my @matchAdd;
+my $Epsilon = 0.00000000000005;
+foreach (@records) {
     my $printDiff = 1;
 
-    if (scalar @{$entry->{"RemoveLines"}} == scalar @{$entry->{"AddLines"}}) {
-        my $diffFound = scalar @{$entry->{"RemoveLines"}};
-        for ($i = 0; $i < scalar @{$entry->{"RemoveLines"}}; $i++) {
-            if ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<HR>([0-9\.]+)<\/HR>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<HR>([0-9\.]+)<\/HR>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+    if (scalar @{$_->{"RemoveLines"}} == scalar @{$_->{"AddLines"}}) {
+        my $diffFound = scalar @{$_->{"RemoveLines"}};
+        for (my $i = 0; $i < scalar @{$_->{"RemoveLines"}}; $i++) {
+            if ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<HR>([0-9\.]+)<\/HR>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<HR>([0-9\.]+)<\/HR>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Latitude>([\-0-9\.]+)<\/Latitude>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Latitude>([\-0-9\.]+)<\/Latitude>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.000000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.000000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Latitude>([\-0-9\.]+)<\/Latitude>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Latitude>([\-0-9\.]+)<\/Latitude>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Longitude>([\-0-9\.]+)<\/Longitude>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Longitude>([\-0-9\.]+)<\/Longitude>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.000000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.000000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Longitude>([\-0-9\.]+)<\/Longitude>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Longitude>([\-0-9\.]+)<\/Longitude>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Speed>([0-9\.]+)<\/Speed>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Speed>([0-9\.]+)<\/Speed>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Speed>([0-9\.]+)<\/Speed>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Speed>([0-9\.]+)<\/Speed>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<VerticalSpeed>([\-0-9\.]+)<\/VerticalSpeed>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<VerticalSpeed>([\-0-9\.]+)<\/VerticalSpeed>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<VerticalSpeed>([\-0-9\.]+)<\/VerticalSpeed>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<VerticalSpeed>([\-0-9\.]+)<\/VerticalSpeed>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<GPSHeading>([\-0-9\.]+)<\/GPSHeading>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<GPSHeading>([\-0-9\.]+)<\/GPSHeading>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<GPSHeading>([\-0-9\.]+)<\/GPSHeading>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<GPSHeading>([\-0-9\.]+)<\/GPSHeading>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<GPSSpeed>([0-9\.]+)<\/GPSSpeed>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<GPSSpeed>([0-9\.]+)<\/GPSSpeed>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<GPSSpeed>([0-9\.]+)<\/GPSSpeed>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<GPSSpeed>([0-9\.]+)<\/GPSSpeed>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<GPSAltitude>([0-9\.]+)<\/GPSAltitude>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<GPSAltitude>([0-9\.]+)<\/GPSAltitude>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<GPSAltitude>([0-9\.]+)<\/GPSAltitude>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<GPSAltitude>([0-9\.]+)<\/GPSAltitude>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<EHPE>([0-9\.]+)<\/EHPE>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<EHPE>([0-9\.]+)<\/EHPE>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<EHPE>([0-9\.]+)<\/EHPE>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<EHPE>([0-9\.]+)<\/EHPE>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Duration>([0-9\.]+)<\/Duration>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Duration>([0-9\.]+)<\/Duration>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Duration>([0-9\.]+)<\/Duration>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Duration>([0-9\.]+)<\/Duration>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Time>([0-9\.]+)<\/Time>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Time>([0-9\.]+)<\/Time>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Time>([0-9\.]+)<\/Time>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Time>([0-9\.]+)<\/Time>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<EnergyConsumption>([0-9\.]+)<\/EnergyConsumption>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<EnergyConsumption>([0-9\.]+)<\/EnergyConsumption>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<EnergyConsumption>([0-9\.]+)<\/EnergyConsumption>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<EnergyConsumption>([0-9\.]+)<\/EnergyConsumption>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<PeakTrainingEffect>([0-9\.]+)<\/PeakTrainingEffect>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<PeakTrainingEffect>([0-9\.]+)<\/PeakTrainingEffect>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<PeakTrainingEffect>([0-9\.]+)<\/PeakTrainingEffect>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<PeakTrainingEffect>([0-9\.]+)<\/PeakTrainingEffect>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<BatteryCharge>([0-9\.]+)<\/BatteryCharge>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<BatteryCharge>([0-9\.]+)<\/BatteryCharge>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<BatteryCharge>([0-9\.]+)<\/BatteryCharge>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<BatteryCharge>([0-9\.]+)<\/BatteryCharge>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<BatteryChargeAtStart>([0-9\.]+)<\/BatteryChargeAtStart>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<BatteryChargeAtStart>([0-9\.]+)<\/BatteryChargeAtStart>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<BatteryChargeAtStart>([0-9\.]+)<\/BatteryChargeAtStart>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<BatteryChargeAtStart>([0-9\.]+)<\/BatteryChargeAtStart>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Avg>([0-9\.]+)<\/Avg>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Avg>([0-9\.]+)<\/Avg>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Avg>([0-9\.]+)<\/Avg>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Avg>([0-9\.]+)<\/Avg>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Max>([0-9\.]+)<\/Max>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Max>([0-9\.]+)<\/Max>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Max>([0-9\.]+)<\/Max>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Max>([0-9\.]+)<\/Max>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            #elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2})Z<\/UTC>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2})Z<\/UTC>/g))) {
-            #    if ((@matchRemove[0] - @matchAdd[0]) <= 1 &&
-            #        (@matchRemove[0] - @matchAdd[0]) >= -1) {
+            #elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2})Z<\/UTC>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2})Z<\/UTC>/g))) {
+            #    if (($matchRemove[0] - $matchAdd[0]) <= 1 &&
+            #        ($matchRemove[0] - $matchAdd[0]) >= -1) {
             #        $diffFound--;
             #    }
             #}
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2}\.[0-9]{3})Z<\/UTC>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2}\.[0-9]{3})Z<\/UTC>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.002 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.002) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2}\.[0-9]{3})Z<\/UTC>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2}\.[0-9]{3})Z<\/UTC>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  0.002 ) {
                     $diffFound--;
                 }
             }
@@ -162,14 +145,14 @@
     }
 
     if ($printDiff == 1) {
-        print $entry->{"LinesText"}, "\n";
-        foreach my $remLine (@{$entry->{"RemoveLines"}}) {
+        print $_->{"LinesText"}, "\n";
+        foreach my $remLine (@{$_->{"RemoveLines"}}) {
             print $remLine, "\n";
         }
-        if (scalar @{$entry->{"RemoveLines"}} > 0 &&  scalar @{$entry->{"AddLines"}} > 0) {
+        if (scalar @{$_->{"RemoveLines"}} > 0 &&  scalar @{$_->{"AddLines"}} > 0) {
             print "---\n";
         }
-        foreach my $remLine (@{$entry->{"AddLines"}}) {
+        foreach my $remLine (@{$_->{"AddLines"}}) {
             print $remLine, "\n";
         }
     }
diff -Nur -x debian -x .git -x .gitignore -x .pc ./wireshark_dissector/ambit-dissector.c ../openambit.git/wireshark_dissector/ambit-dissector.c
--- ./wireshark_dissector/ambit-dissector.c	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/wireshark_dissector/ambit-dissector.c	2014-11-05 21:53:14.000000000 +0100
@@ -61,6 +61,10 @@
 static gint dissect_ambit_lock_status_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
 static gint dissect_ambit_lock_set(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
 static gint dissect_ambit_lock_set_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
+static gint dissect_ambit_gps_data_peek_get(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
+static gint dissect_ambit_gps_data_peek_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
+static gint dissect_ambit_data_write(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
+static gint dissect_ambit_data_write_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
 
 static gint dissect_ambit3_settings_get(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
 static gint dissect_ambit3_settings_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
@@ -151,6 +155,7 @@
 static int hf_ambit_log_header_energy = -1;
 static int hf_ambit_log_header_cadence_max = -1;
 static int hf_ambit_log_header_cadence_avg = -1;
+static int hf_ambit_log_header_swimming_lengths = -1;
 static int hf_ambit_log_header_speed_max_time = -1;
 static int hf_ambit_log_header_alt_max_time = -1;
 static int hf_ambit_log_header_alt_min_time = -1;
@@ -159,6 +164,7 @@
 static int hf_ambit_log_header_temp_max_time = -1;
 static int hf_ambit_log_header_temp_min_time = -1;
 static int hf_ambit_log_header_cadence_max_time = -1;
+static int hf_ambit_log_header_swimming_pool_length = -1;
 static int hf_ambit_log_header_time_first_fix = -1;
 static int hf_ambit_log_header_battery_start = -1;
 static int hf_ambit_log_header_battery_stop = -1;
@@ -238,8 +244,25 @@
 static int hf_ambit_log_altitude_source_altitude_offset = -1;
 static int hf_ambit_log_altitude_source_pressure_offset = -1;
 
+static int hf_ambit_log_cadence_source_type = -1;
+
+static int hf_ambit_log_fwinfo_build_date = -1;
+
+static int hf_ambit_log_swimming_turn_distance = -1;
+static int hf_ambit_log_swimming_turn_lengths = -1;
+static int hf_ambit_log_swimming_turn_lengths_wo_change = -1;
+static int hf_ambit_log_swimming_turn_classification0 = -1;
+static int hf_ambit_log_swimming_turn_classification1 = -1;
+static int hf_ambit_log_swimming_turn_classification2 = -1;
+static int hf_ambit_log_swimming_turn_classification3 = -1;
+static int hf_ambit_log_swimming_turn_prev_style = -1;
+
+static int hf_ambit_log_delayed_store = -1;
+
 static int hf_ambit_log_ibi = -1;
 
+static int hf_ambit_gps_data_head = -1;
+
 static gint ett_ambit = -1;
 static gint ett_ambit_data = -1;
 static gint ett_ambit_log_data = -1;
@@ -296,8 +319,12 @@
 };
 
 static const value_string log_samples_distance_source_type_vals[] = {
+    { 0x00, "Bikepod" },
+    { 0x01, "Footpod" },
     { 0x02, "GPS" },
     { 0x03, "Wrist" },
+    { 0x04, "Indoorswimming" },
+    { 0x05, "Outdoorswimming" },
     { 0, NULL }
 };
 
@@ -306,6 +333,21 @@
     { 0, NULL }
 };
 
+static const value_string log_samples_cadence_source_type_vals[] = {
+    { 0x40, "Wrist" },
+    { 0, NULL }
+};
+
+static const value_string log_samples_swimming_style_vals[] = {
+    { 0x00, "Other" },
+    { 0x01, "Butterfly" },
+    { 0x02, "Backstroke" },
+    { 0x03, "Breaststroke" },
+    { 0x04, "Freestyle" },
+    { 0x05, "Drill" },
+    { 0, NULL }
+};
+
 static const ambit_protocol_type_t subdissectors[] = {
     { 0x03000500, "Set time", dissect_ambit_time_write },
     { 0x03000a00, "Time reply", dissect_ambit_time_reply },
@@ -329,6 +371,10 @@
     { 0x0b0a0a00, "Log header step reply", dissect_ambit_log_header_step_reply },
     { 0x0b0b0500, "Get log header", dissect_ambit_log_header_get },
     { 0x0b0b0a00, "Log header reply", dissect_ambit_log_header_reply },
+    { 0x0b150500, "GPS data peek request", dissect_ambit_gps_data_peek_get },
+    { 0x0b150a00, "GPS data peek reply", dissect_ambit_gps_data_peek_reply },
+    { 0x0b160500, "Data write", dissect_ambit_data_write },
+    { 0x0b160a00, "Data write reply", dissect_ambit_data_write_reply },
     { 0x0b170500, "Get log data", dissect_ambit_log_data_get },
     { 0x0b170a00, "Log data reply", dissect_ambit_log_data_reply },
     { 0x0b190500, "Get lock status", dissect_ambit_lock_status_get },
@@ -363,7 +409,11 @@
 {
     proto_item *unknown_item = NULL;
     unknown_item = proto_tree_add_item(tree, hf_ambit_unknown, tvb, offset, len, ENC_LITTLE_ENDIAN);
+#if VERSION_MAJOR >= 1 && VERSION_MINOR >= 11
+    /* TODO port to new expert info API */
+#else
     expert_add_info_format(pinfo, unknown_item, PI_UNDECODED, PI_WARN, "Not dissected yet");
+#endif
 }
 
 static gint dissect_ambit_date_write(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
@@ -640,8 +690,10 @@
         offset += 1;
         proto_tree_add_item(tree, hf_ambit_log_header_cadence_avg, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         offset += 1;
-        dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 4);
-        offset += 4;
+        dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 2);
+        offset += 2;
+        proto_tree_add_item(tree, hf_ambit_log_header_swimming_lengths, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+        offset += 2;
         proto_tree_add_item(tree, hf_ambit_log_header_speed_max_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
         offset += 4;
         proto_tree_add_item(tree, hf_ambit_log_header_alt_max_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
@@ -658,7 +710,7 @@
         offset += 4;
         proto_tree_add_item(tree, hf_ambit_log_header_cadence_max_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
         offset += 4;
-        dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 4);
+        proto_tree_add_item(tree, hf_ambit_log_header_swimming_pool_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);
         offset += 4;
         proto_tree_add_item(tree, hf_ambit_log_header_time_first_fix, tvb, offset, 2, ENC_LITTLE_ENDIAN);
         offset += 2;
@@ -958,9 +1010,12 @@
     if (offset + 1 >= length) return offset;
     proto_tree_add_item(tree, hf_ambit_log_header_cadence_avg, tvb, offset, 1, ENC_LITTLE_ENDIAN);
     offset += 1;
-    if (offset + 4 >= length) return offset;
-    dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 4);
-    offset += 4;
+    if (offset + 2 >= length) return offset;
+    dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 2);
+    offset += 2;
+    if (offset + 2 >= length) return offset;
+    proto_tree_add_item(tree, hf_ambit_log_header_swimming_lengths, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+    offset += 2;
     if (offset + 4 >= length) return offset;
     proto_tree_add_item(tree, hf_ambit_log_header_speed_max_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
     offset += 4;
@@ -986,7 +1041,7 @@
     proto_tree_add_item(tree, hf_ambit_log_header_cadence_max_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
     offset += 4;
     if (offset + 4 >= length) return offset;
-    dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 4);
+    proto_tree_add_item(tree, hf_ambit_log_header_swimming_pool_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);
     offset += 4;
     if (offset + 2 >= length) return offset;
     proto_tree_add_item(tree, hf_ambit_log_header_time_first_fix, tvb, offset, 2, ENC_LITTLE_ENDIAN);
@@ -1448,6 +1503,64 @@
                 dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, sample_len - 9);
             }
             break;
+          case 0x14:
+            sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Swimming turn)", (*sampleno)++);
+            sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_time_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 1);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_delayed_store, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 1);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_distance, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_lengths, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 4);
+            offset += 4;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 2);
+            offset += 2;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 8);
+            offset += 8;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_lengths_wo_change, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_classification0, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_classification1, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_classification2, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_classification3, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_prev_style, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 1);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_distance, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            break;
+          case 0x15:
+            sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Swimming stroke)", (*sampleno)++);
+            sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_time_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_delayed_store, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            break;
           case 0x18:
             sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Activity)", (*sampleno)++);
             sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
@@ -1467,6 +1580,23 @@
                 dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, sample_len - 12);
             }
             break;
+          case 0x1a:
+            sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Cadence source)", (*sampleno)++);
+            sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_time_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_cadence_source_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            if (offset < sample_len - 2) {
+                dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, sample_len - 7);
+            }
+            break;
           case 0x1b:
             sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (lat-long)", (*sampleno)++);
             sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
@@ -1490,6 +1620,35 @@
                 dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, sample_len - 14);
             }
             break;
+          case 0x1c:
+            sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Firmware info)", (*sampleno)++);
+            sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_time_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            {
+                guint8 fw1,fw2;
+                guint16 fw3;
+                fw1 = tvb_get_guint8(tvb, offset);
+                fw2 = tvb_get_guint8(tvb, offset+1);
+                fw3 = tvb_get_letohs(tvb, offset+2);
+                proto_tree_add_string_format_value(sample_tree, hf_ambit_fw_version, tvb, offset, 4, "FW version", "%d.%d.%d", fw1, fw2, fw3);
+                offset += 4;
+                guint16 year = tvb_get_letohs(tvb, offset);
+                guint8 month = tvb_get_guint8(tvb, offset + 2);
+                guint8 day = tvb_get_guint8(tvb, offset + 3);
+                guint8 hour = tvb_get_guint8(tvb, offset + 4);
+                guint8 minute = tvb_get_guint8(tvb, offset + 5);
+                guint16 seconds = tvb_get_letohs(tvb, offset + 6);
+                proto_tree_add_string_format_value(sample_tree, hf_ambit_log_fwinfo_build_date, tvb, offset, 8, "Builddate", "%04d-%02d-%02d %02d:%02d:%2.3f", year, month, day, hour, minute, ((float)seconds/1000.0));
+                offset += 8;
+            }
+            break;
           default:
             sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Unknown)", (*sampleno)++);
             sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
@@ -1528,6 +1687,29 @@
 {
 }
 
+static gint dissect_ambit_gps_data_peek_get(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
+{
+}
+
+static gint dissect_ambit_gps_data_peek_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
+{
+    proto_tree_add_item(tree, hf_ambit_gps_data_head, tvb, 0, 9, ENC_LITTLE_ENDIAN);
+}
+
+static gint dissect_ambit_data_write(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
+{
+    guint32 length = tvb_get_letohl(tvb, 4);
+
+    proto_tree_add_item(tree, hf_ambit_log_data_address, tvb, 0, 4, ENC_LITTLE_ENDIAN);
+    proto_tree_add_item(tree, hf_ambit_log_data_length, tvb, 4, 4, ENC_LITTLE_ENDIAN);
+
+    proto_tree_add_text(tree, tvb, 8, length, "Payload");
+}
+
+static gint dissect_ambit_data_write_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
+{
+}
+
 static gint dissect_ambit3_settings_get(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
 {
 }
@@ -2114,6 +2296,8 @@
           { "Cadence max (rpm)", "ambit.log_header.cadence_max", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_cadence_avg,
           { "Cadence avg (rpm)", "ambit.log_header.cadence_avg", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_header_swimming_lengths,
+          { "Swimming pool lengths", "ambit.log_header.swimming_lengths", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_speed_max_time,
           { "Time max speed (ms)", "ambit.log_header.speed_maxtime", FT_UINT32, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_alt_max_time,
@@ -2130,6 +2314,8 @@
           { "Time min temperature (ms)", "ambit.log_header.temp_mintime", FT_UINT32, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_cadence_max_time,
           { "Time max cadence (ms)", "ambit.log_header.cadence_maxtime", FT_UINT32, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_header_swimming_pool_length,
+          { "Swimming pool length (m)", "ambit.log_header.swimming_pool_length", FT_UINT32, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_time_first_fix,
           { "Time of first fix", "ambit.log_header.time_first_fix", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_battery_start,
@@ -2277,9 +2463,37 @@
           { "Altitude offset", "ambit.log_sample.altitude_source.alt_offset", FT_INT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_altitude_source_pressure_offset,
           { "Pressure", "ambit.log_sample.altitude_source.pres_offset", FT_INT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_cadence_source_type,
+          { "Type", "ambit.log_sample.cadence_source.type", FT_UINT8, BASE_HEX, VALS(log_samples_cadence_source_type_vals), 0x0,NULL, HFILL } },
+
+        { &hf_ambit_log_fwinfo_build_date,
+          { "Build date", "ambit.log_sample.fwinfo.builddate", FT_STRING, BASE_NONE, NULL, 0x0,NULL, HFILL } },
+
+        { &hf_ambit_log_swimming_turn_distance,
+          { "Distance (cm)", "ambit.log_sample.swimming_turn.distance", FT_UINT32, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_lengths,
+          { "Total pool lengths", "ambit.log_sample.swimming_turn.lengths", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_lengths_wo_change,
+          { "Total pool lengths w/o style change(!?)", "ambit.log_sample.swimming_turn.lengths_wo_change", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_prev_style,
+          { "Style", "ambit.log_sample.swimming_turn.style", FT_UINT8, BASE_HEX, VALS(log_samples_swimming_style_vals), 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_classification0,
+          { "ClassificationVector[0]", "ambit.log_sample.swimming_turn.classification0", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_classification1,
+          { "ClassificationVector[1]", "ambit.log_sample.swimming_turn.classification1", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_classification2,
+          { "ClassificationVector[2]", "ambit.log_sample.swimming_turn.classification2", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_classification3,
+          { "ClassificationVector[3]", "ambit.log_sample.swimming_turn.classification3", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+
+        { &hf_ambit_log_delayed_store,
+          { "Log write delay (1/10 s)", "ambit.log_sample.delayed_store", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
 
         { &hf_ambit_log_ibi,
           { "IBI entry", "ambit.log_sample.ibi", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+
+        { &hf_ambit_gps_data_head,
+          { "Current GPS position data version", "ambit.gps.data.head", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } },
     };
 
     static gint *ett[] = {
diff -Nur -x debian -x .git -x .gitignore -x .pc ./wireshark_dissector/cmake/FindWireshark.cmake ../openambit.git/wireshark_dissector/cmake/FindWireshark.cmake
--- ./wireshark_dissector/cmake/FindWireshark.cmake	2015-05-03 11:18:41.000000000 +0200
+++ ../openambit.git/wireshark_dissector/cmake/FindWireshark.cmake	2014-11-05 21:53:14.000000000 +0100
@@ -16,7 +16,7 @@
 # wireshark does not install its library with pkg-config information,
 # so we need to manually find the libraries and headers
 
-FIND_PATH( WIRESHARK_INCLUDE_DIRS epan/column_info.h PATH_SUFFIXES wireshark )
+FIND_PATH( WIRESHARK_INCLUDE_DIRS epan/packet.h PATH_SUFFIXES wireshark )
 FIND_LIBRARY( WIRESHARK_LIBRARIES wireshark PATH_SUFFIXES wireshark )
 
 # Report results
