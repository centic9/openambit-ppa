diff -Nur -x debian -x .git -x .pc ./src/example/ambitconsole.c ../openambit.git/src/example/ambitconsole.c
--- ./src/example/ambitconsole.c	2014-09-17 21:24:42.950329917 +0200
+++ ../openambit.git/src/example/ambitconsole.c	2014-11-05 21:53:14.541131599 +0100
@@ -1,5 +1,6 @@
 #include <stdlib.h>
 #include <stdio.h>
+#include <string.h>
 #include <libambit.h>
 
 static int log_skip_cb(void *ambit_object, ambit_log_header_t *log_header);
@@ -7,18 +8,27 @@
 
 int main(int argc, char *argv[])
 {
+    ambit_device_info_t *info = libambit_enumerate();
     ambit_object_t *ambit_object;
-    ambit_device_info_t info;
     ambit_device_status_t status;
     ambit_personal_settings_t settings;
     time_t current_time;
     struct tm *local_time;
 
-    if ((ambit_object = libambit_detect()) != NULL) {
-        libambit_device_info_get(ambit_object, &info);
+    if (info) {
+        printf("Device: %s, serial: %s\n", info->name, info->serial);
+        if (0 == info->access_status) {
+          printf("F/W version: %d.%d.%d\n", info->fw_version[0], info->fw_version[1], (info->fw_version[2] << 0) | (info->fw_version[3] << 8));
+            if (!info->is_supported) {
+                printf("Device is not supported yet!\n");
+            }
+        }
+        else {
+            printf("%s: %s\n", info->path, strerror(info->access_status));
+        }
 
-        if (libambit_device_supported(ambit_object)) {
-            printf("Device: %s, serial: %s, FW version: %d.%d.%d\n", info.name, info.serial, info.fw_version[0], info.fw_version[1], info.fw_version[2] | (info.fw_version[3] << 8));
+        ambit_object = libambit_new(info);
+        if (ambit_object) {
 
             if (libambit_device_status_get(ambit_object, &status) == 0) {
                 printf("Current charge: %d%%\n", status.charge);
@@ -42,16 +52,13 @@
             //}
 
             libambit_log_read(ambit_object, log_skip_cb, log_data_cb, NULL, ambit_object);
+            libambit_close(ambit_object);
         }
-        else {
-            printf("Device: %s (fw_version: %d.%d.%d) is not supported yet!\n", info.name, info.fw_version[0], info.fw_version[1], info.fw_version[2] | (info.fw_version[3] << 8));
-        }
-
-        libambit_close(ambit_object);
     }
     else {
         printf("No clock found, exiting\n");
     }
+    libambit_free_enumeration(info);
 
     return 0;
 }
diff -Nur -x debian -x .git -x .pc ./src/libambit/cmake/FindPCAP.cmake ../openambit.git/src/libambit/cmake/FindPCAP.cmake
--- ./src/libambit/cmake/FindPCAP.cmake	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/cmake/FindPCAP.cmake	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,74 @@
+# - Try to find libpcap include dirs and libraries
+#
+# Usage of this module as follows:
+#
+#     find_package(PCAP)
+#
+# Variables used by this module, they can change the default behaviour and need
+# to be set before calling find_package:
+#
+#  PCAP_ROOT_DIR             Set this variable to the root installation of
+#                            libpcap if the module has problems finding the
+#                            proper installation path.
+#
+# Variables defined by this module:
+#
+#  PCAP_FOUND                System has libpcap, include and library dirs found
+#  PCAP_INCLUDE_DIR          The libpcap include directories.
+#  PCAP_LIBRARY              The libpcap library (possibly includes a thread
+#                            library e.g. required by pf_ring's libpcap)
+#  HAVE_PF_RING              If a found version of libpcap supports PF_RING
+
+find_path(PCAP_ROOT_DIR
+    NAMES include/pcap.h
+)
+
+find_path(PCAP_INCLUDE_DIR
+    NAMES pcap.h
+    HINTS ${PCAP_ROOT_DIR}/include
+)
+
+find_library(PCAP_LIBRARY
+    NAMES pcap
+    HINTS ${PCAP_ROOT_DIR}/lib
+)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(PCAP DEFAULT_MSG
+    PCAP_LIBRARY
+    PCAP_INCLUDE_DIR
+)
+
+include(CheckCSourceCompiles)
+set(CMAKE_REQUIRED_LIBRARIES ${PCAP_LIBRARY})
+check_c_source_compiles("int main() { return 0; }" PCAP_LINKS_SOLO)
+set(CMAKE_REQUIRED_LIBRARIES)
+
+# check if linking against libpcap also needs to link against a thread library
+if (NOT PCAP_LINKS_SOLO)
+    find_package(Threads)
+    if (THREADS_FOUND)
+        set(CMAKE_REQUIRED_LIBRARIES ${PCAP_LIBRARY} ${CMAKE_THREAD_LIBS_INIT})
+        check_c_source_compiles("int main() { return 0; }" PCAP_NEEDS_THREADS)
+        set(CMAKE_REQUIRED_LIBRARIES)
+    endif ()
+    if (THREADS_FOUND AND PCAP_NEEDS_THREADS)
+        set(_tmp ${PCAP_LIBRARY} ${CMAKE_THREAD_LIBS_INIT})
+        list(REMOVE_DUPLICATES _tmp)
+        set(PCAP_LIBRARY ${_tmp}
+            CACHE STRING "Libraries needed to link against libpcap" FORCE)
+    else ()
+        message(FATAL_ERROR "Couldn't determine how to link against libpcap")
+    endif ()
+endif ()
+
+include(CheckFunctionExists)
+set(CMAKE_REQUIRED_LIBRARIES ${PCAP_LIBRARY})
+check_function_exists(pcap_get_pfring_id HAVE_PF_RING)
+set(CMAKE_REQUIRED_LIBRARIES)
+
+mark_as_advanced(
+    PCAP_ROOT_DIR
+    PCAP_INCLUDE_DIR
+    PCAP_LIBRARY
+)
diff -Nur -x debian -x .git -x .pc ./src/libambit/cmake/HidapiDriver.cmake ../openambit.git/src/libambit/cmake/HidapiDriver.cmake
--- ./src/libambit/cmake/HidapiDriver.cmake	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/cmake/HidapiDriver.cmake	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,30 @@
+# - Resolve what hidapi driver to use
+# This module is affected by the following defines
+#  HIDAPI_DRIVER (possible values: usbraw, libusb, pcapsimulate)
+#
+# This module defines
+#  HIDAPI_INCLUDE_DIR
+#  HIDAPI_SOURCE_FILES
+#  HIDAPI_LIBS
+
+if (NOT HIDAPI_RESOLVED)
+    if (HIDAPI_DRIVER STREQUAL "libusb")
+        find_package(libusb REQUIRED)
+        set (HIDAPI_INCLUDE_DIR "hidapi" ${LIBUSB_INCLUDE_DIR})
+        set (HIDAPI_SOURCE_FILES "hidapi/hid-libusb.c")
+        set (HIDAPI_LIBS ${LIBUSB_LIBRARIES})
+    elseif (HIDAPI_DRIVER STREQUAL "pcapsimulate")
+        find_package(PCAP REQUIRED)
+        set (HIDAPI_INCLUDE_DIR "hidapi" ${PCAP_INCLUDE_DIR})
+        set (HIDAPI_SOURCE_FILES "hidapi/hid-pcapsimulate.c")
+        set (HIDAPI_LIBS ${PCAP_LIBRARY})
+    else (HIDAPI_DRIVER STREQUAL "libusb")
+        find_package(UDev REQUIRED)
+        set (HIDAPI_INCLUDE_DIR "hidapi" ${UDEV_INCLUDE_DIR})
+        set (HIDAPI_SOURCE_FILES "hidapi/hid-linux.c")
+        set (HIDAPI_LIBS ${UDEV_LIBS})
+    endif (HIDAPI_DRIVER STREQUAL "libusb")
+
+    mark_as_advanced(HIDAPI_INCLUDE_DIR HIDAPI_SOURCE_FILES HIDAPI_LIBS)
+    set (HIDAPI_RESOLVED TRUE)
+endif (NOT HIDAPI_RESOLVED)
diff -Nur -x debian -x .git -x .pc ./src/libambit/CMakeLists.txt ../openambit.git/src/libambit/CMakeLists.txt
--- ./src/libambit/CMakeLists.txt	2014-09-17 21:28:00.560501284 +0200
+++ ../openambit.git/src/libambit/CMakeLists.txt	2014-11-05 21:53:14.541131599 +0100
@@ -15,8 +15,7 @@
   set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -DDEBUG_PRINT_FILE_LINE=${DEBUG_PRINT_FILE_LINE}")
 ENDIF()
 
-find_package(libusb REQUIRED)
-find_package(UDev REQUIRED)
+include(HidapiDriver)
 include(GNUInstallDirs)
 
 add_library (
@@ -24,24 +23,28 @@
   SHARED
   crc16.c
   debug.c
-  hid.c
+  device_driver_ambit.c
+  device_driver_common.c
+  device_support.c
   libambit.c
   personal.c
   pmem20.c
   protocol.c
+  sha256.c
+  utils.c
+  ${HIDAPI_SOURCE_FILES}
 )
 
 target_link_libraries(
   ambit
-  ${UDEV_LIBS}
-  ${LIBUSB_LIBRARIES}
+  ${HIDAPI_LIBS}
   m
 )
 
 set_target_properties(ambit PROPERTIES VERSION 0.3.0 SOVERSION 0)
 
 include_directories(
-  hidapi
+  ${HIDAPI_INCLUDE_DIR}
 )
 
 install(TARGETS ambit DESTINATION ${CMAKE_INSTALL_LIBDIR})
diff -Nur -x debian -x .git -x .pc ./src/libambit/crc16.c ../openambit.git/src/libambit/crc16.c
--- ./src/libambit/crc16.c	2014-09-17 21:24:42.950329917 +0200
+++ ../openambit.git/src/libambit/crc16.c	2014-11-05 21:53:14.541131599 +0100
@@ -18,7 +18,7 @@
 /*                                                               */
 /*****************************************************************/
 
-#include "libambit_int.h"
+#include "crc16.h"
 
 static uint16_t crctable[256] =
 {
diff -Nur -x debian -x .git -x .pc ./src/libambit/crc16.h ../openambit.git/src/libambit/crc16.h
--- ./src/libambit/crc16.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/crc16.h	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,31 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __CRC16_H__
+#define __CRC16_H__
+
+#include <stddef.h>
+#include <stdint.h>
+
+uint16_t crc16_ccitt_false(unsigned char *buf, size_t buflen);
+uint16_t crc16_ccitt_false_init(unsigned char *buf, size_t buflen, uint16_t crc);
+
+#endif /* __CRC16_H__ */
diff -Nur -x debian -x .git -x .pc ./src/libambit/debug.c ../openambit.git/src/libambit/debug.c
--- ./src/libambit/debug.c	2014-09-17 21:24:42.966329637 +0200
+++ ../openambit.git/src/libambit/debug.c	2014-11-05 21:53:14.541131599 +0100
@@ -19,8 +19,7 @@
  * Contributors:
  *
  */
-#include "libambit.h"
-#include "libambit_int.h"
+#include "debug.h"
 
 #include <stdarg.h>
 #include <stdio.h>
diff -Nur -x debian -x .git -x .pc ./src/libambit/debug.h ../openambit.git/src/libambit/debug.h
--- ./src/libambit/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/debug.h	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+#include <stddef.h>
+#include <stdint.h>
+
+typedef enum debug_level_e {
+    debug_level_err,
+    debug_level_warn,
+    debug_level_info
+} debug_level_t;
+
+void debug_printf(debug_level_t level, const char *file, int line, const char *func, const char *fmt, ...);
+
+#ifdef DEBUG_PRINT_ERROR
+#define LOG_ERROR(fmt, ...) debug_printf(debug_level_err, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
+#else
+#define LOG_ERROR(fmt, ...)
+#endif
+#ifdef DEBUG_PRINT_WARNING
+#define LOG_WARNING(fmt, ...) debug_printf(debug_level_warn, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
+#else
+#define LOG_WARNING(fmt, ...)
+#endif
+#ifdef DEBUG_PRINT_INFO
+#define LOG_INFO(fmt, ...) debug_printf(debug_level_info, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
+#else
+#define LOG_INFO(fmt, ...)
+#endif
+
+#endif /* __DEBUG_H__ */
diff -Nur -x debian -x .git -x .pc ./src/libambit/device_driver_ambit.c ../openambit.git/src/libambit/device_driver_ambit.c
--- ./src/libambit/device_driver_ambit.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_driver_ambit.c	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,298 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include "device_driver.h"
+#include "device_driver_common.h"
+#include "libambit_int.h"
+#include "protocol.h"
+#include "pmem20.h"
+#include "personal.h"
+#include "debug.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+/*
+ * Local definitions
+ */
+#define PMEM20_LOG_START                  0x000f4240
+#define PMEM20_LOG_SIZE                   0x0029f630 /* 2 750 000 */
+
+struct ambit_device_driver_data_s {
+    libambit_pmem20_t pmem20;
+};
+
+/*
+ * Static functions
+ */
+static void init(ambit_object_t *object, uint32_t driver_param);
+static void deinit(ambit_object_t *object);
+static int personal_settings_get(ambit_object_t *object, ambit_personal_settings_t *settings);
+static int log_read(ambit_object_t *object, ambit_log_skip_cb skip_cb, ambit_log_push_cb push_cb, ambit_log_progress_cb progress_cb, void *userref);
+static int gps_orbit_header_read(ambit_object_t *object, uint8_t data[8]);
+static int gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen);
+
+/*
+ * Global variables
+ */
+ambit_device_driver_t ambit_device_driver_ambit = {
+    init,
+    deinit,
+    libambit_device_driver_lock_log,
+    libambit_device_driver_date_time_set,
+    libambit_device_driver_status_get,
+    personal_settings_get,
+    log_read,
+    gps_orbit_header_read,
+    gps_orbit_write
+};
+
+/*
+ * Static functions implementation
+ */
+/**
+ * Init function
+ * \param object to initialize
+ * \param driver_param PMEM20 chunk size
+ */
+static void init(ambit_object_t *object, uint32_t driver_param)
+{
+    struct ambit_device_driver_data_s *data;
+
+    if ((data = calloc(1, sizeof(struct ambit_device_driver_data_s))) != NULL) {
+        object->driver_data = data;
+        libambit_pmem20_init(&object->driver_data->pmem20, object, driver_param);
+    }
+}
+
+static void deinit(ambit_object_t *object)
+{
+    if (object->driver_data != NULL) {
+        libambit_pmem20_deinit(&object->driver_data->pmem20);
+    }
+}
+
+static int personal_settings_get(ambit_object_t *object, ambit_personal_settings_t *settings)
+{
+    uint8_t *reply_data = NULL;
+    size_t replylen = 0;
+    int ret = -1;
+
+    LOG_INFO("Reading personal settings");
+
+    if (libambit_protocol_command(object, ambit_command_personal_settings, NULL, 0, &reply_data, &replylen, 0) == 0) {
+        ret = libambit_personal_settings_parse(reply_data, replylen, settings);
+        libambit_protocol_free(reply_data);
+    }
+    else {
+        LOG_WARNING("Failed to read personal settings");
+    }
+
+    return ret;
+}
+
+static int log_read(ambit_object_t *object, ambit_log_skip_cb skip_cb, ambit_log_push_cb push_cb, ambit_log_progress_cb progress_cb, void *userref)
+{
+    int entries_read = 0;
+
+    uint8_t *reply_data = NULL;
+    size_t replylen = 0;
+    uint16_t log_entries_total = 0;
+    uint16_t log_entries_walked = 0;
+
+    uint32_t more = 0x00000400;
+
+    bool read_pmem = false;
+
+    ambit_log_header_t log_header;
+    ambit_log_entry_t *log_entry;
+
+    LOG_INFO("Reading number of logs");
+
+    /*
+     * Read number of log entries
+     */
+    if (libambit_protocol_command(object, ambit_command_log_count, NULL, 0, &reply_data, &replylen, 0) != 0) {
+        LOG_WARNING("Failed to read number of log entries");
+        return -1;
+    }
+    log_entries_total = le16toh(*(uint16_t*)(reply_data + 2));
+    libambit_protocol_free(reply_data);
+
+    LOG_INFO("Number of logs=%d", log_entries_total);
+
+    /*
+     * First part walks through headers to check if there is any point in start
+     * reading the PMEM content. If no skip callback is defined, there is no
+     * point in checking the headers, because no one can tell us to not include
+     * the logs...
+     */
+
+    if (skip_cb != NULL) {
+        LOG_INFO("Look in headers for new logs");
+        // Rewind
+        if (libambit_protocol_command(object, ambit_command_log_head_first, NULL, 0, &reply_data, &replylen, 0) != 0) {
+            LOG_WARNING("Failed to rewind header pointer");
+            return -1;
+        }
+        more = le32toh(*(uint32_t*)reply_data);
+        libambit_protocol_free(reply_data);
+
+        // Loop through logs while more entries exists
+        while (more == 0x00000400) {
+            LOG_INFO("Reading next header");
+            // Go to next entry
+            if (libambit_protocol_command(object, ambit_command_log_head_step, NULL, 0, &reply_data, &replylen, 0) != 0) {
+                LOG_WARNING("Failed to walk to next header");
+                return -1;
+            }
+            libambit_protocol_free(reply_data);
+
+            // Assume every header is composited by 2 parts, where only the
+            // second is of interrest right now
+            if (libambit_protocol_command(object, ambit_command_log_head, NULL, 0, &reply_data, &replylen, 0) != 0) {
+                LOG_WARNING("Failed to read first part of header");
+                return -1;
+            }
+            libambit_protocol_free(reply_data);
+
+            if (libambit_protocol_command(object, ambit_command_log_head, NULL, 0, &reply_data, &replylen, 0) == 0) {
+                if (replylen > 8 && libambit_pmem20_log_parse_header(reply_data + 8, replylen - 8, &log_header) == 0) {
+                    if (skip_cb(userref, &log_header) != 0) {
+                        // Header was NOT skipped, break out!
+                        read_pmem = true;
+                        LOG_INFO("Found new entry, start reading log data");
+                        break;
+                    }
+                }
+                else {
+                    LOG_ERROR("Failed to parse log header");
+                    return -1;
+                }
+                libambit_protocol_free(reply_data);
+            }
+            else {
+                LOG_WARNING("Failed to read second part of header");
+                return -1;
+            }
+
+            // Is there more entries to read?
+            if (libambit_protocol_command(object, ambit_command_log_head_peek, NULL, 0, &reply_data, &replylen, 0) != 0) {
+                LOG_WARNING("Failed to check for more headers");
+                return -1;
+            }
+            more = le32toh(*(uint32_t*)reply_data);
+            libambit_protocol_free(reply_data);
+        }
+    }
+    else {
+        LOG_INFO("No skip callback defined, reading log data");
+        read_pmem = true;
+    }
+
+    if (read_pmem) {
+        if (libambit_pmem20_log_init(&object->driver_data->pmem20, PMEM20_LOG_START, PMEM20_LOG_SIZE) != 0) {
+            return -1;
+        }
+
+        // Loop through all log entries, first check headers
+        while (log_entries_walked < log_entries_total && libambit_pmem20_log_next_header(&object->driver_data->pmem20, &log_header) == 1) {
+            LOG_INFO("Reading header of log %d of %d", log_entries_walked + 1, log_entries_total);
+            if (progress_cb != NULL) {
+                progress_cb(userref, log_entries_total, log_entries_walked+1, 100*log_entries_walked/log_entries_total);
+            }
+            // Check if this entry needs to be read
+            if (skip_cb == NULL || skip_cb(userref, &log_header) != 0) {
+                LOG_INFO("Reading data of log %d of %d", log_entries_walked + 1, log_entries_total);
+                log_entry = libambit_pmem20_log_read_entry(&object->driver_data->pmem20);
+                if (log_entry != NULL) {
+                    if (push_cb != NULL) {
+                        push_cb(userref, log_entry);
+                    }
+                    entries_read++;
+                }
+            }
+            else {
+                LOG_INFO("Log %d of %d already exists, skip reading data", log_entries_walked + 1, log_entries_total);
+            }
+            log_entries_walked++;
+            if (progress_cb != NULL) {
+                progress_cb(userref, log_entries_total, log_entries_walked, 100*log_entries_walked/log_entries_total);
+            }
+        }
+    }
+
+    LOG_INFO("%d entries read", entries_read);
+
+    return entries_read;
+}
+
+static int gps_orbit_header_read(ambit_object_t *object, uint8_t data[8])
+{
+    uint8_t *reply_data = NULL;
+    size_t replylen = 0;
+    int ret = -1;
+
+    if (libambit_protocol_command(object, ambit_command_gps_orbit_head, NULL, 0, &reply_data, &replylen, 0) == 0 && replylen >= 9) {
+        memcpy(data, &reply_data[1], 8);
+        libambit_protocol_free(reply_data);
+
+        ret = 0;
+    }
+    else {
+        LOG_WARNING("Failed to read GPS orbit header");
+    }
+
+    return ret;
+}
+
+static int gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen)
+{
+    uint8_t header[8], cmpheader[8];
+    int ret = -1;
+
+    LOG_INFO("Writing GPS orbit data");
+
+    libambit_protocol_command(object, ambit_command_write_start, NULL, 0, NULL, NULL, 0);
+
+    if (object->driver->gps_orbit_header_read(object, header) == 0) {
+        cmpheader[0] = data[7]; // Year, swap bytes
+        cmpheader[1] = data[6];
+        cmpheader[2] = data[8];
+        cmpheader[3] = data[9];
+        cmpheader[4] = data[13]; // 4 byte swap
+        cmpheader[5] = data[12];
+        cmpheader[6] = data[11];
+        cmpheader[7] = data[10];
+
+        // Check if new data differs 
+        if (memcmp(header, cmpheader, 8) != 0) {
+            ret = libambit_pmem20_gps_orbit_write(&object->driver_data->pmem20, data, datalen, false);
+        }
+        else {
+            LOG_INFO("Current GPS orbit data is already up to date, skipping");
+            ret = 0;
+        }
+    }
+
+    return ret;
+}
+
diff -Nur -x debian -x .git -x .pc ./src/libambit/device_driver_common.c ../openambit.git/src/libambit/device_driver_common.c
--- ./src/libambit/device_driver_common.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_driver_common.c	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,124 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include "device_driver_common.h"
+#include "protocol.h"
+#include "debug.h"
+
+#include <stdlib.h>
+
+/*
+ * Local definitions
+ */
+
+/*
+ * Static functions
+ */
+
+/*
+ * Public functions
+ */
+int libambit_device_driver_lock_log(ambit_object_t *object, bool lock)
+{
+    int ret = -1;
+    uint8_t send_data[] = { 0x00, 0x00, 0x00, 0x00 };
+    uint8_t *reply_data = NULL;
+    size_t replylen;
+
+    uint32_t current_lock = 0xffffffff;
+
+    if ((ret = libambit_protocol_command(object, ambit_command_lock_check, NULL, 0, &reply_data, &replylen, 0)) == 0) {
+        current_lock = le32toh(*(uint32_t*)reply_data);
+        libambit_protocol_free(reply_data);
+    }
+
+    if (lock && current_lock == 0) {
+        LOG_INFO("Setting Sync message to device display");
+        send_data[0] = 1;
+        ret = libambit_protocol_command(object, ambit_command_lock_set, send_data, sizeof(send_data), &reply_data, &replylen, 0);
+        libambit_protocol_free(reply_data);
+    }
+    else if (!lock && current_lock == 1) {
+        LOG_INFO("Clearing Sync message to device display");
+        send_data[0] = 0;
+        ret = libambit_protocol_command(object, ambit_command_lock_set, send_data, sizeof(send_data), &reply_data, &replylen, 0);
+        libambit_protocol_free(reply_data);
+    }
+
+    return ret;
+}
+
+int libambit_device_driver_date_time_set(ambit_object_t *object, struct tm *tm)
+{
+    uint8_t date_data[8] = { 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00 };
+    uint8_t time_data[8];
+    int ret = -1;
+
+    LOG_INFO("Writing date and time to clock");
+
+    // Set date
+    *(uint16_t*)(&date_data[0]) = htole16(1900 + tm->tm_year);
+    date_data[2] = 1 + tm->tm_mon;
+    date_data[3] = tm->tm_mday;
+    // byte[4-7] unknown (but set to 0x28000000 in moveslink)
+
+    // Set time (+date)
+    *(uint16_t*)(&time_data[0]) = htole16(1900 + tm->tm_year);
+    time_data[2] = 1 + tm->tm_mon;
+    time_data[3] = tm->tm_mday;
+    time_data[4] = tm->tm_hour;
+    time_data[5] = tm->tm_min;
+    *(uint16_t*)(&time_data[6]) = htole16(1000*tm->tm_sec);
+
+    if (libambit_protocol_command(object, ambit_command_date, date_data, sizeof(date_data), NULL, NULL, 0) == 0 &&
+        libambit_protocol_command(object, ambit_command_time, time_data, sizeof(time_data), NULL, NULL, 0) == 0) {
+
+        ret = 0;
+    }
+    else {
+        LOG_WARNING("Failed to write date and time");
+    }
+
+    return ret;
+}
+
+int libambit_device_driver_status_get(ambit_object_t *object, ambit_device_status_t *status)
+{
+    uint8_t *reply_data = NULL;
+    size_t replylen;
+    int ret = -1;
+
+    LOG_INFO("Reading device status");
+
+    if (libambit_protocol_command(object, ambit_command_status, NULL, 0, &reply_data, &replylen, 0) == 0) {
+        if (status != NULL) {
+            status->charge = reply_data[1];
+        }
+        ret = 0;
+    }
+    else {
+        LOG_WARNING("Failed to read device status");
+    }
+
+    libambit_protocol_free(reply_data);
+
+    return ret;
+}
diff -Nur -x debian -x .git -x .pc ./src/libambit/device_driver_common.h ../openambit.git/src/libambit/device_driver_common.h
--- ./src/libambit/device_driver_common.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_driver_common.h	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,36 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __DEVICE_DRIVER_COMMON_H__
+#define __DEVICE_DRIVER_COMMON_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <time.h>
+
+#include "libambit.h"
+
+int libambit_device_driver_lock_log(ambit_object_t *object, bool lock);
+int libambit_device_driver_date_time_set(ambit_object_t *object, struct tm *tm);
+int libambit_device_driver_status_get(ambit_object_t *object, ambit_device_status_t *status);
+
+#endif /* DEVICE_DRIVER_COMMON */
diff -Nur -x debian -x .git -x .pc ./src/libambit/device_driver.h ../openambit.git/src/libambit/device_driver.h
--- ./src/libambit/device_driver.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_driver.h	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,44 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __DEVICE_DRIVER_H__
+#define __DEVICE_DRIVER_H__
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "libambit.h"
+
+typedef struct ambit_device_driver_s {
+    void (*init)(ambit_object_t *object, uint32_t driver_param);
+    void (*deinit)(ambit_object_t *object);
+    int (*lock_log)(ambit_object_t *object, bool lock);
+    int (*date_time_set)(ambit_object_t *object, struct tm *tm);
+    int (*status_get)(ambit_object_t *object, ambit_device_status_t *status);
+    int (*personal_settings_get)(ambit_object_t *object, ambit_personal_settings_t *settings);
+    int (*log_read)(ambit_object_t *object, ambit_log_skip_cb skip_cb, ambit_log_push_cb push_cb, ambit_log_progress_cb progress_cb, void *userref);
+    int (*gps_orbit_header_read)(ambit_object_t *object, uint8_t data[8]);
+    int (*gps_orbit_write)(ambit_object_t *object, uint8_t *data, size_t datalen);
+} ambit_device_driver_t;
+
+extern ambit_device_driver_t ambit_device_driver_ambit; // Ambit & Ambit2
+
+#endif /* __DEVICE_DRIVER_H__ */
diff -Nur -x debian -x .git -x .pc ./src/libambit/device_support.c ../openambit.git/src/libambit/device_support.c
--- ./src/libambit/device_support.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_support.c	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,105 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include "device_support.h"
+#include "device_driver.h"
+
+#include <string.h>
+
+/*
+ * Local definitions
+ */
+#define SUUNTO_USB_VENDOR_ID 0x1493
+
+typedef struct int_known_device_s {
+    uint16_t vid;
+    uint16_t pid;
+    char *model;
+    uint8_t min_sw_version[4];
+    ambit_known_device_t public_info;
+} int_known_device_t;
+
+/*
+ * Static functions
+ */
+static uint32_t version_number(const uint8_t version[4]);
+
+/*
+ * Static variables
+ */
+static int_known_device_t known_devices[] = {
+    { SUUNTO_USB_VENDOR_ID, 0x001c, "Finch", {0x00,0x00,0x00,0x00}, { "Suunto Ambit3 Sport", false, NULL, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x001b, "Emu", {0x00,0x00,0x00,0x00}, { "Suunto Ambit3 Peak", false, NULL, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x001d, "Greentit", {0x00,0x00,0x00,0x00}, { "Suunto Ambit2 R", true, &ambit_device_driver_ambit, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x01,0x01,0x02,0x00}, { "Suunto Ambit2 S", true, &ambit_device_driver_ambit, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x01,0x01,0x02,0x00}, { "Suunto Ambit2", true, &ambit_device_driver_ambit, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x00,0x02,0x03,0x00}, { "Suunto Ambit2 S", false, NULL, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x00,0x02,0x03,0x00}, { "Suunto Ambit2", false, NULL, 0x0400 } },
+    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x00,0x02,0x02,0x00}, { "Suunto Ambit2 S (up to 0.2.2)", false, NULL, 0x0200 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x00,0x02,0x02,0x00}, { "Suunto Ambit2 (up to 0.2.2)", false, NULL, 0x0200 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x02,0x01,0x00,0x00}, { "Suunto Ambit", true, &ambit_device_driver_ambit, 0x0200 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x09,0x00,0x00}, { "Suunto Ambit", false, NULL, 0x0200 } }, /* First with PMEM 2.0!? */
+    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x06,0x00,0x00}, { "Suunto Ambit", false, NULL, 0 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x01,0x00,0x00}, { "Suunto Ambit", false, NULL, 0 } },
+    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x00,0x00,0x00,0x00}, { "Suunto Ambit", false, NULL, 0 } },
+    { 0x0000, 0x0000, NULL, {0x00,0x00,0x00,0x00}, { NULL, false, NULL, 0 } }
+};
+
+bool libambit_device_support_known(uint16_t vendor_id, uint16_t product_id)
+{
+    int i;
+
+    for (i=0; i<sizeof(known_devices)/sizeof(known_devices[0]); i++) {
+        if (vendor_id == known_devices[i].vid && product_id == known_devices[i].pid) {
+            // Found at least one row with the correct device
+            return true;
+        }
+    }
+
+    return false;
+}
+
+const ambit_known_device_t *libambit_device_support_find(uint16_t vendor_id, uint16_t product_id, const char *model, const uint8_t *fw_version)
+{
+    ambit_known_device_t *device;
+    int i;
+
+    for (i=0; i<sizeof(known_devices)/sizeof(known_devices[0]); i++) {
+        if (vendor_id == known_devices[i].vid &&
+            product_id == known_devices[i].pid &&
+            strncmp(model, known_devices[i].model, LIBAMBIT_MODEL_NAME_LENGTH) == 0 &&
+            (version_number (fw_version) >= version_number (known_devices[i].min_sw_version))) {
+            // Found matching entry, reset to this one!
+            device = &known_devices[i].public_info;
+            break;
+        }
+    }
+
+    return device;
+}
+
+static uint32_t version_number(const uint8_t version[4])
+{
+    return (  (version[0] << 24)
+            | (version[1] << 16)
+            | (version[2] <<  0)
+            | (version[3] <<  8));
+}
diff -Nur -x debian -x .git -x .pc ./src/libambit/device_support.h ../openambit.git/src/libambit/device_support.h
--- ./src/libambit/device_support.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/device_support.h	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,39 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __DEVICE_SUPPORT_H__
+#define __DEVICE_SUPPORT_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+typedef struct ambit_known_device_s {
+    char *name;
+    bool supported;
+    struct ambit_device_driver_s *driver;
+    uint32_t driver_param;
+} ambit_known_device_t;
+
+bool libambit_device_support_known(uint16_t vendor_id, uint16_t product_id);
+const ambit_known_device_t *libambit_device_support_find(uint16_t vendor_id, uint16_t product_id, const char *model, const uint8_t *fw_version);
+
+#endif /* __DEVICE_SUPPORT_H__ */
diff -Nur -x debian -x .git -x .pc ./src/libambit/hidapi/hid-libusb.c ../openambit.git/src/libambit/hidapi/hid-libusb.c
--- ./src/libambit/hidapi/hid-libusb.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/hidapi/hid-libusb.c	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,1427 @@
+/*******************************************************
+ HIDAPI - Multi-Platform library for
+ communication with HID devices.
+
+ Alan Ott
+ Signal 11 Software
+
+ 8/22/2009
+ Linux Version - 6/2/2010
+ Libusb Version - 8/13/2010
+ FreeBSD Version - 11/1/2011
+
+ Copyright 2009, All Rights Reserved.
+
+ At the discretion of the user of this library,
+ this software may be licensed under the terms of the
+ GNU General Public License v3, a BSD-Style license, or the
+ original HIDAPI license as outlined in the LICENSE.txt,
+ LICENSE-gpl3.txt, LICENSE-bsd.txt, and LICENSE-orig.txt
+ files located at the root of the source distribution.
+ These files may also be found in the public source
+ code repository located at:
+        http://github.com/signal11/hidapi .
+********************************************************/
+
+#define _GNU_SOURCE /* needed for wcsdup() before glibc 2.10 */
+
+/* C */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <locale.h>
+#include <errno.h>
+
+/* Unix */
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/utsname.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <wchar.h>
+
+/* GNU / LibUSB */
+#include "libusb.h"
+#include "iconv.h"
+
+#include "hidapi.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef DEBUG_PRINTF
+#define LOG(...) fprintf(stderr, __VA_ARGS__)
+#else
+#define LOG(...) do {} while (0)
+#endif
+
+#ifndef __FreeBSD__
+#define DETACH_KERNEL_DRIVER
+#endif
+
+/* Uncomment to enable the retrieval of Usage and Usage Page in
+hid_enumerate(). Warning, on platforms different from FreeBSD
+this is very invasive as it requires the detach
+and re-attach of the kernel driver. See comments inside hid_enumerate().
+libusb HIDAPI programs are encouraged to use the interface number
+instead to differentiate between interfaces on a composite HID device. */
+/*#define INVASIVE_GET_USAGE*/
+
+/* Linked List of input reports received from the device. */
+struct input_report {
+	uint8_t *data;
+	size_t len;
+	struct input_report *next;
+};
+
+
+struct hid_device_ {
+	/* Handle to the actual device. */
+	libusb_device_handle *device_handle;
+
+	/* Endpoint information */
+	int input_endpoint;
+	int output_endpoint;
+	int input_ep_max_packet_size;
+
+	/* The interface number of the HID */
+	int interface;
+
+	/* Indexes of Strings */
+	int manufacturer_index;
+	int product_index;
+	int serial_index;
+
+	/* Whether blocking reads are used */
+	int blocking; /* boolean */
+
+	/* Read thread objects */
+	pthread_t thread;
+	pthread_mutex_t mutex; /* Protects input_reports */
+	pthread_cond_t condition;
+	pthread_barrier_t barrier; /* Ensures correct startup sequence */
+	int shutdown_thread;
+	int cancelled;
+	struct libusb_transfer *transfer;
+
+	/* List of received input reports. */
+	struct input_report *input_reports;
+};
+
+static libusb_context *usb_context = NULL;
+
+uint16_t get_usb_code_for_current_locale(void);
+static int return_data(hid_device *dev, unsigned char *data, size_t length);
+
+static hid_device *new_hid_device(void)
+{
+	hid_device *dev = calloc(1, sizeof(hid_device));
+	dev->blocking = 1;
+
+	pthread_mutex_init(&dev->mutex, NULL);
+	pthread_cond_init(&dev->condition, NULL);
+	pthread_barrier_init(&dev->barrier, NULL, 2);
+
+	return dev;
+}
+
+static void free_hid_device(hid_device *dev)
+{
+	/* Clean up the thread objects */
+	pthread_barrier_destroy(&dev->barrier);
+	pthread_cond_destroy(&dev->condition);
+	pthread_mutex_destroy(&dev->mutex);
+
+	/* Free the device itself */
+	free(dev);
+}
+
+#if 0
+/*TODO: Implement this funciton on hidapi/libusb.. */
+static void register_error(hid_device *device, const char *op)
+{
+
+}
+#endif
+
+#ifdef INVASIVE_GET_USAGE
+/* Get bytes from a HID Report Descriptor.
+   Only call with a num_bytes of 0, 1, 2, or 4. */
+static uint32_t get_bytes(uint8_t *rpt, size_t len, size_t num_bytes, size_t cur)
+{
+	/* Return if there aren't enough bytes. */
+	if (cur + num_bytes >= len)
+		return 0;
+
+	if (num_bytes == 0)
+		return 0;
+	else if (num_bytes == 1) {
+		return rpt[cur+1];
+	}
+	else if (num_bytes == 2) {
+		return (rpt[cur+2] * 256 + rpt[cur+1]);
+	}
+	else if (num_bytes == 4) {
+		return (rpt[cur+4] * 0x01000000 +
+		        rpt[cur+3] * 0x00010000 +
+		        rpt[cur+2] * 0x00000100 +
+		        rpt[cur+1] * 0x00000001);
+	}
+	else
+		return 0;
+}
+
+/* Retrieves the device's Usage Page and Usage from the report
+   descriptor. The algorithm is simple, as it just returns the first
+   Usage and Usage Page that it finds in the descriptor.
+   The return value is 0 on success and -1 on failure. */
+static int get_usage(uint8_t *report_descriptor, size_t size,
+                     unsigned short *usage_page, unsigned short *usage)
+{
+	unsigned int i = 0;
+	int size_code;
+	int data_len, key_size;
+	int usage_found = 0, usage_page_found = 0;
+
+	while (i < size) {
+		int key = report_descriptor[i];
+		int key_cmd = key & 0xfc;
+
+		//printf("key: %02hhx\n", key);
+
+		if ((key & 0xf0) == 0xf0) {
+			/* This is a Long Item. The next byte contains the
+			   length of the data section (value) for this key.
+			   See the HID specification, version 1.11, section
+			   6.2.2.3, titled "Long Items." */
+			if (i+1 < size)
+				data_len = report_descriptor[i+1];
+			else
+				data_len = 0; /* malformed report */
+			key_size = 3;
+		}
+		else {
+			/* This is a Short Item. The bottom two bits of the
+			   key contain the size code for the data section
+			   (value) for this key.  Refer to the HID
+			   specification, version 1.11, section 6.2.2.2,
+			   titled "Short Items." */
+			size_code = key & 0x3;
+			switch (size_code) {
+			case 0:
+			case 1:
+			case 2:
+				data_len = size_code;
+				break;
+			case 3:
+				data_len = 4;
+				break;
+			default:
+				/* Can't ever happen since size_code is & 0x3 */
+				data_len = 0;
+				break;
+			};
+			key_size = 1;
+		}
+
+		if (key_cmd == 0x4) {
+			*usage_page  = get_bytes(report_descriptor, size, data_len, i);
+			usage_page_found = 1;
+			//printf("Usage Page: %x\n", (uint32_t)*usage_page);
+		}
+		if (key_cmd == 0x8) {
+			*usage = get_bytes(report_descriptor, size, data_len, i);
+			usage_found = 1;
+			//printf("Usage: %x\n", (uint32_t)*usage);
+		}
+
+		if (usage_page_found && usage_found)
+			return 0; /* success */
+
+		/* Skip over this key and it's associated data */
+		i += data_len + key_size;
+	}
+
+	return -1; /* failure */
+}
+#endif /* INVASIVE_GET_USAGE */
+
+#ifdef __FreeBSD__
+/* The FreeBSD version of libusb doesn't have this funciton. In mainline
+   libusb, it's inlined in libusb.h. This function will bear a striking
+   resemblence to that one, because there's about one way to code it.
+
+   Note that the data parameter is Unicode in UTF-16LE encoding.
+   Return value is the number of bytes in data, or LIBUSB_ERROR_*.
+ */
+static inline int libusb_get_string_descriptor(libusb_device_handle *dev,
+	uint8_t descriptor_index, uint16_t lang_id,
+	unsigned char *data, int length)
+{
+	return libusb_control_transfer(dev,
+		LIBUSB_ENDPOINT_IN | 0x0, /* Endpoint 0 IN */
+		LIBUSB_REQUEST_GET_DESCRIPTOR,
+		(LIBUSB_DT_STRING << 8) | descriptor_index,
+		lang_id, data, (uint16_t) length, 1000);
+}
+
+#endif
+
+
+/* Get the first language the device says it reports. This comes from
+   USB string #0. */
+static uint16_t get_first_language(libusb_device_handle *dev)
+{
+	uint16_t buf[32];
+	int len;
+
+	/* Get the string from libusb. */
+	len = libusb_get_string_descriptor(dev,
+			0x0, /* String ID */
+			0x0, /* Language */
+			(unsigned char*)buf,
+			sizeof(buf));
+	if (len < 4)
+		return 0x0;
+
+	return buf[1]; /* First two bytes are len and descriptor type. */
+}
+
+static int is_language_supported(libusb_device_handle *dev, uint16_t lang)
+{
+	uint16_t buf[32];
+	int len;
+	int i;
+
+	/* Get the string from libusb. */
+	len = libusb_get_string_descriptor(dev,
+			0x0, /* String ID */
+			0x0, /* Language */
+			(unsigned char*)buf,
+			sizeof(buf));
+	if (len < 4)
+		return 0x0;
+
+
+	len /= 2; /* language IDs are two-bytes each. */
+	/* Start at index 1 because there are two bytes of protocol data. */
+	for (i = 1; i < len; i++) {
+		if (buf[i] == lang)
+			return 1;
+	}
+
+	return 0;
+}
+
+
+/* This function returns a newly allocated wide string containing the USB
+   device string numbered by the index. The returned string must be freed
+   by using free(). */
+static wchar_t *get_usb_string(libusb_device_handle *dev, uint8_t idx)
+{
+	char buf[512];
+	int len;
+	wchar_t *str = NULL;
+	wchar_t wbuf[256];
+
+	/* iconv variables */
+	iconv_t ic;
+	size_t inbytes;
+	size_t outbytes;
+	size_t res;
+#ifdef __FreeBSD__
+	const char *inptr;
+#else
+	char *inptr;
+#endif
+	char *outptr;
+
+	/* Determine which language to use. */
+	uint16_t lang;
+	lang = get_usb_code_for_current_locale();
+	if (!is_language_supported(dev, lang))
+		lang = get_first_language(dev);
+
+	/* Get the string from libusb. */
+	len = libusb_get_string_descriptor(dev,
+			idx,
+			lang,
+			(unsigned char*)buf,
+			sizeof(buf));
+	if (len < 0)
+		return NULL;
+
+	/* buf does not need to be explicitly NULL-terminated because
+	   it is only passed into iconv() which does not need it. */
+
+	/* Initialize iconv. */
+	ic = iconv_open("WCHAR_T", "UTF-16LE");
+	if (ic == (iconv_t)-1) {
+		LOG("iconv_open() failed\n");
+		return NULL;
+	}
+
+	/* Convert to native wchar_t (UTF-32 on glibc/BSD systems).
+	   Skip the first character (2-bytes). */
+	inptr = buf+2;
+	inbytes = len-2;
+	outptr = (char*) wbuf;
+	outbytes = sizeof(wbuf);
+	res = iconv(ic, &inptr, &inbytes, &outptr, &outbytes);
+	if (res == (size_t)-1) {
+		LOG("iconv() failed\n");
+		goto err;
+	}
+
+	/* Write the terminating NULL. */
+	wbuf[sizeof(wbuf)/sizeof(wbuf[0])-1] = 0x00000000;
+	if (outbytes >= sizeof(wbuf[0]))
+		*((wchar_t*)outptr) = 0x00000000;
+
+	/* Allocate and copy the string. */
+	str = wcsdup(wbuf);
+
+err:
+	iconv_close(ic);
+
+	return str;
+}
+
+static char *make_path(libusb_device *dev, int interface_number)
+{
+	char str[64];
+	snprintf(str, sizeof(str), "%04x:%04x:%02x",
+		libusb_get_bus_number(dev),
+		libusb_get_device_address(dev),
+		interface_number);
+	str[sizeof(str)-1] = '\0';
+
+	return strdup(str);
+}
+
+
+int HID_API_EXPORT hid_init(void)
+{
+	if (!usb_context) {
+		const char *locale;
+
+		/* Init Libusb */
+		if (libusb_init(&usb_context))
+			return -1;
+
+		/* Set the locale if it's not set. */
+		locale = setlocale(LC_CTYPE, NULL);
+		if (!locale)
+			setlocale(LC_CTYPE, "");
+	}
+
+	return 0;
+}
+
+int HID_API_EXPORT hid_exit(void)
+{
+	if (usb_context) {
+		libusb_exit(usb_context);
+		usb_context = NULL;
+	}
+
+	return 0;
+}
+
+struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id, unsigned short product_id)
+{
+	libusb_device **devs;
+	libusb_device *dev;
+	libusb_device_handle *handle;
+	ssize_t num_devs;
+	int i = 0;
+
+	struct hid_device_info *root = NULL; /* return object */
+	struct hid_device_info *cur_dev = NULL;
+
+	if(hid_init() < 0)
+		return NULL;
+
+	num_devs = libusb_get_device_list(usb_context, &devs);
+	if (num_devs < 0)
+		return NULL;
+	while ((dev = devs[i++]) != NULL) {
+		struct libusb_device_descriptor desc;
+		struct libusb_config_descriptor *conf_desc = NULL;
+		int j, k;
+		int interface_num = 0;
+
+		int res = libusb_get_device_descriptor(dev, &desc);
+		unsigned short dev_vid = desc.idVendor;
+		unsigned short dev_pid = desc.idProduct;
+
+		res = libusb_get_active_config_descriptor(dev, &conf_desc);
+		if (res < 0)
+			libusb_get_config_descriptor(dev, 0, &conf_desc);
+		if (conf_desc) {
+			for (j = 0; j < conf_desc->bNumInterfaces; j++) {
+				const struct libusb_interface *intf = &conf_desc->interface[j];
+				for (k = 0; k < intf->num_altsetting; k++) {
+					const struct libusb_interface_descriptor *intf_desc;
+					intf_desc = &intf->altsetting[k];
+					if (intf_desc->bInterfaceClass == LIBUSB_CLASS_HID) {
+						interface_num = intf_desc->bInterfaceNumber;
+
+						/* Check the VID/PID against the arguments */
+						if ((vendor_id == 0x0 || vendor_id == dev_vid) &&
+						    (product_id == 0x0 || product_id == dev_pid)) {
+							struct hid_device_info *tmp;
+
+							/* VID/PID match. Create the record. */
+							tmp = calloc(1, sizeof(struct hid_device_info));
+							if (cur_dev) {
+								cur_dev->next = tmp;
+							}
+							else {
+								root = tmp;
+							}
+							cur_dev = tmp;
+
+							/* Fill out the record */
+							cur_dev->next = NULL;
+							cur_dev->path = make_path(dev, interface_num);
+
+							res = libusb_open(dev, &handle);
+
+							if (res >= 0) {
+								/* Serial Number */
+								if (desc.iSerialNumber > 0)
+									cur_dev->serial_number =
+										get_usb_string(handle, desc.iSerialNumber);
+
+								/* Manufacturer and Product strings */
+								if (desc.iManufacturer > 0)
+									cur_dev->manufacturer_string =
+										get_usb_string(handle, desc.iManufacturer);
+								if (desc.iProduct > 0)
+									cur_dev->product_string =
+										get_usb_string(handle, desc.iProduct);
+
+#ifdef INVASIVE_GET_USAGE
+{
+							/*
+							This section is removed because it is too
+							invasive on the system. Getting a Usage Page
+							and Usage requires parsing the HID Report
+							descriptor. Getting a HID Report descriptor
+							involves claiming the interface. Claiming the
+							interface involves detaching the kernel driver.
+							Detaching the kernel driver is hard on the system
+							because it will unclaim interfaces (if another
+							app has them claimed) and the re-attachment of
+							the driver will sometimes change /dev entry names.
+							It is for these reasons that this section is
+							#if 0. For composite devices, use the interface
+							field in the hid_device_info struct to distinguish
+							between interfaces. */
+								unsigned char data[256];
+#ifdef DETACH_KERNEL_DRIVER
+								int detached = 0;
+								/* Usage Page and Usage */
+								res = libusb_kernel_driver_active(handle, interface_num);
+								if (res == 1) {
+									res = libusb_detach_kernel_driver(handle, interface_num);
+									if (res < 0)
+										LOG("Couldn't detach kernel driver, even though a kernel driver was attached.");
+									else
+										detached = 1;
+								}
+#endif
+								res = libusb_claim_interface(handle, interface_num);
+								if (res >= 0) {
+									/* Get the HID Report Descriptor. */
+									res = libusb_control_transfer(handle, LIBUSB_ENDPOINT_IN|LIBUSB_RECIPIENT_INTERFACE, LIBUSB_REQUEST_GET_DESCRIPTOR, (LIBUSB_DT_REPORT << 8)|interface_num, 0, data, sizeof(data), 5000);
+									if (res >= 0) {
+										unsigned short page=0, usage=0;
+										/* Parse the usage and usage page
+										   out of the report descriptor. */
+										get_usage(data, res,  &page, &usage);
+										cur_dev->usage_page = page;
+										cur_dev->usage = usage;
+									}
+									else
+										LOG("libusb_control_transfer() for getting the HID report failed with %d\n", res);
+
+									/* Release the interface */
+									res = libusb_release_interface(handle, interface_num);
+									if (res < 0)
+										LOG("Can't release the interface.\n");
+								}
+								else
+									LOG("Can't claim interface %d\n", res);
+#ifdef DETACH_KERNEL_DRIVER
+								/* Re-attach kernel driver if necessary. */
+								if (detached) {
+									res = libusb_attach_kernel_driver(handle, interface_num);
+									if (res < 0)
+										LOG("Couldn't re-attach kernel driver.\n");
+								}
+#endif
+}
+#endif /* INVASIVE_GET_USAGE */
+
+								libusb_close(handle);
+							}
+							/* VID/PID */
+							cur_dev->vendor_id = dev_vid;
+							cur_dev->product_id = dev_pid;
+
+							/* Release Number */
+							cur_dev->release_number = desc.bcdDevice;
+
+							/* Interface Number */
+							cur_dev->interface_number = interface_num;
+						}
+					}
+				} /* altsettings */
+			} /* interfaces */
+			libusb_free_config_descriptor(conf_desc);
+		}
+	}
+
+	libusb_free_device_list(devs, 1);
+
+	return root;
+}
+
+void  HID_API_EXPORT hid_free_enumeration(struct hid_device_info *devs)
+{
+	struct hid_device_info *d = devs;
+	while (d) {
+		struct hid_device_info *next = d->next;
+		free(d->path);
+		free(d->serial_number);
+		free(d->manufacturer_string);
+		free(d->product_string);
+		free(d);
+		d = next;
+	}
+}
+
+hid_device * hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number)
+{
+	struct hid_device_info *devs, *cur_dev;
+	const char *path_to_open = NULL;
+	hid_device *handle = NULL;
+
+	devs = hid_enumerate(vendor_id, product_id);
+	cur_dev = devs;
+	while (cur_dev) {
+		if (cur_dev->vendor_id == vendor_id &&
+		    cur_dev->product_id == product_id) {
+			if (serial_number) {
+				if (wcscmp(serial_number, cur_dev->serial_number) == 0) {
+					path_to_open = cur_dev->path;
+					break;
+				}
+			}
+			else {
+				path_to_open = cur_dev->path;
+				break;
+			}
+		}
+		cur_dev = cur_dev->next;
+	}
+
+	if (path_to_open) {
+		/* Open the device */
+		handle = hid_open_path(path_to_open);
+	}
+
+	hid_free_enumeration(devs);
+
+	return handle;
+}
+
+static void read_callback(struct libusb_transfer *transfer)
+{
+	hid_device *dev = transfer->user_data;
+	int res;
+
+	if (transfer->status == LIBUSB_TRANSFER_COMPLETED) {
+
+		struct input_report *rpt = malloc(sizeof(*rpt));
+		rpt->data = malloc(transfer->actual_length);
+		memcpy(rpt->data, transfer->buffer, transfer->actual_length);
+		rpt->len = transfer->actual_length;
+		rpt->next = NULL;
+
+		pthread_mutex_lock(&dev->mutex);
+
+		/* Attach the new report object to the end of the list. */
+		if (dev->input_reports == NULL) {
+			/* The list is empty. Put it at the root. */
+			dev->input_reports = rpt;
+			pthread_cond_signal(&dev->condition);
+		}
+		else {
+			/* Find the end of the list and attach. */
+			struct input_report *cur = dev->input_reports;
+			int num_queued = 0;
+			while (cur->next != NULL) {
+				cur = cur->next;
+				num_queued++;
+			}
+			cur->next = rpt;
+
+			/* Pop one off if we've reached 30 in the queue. This
+			   way we don't grow forever if the user never reads
+			   anything from the device. */
+			if (num_queued > 30) {
+				return_data(dev, NULL, 0);
+			}
+		}
+		pthread_mutex_unlock(&dev->mutex);
+	}
+	else if (transfer->status == LIBUSB_TRANSFER_CANCELLED) {
+		dev->shutdown_thread = 1;
+		dev->cancelled = 1;
+		return;
+	}
+	else if (transfer->status == LIBUSB_TRANSFER_NO_DEVICE) {
+		dev->shutdown_thread = 1;
+		dev->cancelled = 1;
+		return;
+	}
+	else if (transfer->status == LIBUSB_TRANSFER_TIMED_OUT) {
+		//LOG("Timeout (normal)\n");
+	}
+	else {
+		LOG("Unknown transfer code: %d\n", transfer->status);
+	}
+
+	/* Re-submit the transfer object. */
+	res = libusb_submit_transfer(transfer);
+	if (res != 0) {
+		LOG("Unable to submit URB. libusb error code: %d\n", res);
+		dev->shutdown_thread = 1;
+		dev->cancelled = 1;
+	}
+}
+
+
+static void *read_thread(void *param)
+{
+	hid_device *dev = param;
+	unsigned char *buf;
+	const size_t length = dev->input_ep_max_packet_size;
+
+	/* Set up the transfer object. */
+	buf = malloc(length);
+	dev->transfer = libusb_alloc_transfer(0);
+	libusb_fill_interrupt_transfer(dev->transfer,
+		dev->device_handle,
+		dev->input_endpoint,
+		buf,
+		length,
+		read_callback,
+		dev,
+		5000/*timeout*/);
+
+	/* Make the first submission. Further submissions are made
+	   from inside read_callback() */
+	libusb_submit_transfer(dev->transfer);
+
+	/* Notify the main thread that the read thread is up and running. */
+	pthread_barrier_wait(&dev->barrier);
+
+	/* Handle all the events. */
+	while (!dev->shutdown_thread) {
+		int res;
+		res = libusb_handle_events(usb_context);
+		if (res < 0) {
+			/* There was an error. */
+			LOG("read_thread(): libusb reports error # %d\n", res);
+
+			/* Break out of this loop only on fatal error.*/
+			if (res != LIBUSB_ERROR_BUSY &&
+			    res != LIBUSB_ERROR_TIMEOUT &&
+			    res != LIBUSB_ERROR_OVERFLOW &&
+			    res != LIBUSB_ERROR_INTERRUPTED) {
+				break;
+			}
+		}
+	}
+
+	/* Cancel any transfer that may be pending. This call will fail
+	   if no transfers are pending, but that's OK. */
+	libusb_cancel_transfer(dev->transfer);
+
+	while (!dev->cancelled)
+		libusb_handle_events_completed(usb_context, &dev->cancelled);
+
+	/* Now that the read thread is stopping, Wake any threads which are
+	   waiting on data (in hid_read_timeout()). Do this under a mutex to
+	   make sure that a thread which is about to go to sleep waiting on
+	   the condition acutally will go to sleep before the condition is
+	   signaled. */
+	pthread_mutex_lock(&dev->mutex);
+	pthread_cond_broadcast(&dev->condition);
+	pthread_mutex_unlock(&dev->mutex);
+
+	/* The dev->transfer->buffer and dev->transfer objects are cleaned up
+	   in hid_close(). They are not cleaned up here because this thread
+	   could end either due to a disconnect or due to a user
+	   call to hid_close(). In both cases the objects can be safely
+	   cleaned up after the call to pthread_join() (in hid_close()), but
+	   since hid_close() calls libusb_cancel_transfer(), on these objects,
+	   they can not be cleaned up here. */
+
+	return NULL;
+}
+
+
+hid_device * HID_API_EXPORT hid_open_path(const char *path)
+{
+	hid_device *dev = NULL;
+
+	libusb_device **devs;
+	libusb_device *usb_dev;
+	int res;
+	int d = 0;
+	int good_open = 0;
+
+	if(hid_init() < 0)
+		return NULL;
+
+	dev = new_hid_device();
+
+	libusb_get_device_list(usb_context, &devs);
+	while ((usb_dev = devs[d++]) != NULL) {
+		struct libusb_device_descriptor desc;
+		struct libusb_config_descriptor *conf_desc = NULL;
+		int i,j,k;
+		libusb_get_device_descriptor(usb_dev, &desc);
+
+		if (libusb_get_active_config_descriptor(usb_dev, &conf_desc) < 0)
+			continue;
+		for (j = 0; j < conf_desc->bNumInterfaces; j++) {
+			const struct libusb_interface *intf = &conf_desc->interface[j];
+			for (k = 0; k < intf->num_altsetting; k++) {
+				const struct libusb_interface_descriptor *intf_desc;
+				intf_desc = &intf->altsetting[k];
+				if (intf_desc->bInterfaceClass == LIBUSB_CLASS_HID) {
+					char *dev_path = make_path(usb_dev, intf_desc->bInterfaceNumber);
+					if (!strcmp(dev_path, path)) {
+						/* Matched Paths. Open this device */
+
+						/* OPEN HERE */
+						res = libusb_open(usb_dev, &dev->device_handle);
+						if (res < 0) {
+							LOG("can't open device\n");
+							free(dev_path);
+							break;
+						}
+						good_open = 1;
+#ifdef DETACH_KERNEL_DRIVER
+						/* Detach the kernel driver, but only if the
+						   device is managed by the kernel */
+						if (libusb_kernel_driver_active(dev->device_handle, intf_desc->bInterfaceNumber) == 1) {
+							res = libusb_detach_kernel_driver(dev->device_handle, intf_desc->bInterfaceNumber);
+							if (res < 0) {
+								libusb_close(dev->device_handle);
+								LOG("Unable to detach Kernel Driver\n");
+								free(dev_path);
+								good_open = 0;
+								break;
+							}
+						}
+#endif
+						res = libusb_claim_interface(dev->device_handle, intf_desc->bInterfaceNumber);
+						if (res < 0) {
+							LOG("can't claim interface %d: %d\n", intf_desc->bInterfaceNumber, res);
+							free(dev_path);
+							libusb_close(dev->device_handle);
+							good_open = 0;
+							break;
+						}
+
+						/* Store off the string descriptor indexes */
+						dev->manufacturer_index = desc.iManufacturer;
+						dev->product_index      = desc.iProduct;
+						dev->serial_index       = desc.iSerialNumber;
+
+						/* Store off the interface number */
+						dev->interface = intf_desc->bInterfaceNumber;
+
+						/* Find the INPUT and OUTPUT endpoints. An
+						   OUTPUT endpoint is not required. */
+						for (i = 0; i < intf_desc->bNumEndpoints; i++) {
+							const struct libusb_endpoint_descriptor *ep
+								= &intf_desc->endpoint[i];
+
+							/* Determine the type and direction of this
+							   endpoint. */
+							int is_interrupt =
+								(ep->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK)
+							      == LIBUSB_TRANSFER_TYPE_INTERRUPT;
+							int is_output =
+								(ep->bEndpointAddress & LIBUSB_ENDPOINT_DIR_MASK)
+							      == LIBUSB_ENDPOINT_OUT;
+							int is_input =
+								(ep->bEndpointAddress & LIBUSB_ENDPOINT_DIR_MASK)
+							      == LIBUSB_ENDPOINT_IN;
+
+							/* Decide whether to use it for intput or output. */
+							if (dev->input_endpoint == 0 &&
+							    is_interrupt && is_input) {
+								/* Use this endpoint for INPUT */
+								dev->input_endpoint = ep->bEndpointAddress;
+								dev->input_ep_max_packet_size = ep->wMaxPacketSize;
+							}
+							if (dev->output_endpoint == 0 &&
+							    is_interrupt && is_output) {
+								/* Use this endpoint for OUTPUT */
+								dev->output_endpoint = ep->bEndpointAddress;
+							}
+						}
+
+						pthread_create(&dev->thread, NULL, read_thread, dev);
+
+						/* Wait here for the read thread to be initialized. */
+						pthread_barrier_wait(&dev->barrier);
+
+					}
+					free(dev_path);
+				}
+			}
+		}
+		libusb_free_config_descriptor(conf_desc);
+
+	}
+
+	libusb_free_device_list(devs, 1);
+
+	/* If we have a good handle, return it. */
+	if (good_open) {
+		return dev;
+	}
+	else {
+		/* Unable to open any devices. */
+		free_hid_device(dev);
+		return NULL;
+	}
+}
+
+
+int HID_API_EXPORT hid_write(hid_device *dev, const unsigned char *data, size_t length)
+{
+	int res;
+	int report_number = data[0];
+	int skipped_report_id = 0;
+
+	if (report_number == 0x0) {
+		data++;
+		length--;
+		skipped_report_id = 1;
+	}
+
+
+	if (dev->output_endpoint <= 0) {
+		/* No interrput out endpoint. Use the Control Endpoint */
+		res = libusb_control_transfer(dev->device_handle,
+			LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_OUT,
+			0x09/*HID Set_Report*/,
+			(2/*HID output*/ << 8) | report_number,
+			dev->interface,
+			(unsigned char *)data, length,
+			1000/*timeout millis*/);
+
+		if (res < 0)
+			return -1;
+
+		if (skipped_report_id)
+			length++;
+
+		return length;
+	}
+	else {
+		/* Use the interrupt out endpoint */
+		int actual_length;
+		res = libusb_interrupt_transfer(dev->device_handle,
+			dev->output_endpoint,
+			(unsigned char*)data,
+			length,
+			&actual_length, 1000);
+
+		if (res < 0)
+			return -1;
+
+		if (skipped_report_id)
+			actual_length++;
+
+		return actual_length;
+	}
+}
+
+/* Helper function, to simplify hid_read().
+   This should be called with dev->mutex locked. */
+static int return_data(hid_device *dev, unsigned char *data, size_t length)
+{
+	/* Copy the data out of the linked list item (rpt) into the
+	   return buffer (data), and delete the liked list item. */
+	struct input_report *rpt = dev->input_reports;
+	size_t len = (length < rpt->len)? length: rpt->len;
+	if (len > 0)
+		memcpy(data, rpt->data, len);
+	dev->input_reports = rpt->next;
+	free(rpt->data);
+	free(rpt);
+	return len;
+}
+
+static void cleanup_mutex(void *param)
+{
+	hid_device *dev = param;
+	pthread_mutex_unlock(&dev->mutex);
+}
+
+
+int HID_API_EXPORT hid_read_timeout(hid_device *dev, unsigned char *data, size_t length, int milliseconds)
+{
+	int bytes_read = -1;
+
+#if 0
+	int transferred;
+	int res = libusb_interrupt_transfer(dev->device_handle, dev->input_endpoint, data, length, &transferred, 5000);
+	LOG("transferred: %d\n", transferred);
+	return transferred;
+#endif
+
+	pthread_mutex_lock(&dev->mutex);
+	pthread_cleanup_push(&cleanup_mutex, dev);
+
+	/* There's an input report queued up. Return it. */
+	if (dev->input_reports) {
+		/* Return the first one */
+		bytes_read = return_data(dev, data, length);
+		goto ret;
+	}
+
+	if (dev->shutdown_thread) {
+		/* This means the device has been disconnected.
+		   An error code of -1 should be returned. */
+		bytes_read = -1;
+		goto ret;
+	}
+
+	if (milliseconds == -1) {
+		/* Blocking */
+		while (!dev->input_reports && !dev->shutdown_thread) {
+			pthread_cond_wait(&dev->condition, &dev->mutex);
+		}
+		if (dev->input_reports) {
+			bytes_read = return_data(dev, data, length);
+		}
+	}
+	else if (milliseconds > 0) {
+		/* Non-blocking, but called with timeout. */
+		int res;
+		struct timespec ts;
+		clock_gettime(CLOCK_REALTIME, &ts);
+		ts.tv_sec += milliseconds / 1000;
+		ts.tv_nsec += (milliseconds % 1000) * 1000000;
+		if (ts.tv_nsec >= 1000000000L) {
+			ts.tv_sec++;
+			ts.tv_nsec -= 1000000000L;
+		}
+
+		while (!dev->input_reports && !dev->shutdown_thread) {
+			res = pthread_cond_timedwait(&dev->condition, &dev->mutex, &ts);
+			if (res == 0) {
+				if (dev->input_reports) {
+					bytes_read = return_data(dev, data, length);
+					break;
+				}
+
+				/* If we're here, there was a spurious wake up
+				   or the read thread was shutdown. Run the
+				   loop again (ie: don't break). */
+			}
+			else if (res == ETIMEDOUT) {
+				/* Timed out. */
+				bytes_read = 0;
+				break;
+			}
+			else {
+				/* Error. */
+				bytes_read = -1;
+				break;
+			}
+		}
+	}
+	else {
+		/* Purely non-blocking */
+		bytes_read = 0;
+	}
+
+ret:
+	pthread_mutex_unlock(&dev->mutex);
+	pthread_cleanup_pop(0);
+
+	return bytes_read;
+}
+
+int HID_API_EXPORT hid_read(hid_device *dev, unsigned char *data, size_t length)
+{
+	return hid_read_timeout(dev, data, length, dev->blocking ? -1 : 0);
+}
+
+int HID_API_EXPORT hid_set_nonblocking(hid_device *dev, int nonblock)
+{
+	dev->blocking = !nonblock;
+
+	return 0;
+}
+
+
+int HID_API_EXPORT hid_send_feature_report(hid_device *dev, const unsigned char *data, size_t length)
+{
+	int res = -1;
+	int skipped_report_id = 0;
+	int report_number = data[0];
+
+	if (report_number == 0x0) {
+		data++;
+		length--;
+		skipped_report_id = 1;
+	}
+
+	res = libusb_control_transfer(dev->device_handle,
+		LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_OUT,
+		0x09/*HID set_report*/,
+		(3/*HID feature*/ << 8) | report_number,
+		dev->interface,
+		(unsigned char *)data, length,
+		1000/*timeout millis*/);
+
+	if (res < 0)
+		return -1;
+
+	/* Account for the report ID */
+	if (skipped_report_id)
+		length++;
+
+	return length;
+}
+
+int HID_API_EXPORT hid_get_feature_report(hid_device *dev, unsigned char *data, size_t length)
+{
+	int res = -1;
+	int skipped_report_id = 0;
+	int report_number = data[0];
+
+	if (report_number == 0x0) {
+		/* Offset the return buffer by 1, so that the report ID
+		   will remain in byte 0. */
+		data++;
+		length--;
+		skipped_report_id = 1;
+	}
+	res = libusb_control_transfer(dev->device_handle,
+		LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_IN,
+		0x01/*HID get_report*/,
+		(3/*HID feature*/ << 8) | report_number,
+		dev->interface,
+		(unsigned char *)data, length,
+		1000/*timeout millis*/);
+
+	if (res < 0)
+		return -1;
+
+	if (skipped_report_id)
+		res++;
+
+	return res;
+}
+
+
+void HID_API_EXPORT hid_close(hid_device *dev)
+{
+	if (!dev)
+		return;
+
+	/* Cause read_thread() to stop. */
+	dev->shutdown_thread = 1;
+	libusb_cancel_transfer(dev->transfer);
+
+	/* Wait for read_thread() to end. */
+	pthread_join(dev->thread, NULL);
+
+	/* Clean up the Transfer objects allocated in read_thread(). */
+	free(dev->transfer->buffer);
+	libusb_free_transfer(dev->transfer);
+
+	/* release the interface */
+	libusb_release_interface(dev->device_handle, dev->interface);
+
+	/* Close the handle */
+	libusb_close(dev->device_handle);
+
+	/* Clear out the queue of received reports. */
+	pthread_mutex_lock(&dev->mutex);
+	while (dev->input_reports) {
+		return_data(dev, NULL, 0);
+	}
+	pthread_mutex_unlock(&dev->mutex);
+
+	free_hid_device(dev);
+}
+
+
+int HID_API_EXPORT_CALL hid_get_manufacturer_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return hid_get_indexed_string(dev, dev->manufacturer_index, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_product_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return hid_get_indexed_string(dev, dev->product_index, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_serial_number_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return hid_get_indexed_string(dev, dev->serial_index, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_indexed_string(hid_device *dev, int string_index, wchar_t *string, size_t maxlen)
+{
+	wchar_t *str;
+
+	str = get_usb_string(dev->device_handle, string_index);
+	if (str) {
+		wcsncpy(string, str, maxlen);
+		string[maxlen-1] = L'\0';
+		free(str);
+		return 0;
+	}
+	else
+		return -1;
+}
+
+
+HID_API_EXPORT const wchar_t * HID_API_CALL  hid_error(hid_device *dev)
+{
+	return NULL;
+}
+
+
+struct lang_map_entry {
+	const char *name;
+	const char *string_code;
+	uint16_t usb_code;
+};
+
+#define LANG(name,code,usb_code) { name, code, usb_code }
+static struct lang_map_entry lang_map[] = {
+	LANG("Afrikaans", "af", 0x0436),
+	LANG("Albanian", "sq", 0x041C),
+	LANG("Arabic - United Arab Emirates", "ar_ae", 0x3801),
+	LANG("Arabic - Bahrain", "ar_bh", 0x3C01),
+	LANG("Arabic - Algeria", "ar_dz", 0x1401),
+	LANG("Arabic - Egypt", "ar_eg", 0x0C01),
+	LANG("Arabic - Iraq", "ar_iq", 0x0801),
+	LANG("Arabic - Jordan", "ar_jo", 0x2C01),
+	LANG("Arabic - Kuwait", "ar_kw", 0x3401),
+	LANG("Arabic - Lebanon", "ar_lb", 0x3001),
+	LANG("Arabic - Libya", "ar_ly", 0x1001),
+	LANG("Arabic - Morocco", "ar_ma", 0x1801),
+	LANG("Arabic - Oman", "ar_om", 0x2001),
+	LANG("Arabic - Qatar", "ar_qa", 0x4001),
+	LANG("Arabic - Saudi Arabia", "ar_sa", 0x0401),
+	LANG("Arabic - Syria", "ar_sy", 0x2801),
+	LANG("Arabic - Tunisia", "ar_tn", 0x1C01),
+	LANG("Arabic - Yemen", "ar_ye", 0x2401),
+	LANG("Armenian", "hy", 0x042B),
+	LANG("Azeri - Latin", "az_az", 0x042C),
+	LANG("Azeri - Cyrillic", "az_az", 0x082C),
+	LANG("Basque", "eu", 0x042D),
+	LANG("Belarusian", "be", 0x0423),
+	LANG("Bulgarian", "bg", 0x0402),
+	LANG("Catalan", "ca", 0x0403),
+	LANG("Chinese - China", "zh_cn", 0x0804),
+	LANG("Chinese - Hong Kong SAR", "zh_hk", 0x0C04),
+	LANG("Chinese - Macau SAR", "zh_mo", 0x1404),
+	LANG("Chinese - Singapore", "zh_sg", 0x1004),
+	LANG("Chinese - Taiwan", "zh_tw", 0x0404),
+	LANG("Croatian", "hr", 0x041A),
+	LANG("Czech", "cs", 0x0405),
+	LANG("Danish", "da", 0x0406),
+	LANG("Dutch - Netherlands", "nl_nl", 0x0413),
+	LANG("Dutch - Belgium", "nl_be", 0x0813),
+	LANG("English - Australia", "en_au", 0x0C09),
+	LANG("English - Belize", "en_bz", 0x2809),
+	LANG("English - Canada", "en_ca", 0x1009),
+	LANG("English - Caribbean", "en_cb", 0x2409),
+	LANG("English - Ireland", "en_ie", 0x1809),
+	LANG("English - Jamaica", "en_jm", 0x2009),
+	LANG("English - New Zealand", "en_nz", 0x1409),
+	LANG("English - Phillippines", "en_ph", 0x3409),
+	LANG("English - Southern Africa", "en_za", 0x1C09),
+	LANG("English - Trinidad", "en_tt", 0x2C09),
+	LANG("English - Great Britain", "en_gb", 0x0809),
+	LANG("English - United States", "en_us", 0x0409),
+	LANG("Estonian", "et", 0x0425),
+	LANG("Farsi", "fa", 0x0429),
+	LANG("Finnish", "fi", 0x040B),
+	LANG("Faroese", "fo", 0x0438),
+	LANG("French - France", "fr_fr", 0x040C),
+	LANG("French - Belgium", "fr_be", 0x080C),
+	LANG("French - Canada", "fr_ca", 0x0C0C),
+	LANG("French - Luxembourg", "fr_lu", 0x140C),
+	LANG("French - Switzerland", "fr_ch", 0x100C),
+	LANG("Gaelic - Ireland", "gd_ie", 0x083C),
+	LANG("Gaelic - Scotland", "gd", 0x043C),
+	LANG("German - Germany", "de_de", 0x0407),
+	LANG("German - Austria", "de_at", 0x0C07),
+	LANG("German - Liechtenstein", "de_li", 0x1407),
+	LANG("German - Luxembourg", "de_lu", 0x1007),
+	LANG("German - Switzerland", "de_ch", 0x0807),
+	LANG("Greek", "el", 0x0408),
+	LANG("Hebrew", "he", 0x040D),
+	LANG("Hindi", "hi", 0x0439),
+	LANG("Hungarian", "hu", 0x040E),
+	LANG("Icelandic", "is", 0x040F),
+	LANG("Indonesian", "id", 0x0421),
+	LANG("Italian - Italy", "it_it", 0x0410),
+	LANG("Italian - Switzerland", "it_ch", 0x0810),
+	LANG("Japanese", "ja", 0x0411),
+	LANG("Korean", "ko", 0x0412),
+	LANG("Latvian", "lv", 0x0426),
+	LANG("Lithuanian", "lt", 0x0427),
+	LANG("F.Y.R.O. Macedonia", "mk", 0x042F),
+	LANG("Malay - Malaysia", "ms_my", 0x043E),
+	LANG("Malay – Brunei", "ms_bn", 0x083E),
+	LANG("Maltese", "mt", 0x043A),
+	LANG("Marathi", "mr", 0x044E),
+	LANG("Norwegian - Bokml", "no_no", 0x0414),
+	LANG("Norwegian - Nynorsk", "no_no", 0x0814),
+	LANG("Polish", "pl", 0x0415),
+	LANG("Portuguese - Portugal", "pt_pt", 0x0816),
+	LANG("Portuguese - Brazil", "pt_br", 0x0416),
+	LANG("Raeto-Romance", "rm", 0x0417),
+	LANG("Romanian - Romania", "ro", 0x0418),
+	LANG("Romanian - Republic of Moldova", "ro_mo", 0x0818),
+	LANG("Russian", "ru", 0x0419),
+	LANG("Russian - Republic of Moldova", "ru_mo", 0x0819),
+	LANG("Sanskrit", "sa", 0x044F),
+	LANG("Serbian - Cyrillic", "sr_sp", 0x0C1A),
+	LANG("Serbian - Latin", "sr_sp", 0x081A),
+	LANG("Setsuana", "tn", 0x0432),
+	LANG("Slovenian", "sl", 0x0424),
+	LANG("Slovak", "sk", 0x041B),
+	LANG("Sorbian", "sb", 0x042E),
+	LANG("Spanish - Spain (Traditional)", "es_es", 0x040A),
+	LANG("Spanish - Argentina", "es_ar", 0x2C0A),
+	LANG("Spanish - Bolivia", "es_bo", 0x400A),
+	LANG("Spanish - Chile", "es_cl", 0x340A),
+	LANG("Spanish - Colombia", "es_co", 0x240A),
+	LANG("Spanish - Costa Rica", "es_cr", 0x140A),
+	LANG("Spanish - Dominican Republic", "es_do", 0x1C0A),
+	LANG("Spanish - Ecuador", "es_ec", 0x300A),
+	LANG("Spanish - Guatemala", "es_gt", 0x100A),
+	LANG("Spanish - Honduras", "es_hn", 0x480A),
+	LANG("Spanish - Mexico", "es_mx", 0x080A),
+	LANG("Spanish - Nicaragua", "es_ni", 0x4C0A),
+	LANG("Spanish - Panama", "es_pa", 0x180A),
+	LANG("Spanish - Peru", "es_pe", 0x280A),
+	LANG("Spanish - Puerto Rico", "es_pr", 0x500A),
+	LANG("Spanish - Paraguay", "es_py", 0x3C0A),
+	LANG("Spanish - El Salvador", "es_sv", 0x440A),
+	LANG("Spanish - Uruguay", "es_uy", 0x380A),
+	LANG("Spanish - Venezuela", "es_ve", 0x200A),
+	LANG("Southern Sotho", "st", 0x0430),
+	LANG("Swahili", "sw", 0x0441),
+	LANG("Swedish - Sweden", "sv_se", 0x041D),
+	LANG("Swedish - Finland", "sv_fi", 0x081D),
+	LANG("Tamil", "ta", 0x0449),
+	LANG("Tatar", "tt", 0X0444),
+	LANG("Thai", "th", 0x041E),
+	LANG("Turkish", "tr", 0x041F),
+	LANG("Tsonga", "ts", 0x0431),
+	LANG("Ukrainian", "uk", 0x0422),
+	LANG("Urdu", "ur", 0x0420),
+	LANG("Uzbek - Cyrillic", "uz_uz", 0x0843),
+	LANG("Uzbek – Latin", "uz_uz", 0x0443),
+	LANG("Vietnamese", "vi", 0x042A),
+	LANG("Xhosa", "xh", 0x0434),
+	LANG("Yiddish", "yi", 0x043D),
+	LANG("Zulu", "zu", 0x0435),
+	LANG(NULL, NULL, 0x0),
+};
+
+uint16_t get_usb_code_for_current_locale(void)
+{
+	char *locale;
+	char search_string[64];
+	char *ptr;
+	struct lang_map_entry *lang;
+
+	/* Get the current locale. */
+	locale = setlocale(0, NULL);
+	if (!locale)
+		return 0x0;
+
+	/* Make a copy of the current locale string. */
+	strncpy(search_string, locale, sizeof(search_string));
+	search_string[sizeof(search_string)-1] = '\0';
+
+	/* Chop off the encoding part, and make it lower case. */
+	ptr = search_string;
+	while (*ptr) {
+		*ptr = tolower(*ptr);
+		if (*ptr == '.') {
+			*ptr = '\0';
+			break;
+		}
+		ptr++;
+	}
+
+	/* Find the entry which matches the string code of our locale. */
+	lang = lang_map;
+	while (lang->string_code) {
+		if (!strcmp(lang->string_code, search_string)) {
+			return lang->usb_code;
+		}
+		lang++;
+	}
+
+	/* There was no match. Find with just the language only. */
+	/* Chop off the variant. Chop it off at the '_'. */
+	ptr = search_string;
+	while (*ptr) {
+		*ptr = tolower(*ptr);
+		if (*ptr == '_') {
+			*ptr = '\0';
+			break;
+		}
+		ptr++;
+	}
+
+#if 0 /* TODO: Do we need this? */
+	/* Find the entry which matches the string code of our language. */
+	lang = lang_map;
+	while (lang->string_code) {
+		if (!strcmp(lang->string_code, search_string)) {
+			return lang->usb_code;
+		}
+		lang++;
+	}
+#endif
+
+	/* Found nothing. */
+	return 0x0;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff -Nur -x debian -x .git -x .pc ./src/libambit/hidapi/hid-linux.c ../openambit.git/src/libambit/hidapi/hid-linux.c
--- ./src/libambit/hidapi/hid-linux.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/hidapi/hid-linux.c	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,795 @@
+/*******************************************************
+ HIDAPI - Multi-Platform library for
+ communication with HID devices.
+
+ Alan Ott
+ Signal 11 Software
+
+ 8/22/2009
+ Linux Version - 6/2/2009
+
+ Copyright 2009, All Rights Reserved.
+
+ At the discretion of the user of this library,
+ this software may be licensed under the terms of the
+ GNU General Public License v3, a BSD-Style license, or the
+ original HIDAPI license as outlined in the LICENSE.txt,
+ LICENSE-gpl3.txt, LICENSE-bsd.txt, and LICENSE-orig.txt
+ files located at the root of the source distribution.
+ These files may also be found in the public source
+ code repository located at:
+        http://github.com/signal11/hidapi .
+********************************************************/
+
+/* C */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <locale.h>
+#include <errno.h>
+
+/* Unix */
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/utsname.h>
+#include <fcntl.h>
+#include <poll.h>
+
+/* Linux */
+#include <linux/hidraw.h>
+#include <linux/version.h>
+#include <linux/input.h>
+#include <libudev.h>
+
+#include "hidapi.h"
+
+/* Definitions from linux/hidraw.h. Since these are new, some distros
+   may not have header files which contain them. */
+#ifndef HIDIOCSFEATURE
+#define HIDIOCSFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x06, len)
+#endif
+#ifndef HIDIOCGFEATURE
+#define HIDIOCGFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x07, len)
+#endif
+
+
+/* USB HID device property names */
+const char *device_string_names[] = {
+	"manufacturer",
+	"product",
+	"serial",
+};
+
+/* Symbolic names for the properties above */
+enum device_string_id {
+	DEVICE_STRING_MANUFACTURER,
+	DEVICE_STRING_PRODUCT,
+	DEVICE_STRING_SERIAL,
+
+	DEVICE_STRING_COUNT,
+};
+
+struct hid_device_ {
+	int device_handle;
+	int blocking;
+	int uses_numbered_reports;
+};
+
+
+static __u32 kernel_version = 0;
+
+static __u32 detect_kernel_version(void)
+{
+	struct utsname name;
+	int major, minor, release;
+	int ret;
+
+	uname(&name);
+	ret = sscanf(name.release, "%d.%d.%d", &major, &minor, &release);
+	if (ret == 3) {
+		return KERNEL_VERSION(major, minor, release);
+	}
+
+	ret = sscanf(name.release, "%d.%d", &major, &minor);
+	if (ret == 2) {
+		return KERNEL_VERSION(major, minor, 0);
+	}
+
+	printf("Couldn't determine kernel version from version string \"%s\"\n", name.release);
+	return 0;
+}
+
+static hid_device *new_hid_device(void)
+{
+	hid_device *dev = calloc(1, sizeof(hid_device));
+	dev->device_handle = -1;
+	dev->blocking = 1;
+	dev->uses_numbered_reports = 0;
+
+	return dev;
+}
+
+
+/* The caller must free the returned string with free(). */
+static wchar_t *utf8_to_wchar_t(const char *utf8)
+{
+	wchar_t *ret = NULL;
+
+	if (utf8) {
+		size_t wlen = mbstowcs(NULL, utf8, 0);
+		if ((size_t) -1 == wlen) {
+			return wcsdup(L"");
+		}
+		ret = calloc(wlen+1, sizeof(wchar_t));
+		mbstowcs(ret, utf8, wlen+1);
+		ret[wlen] = 0x0000;
+	}
+
+	return ret;
+}
+
+/* Get an attribute value from a udev_device and return it as a whar_t
+   string. The returned string must be freed with free() when done.*/
+static wchar_t *copy_udev_string(struct udev_device *dev, const char *udev_name)
+{
+	return utf8_to_wchar_t(udev_device_get_sysattr_value(dev, udev_name));
+}
+
+/* uses_numbered_reports() returns 1 if report_descriptor describes a device
+   which contains numbered reports. */
+static int uses_numbered_reports(__u8 *report_descriptor, __u32 size) {
+	unsigned int i = 0;
+	int size_code;
+	int data_len, key_size;
+
+	while (i < size) {
+		int key = report_descriptor[i];
+
+		/* Check for the Report ID key */
+		if (key == 0x85/*Report ID*/) {
+			/* This device has a Report ID, which means it uses
+			   numbered reports. */
+			return 1;
+		}
+
+		//printf("key: %02hhx\n", key);
+
+		if ((key & 0xf0) == 0xf0) {
+			/* This is a Long Item. The next byte contains the
+			   length of the data section (value) for this key.
+			   See the HID specification, version 1.11, section
+			   6.2.2.3, titled "Long Items." */
+			if (i+1 < size)
+				data_len = report_descriptor[i+1];
+			else
+				data_len = 0; /* malformed report */
+			key_size = 3;
+		}
+		else {
+			/* This is a Short Item. The bottom two bits of the
+			   key contain the size code for the data section
+			   (value) for this key.  Refer to the HID
+			   specification, version 1.11, section 6.2.2.2,
+			   titled "Short Items." */
+			size_code = key & 0x3;
+			switch (size_code) {
+			case 0:
+			case 1:
+			case 2:
+				data_len = size_code;
+				break;
+			case 3:
+				data_len = 4;
+				break;
+			default:
+				/* Can't ever happen since size_code is & 0x3 */
+				data_len = 0;
+				break;
+			};
+			key_size = 1;
+		}
+
+		/* Skip over this key and it's associated data */
+		i += data_len + key_size;
+	}
+
+	/* Didn't find a Report ID key. Device doesn't use numbered reports. */
+	return 0;
+}
+
+/*
+ * The caller is responsible for free()ing the (newly-allocated) character
+ * strings pointed to by serial_number_utf8 and product_name_utf8 after use.
+ */
+static int
+parse_uevent_info(const char *uevent, int *bus_type,
+	unsigned short *vendor_id, unsigned short *product_id,
+	char **serial_number_utf8, char **product_name_utf8)
+{
+	char *tmp = strdup(uevent);
+	char *saveptr = NULL;
+	char *line;
+	char *key;
+	char *value;
+
+	int found_id = 0;
+	int found_serial = 0;
+	int found_name = 0;
+
+	line = strtok_r(tmp, "\n", &saveptr);
+	while (line != NULL) {
+		/* line: "KEY=value" */
+		key = line;
+		value = strchr(line, '=');
+		if (!value) {
+			goto next_line;
+		}
+		*value = '\0';
+		value++;
+
+		if (strcmp(key, "HID_ID") == 0) {
+			/**
+			 *        type vendor   product
+			 * HID_ID=0003:000005AC:00008242
+			 **/
+			int ret = sscanf(value, "%x:%hx:%hx", bus_type, vendor_id, product_id);
+			if (ret == 3) {
+				found_id = 1;
+			}
+		} else if (strcmp(key, "HID_NAME") == 0) {
+			/* The caller has to free the product name */
+			*product_name_utf8 = strdup(value);
+			found_name = 1;
+		} else if (strcmp(key, "HID_UNIQ") == 0) {
+			/* The caller has to free the serial number */
+			*serial_number_utf8 = strdup(value);
+			found_serial = 1;
+		}
+
+next_line:
+		line = strtok_r(NULL, "\n", &saveptr);
+	}
+
+	free(tmp);
+	return (found_id && found_name && found_serial);
+}
+
+
+static int get_device_string(hid_device *dev, enum device_string_id key, wchar_t *string, size_t maxlen)
+{
+	struct udev *udev;
+	struct udev_device *udev_dev, *parent, *hid_dev;
+	struct stat s;
+	int ret = -1;
+        char *serial_number_utf8 = NULL;
+        char *product_name_utf8 = NULL;
+
+	/* Create the udev object */
+	udev = udev_new();
+	if (!udev) {
+		printf("Can't create udev\n");
+		return -1;
+	}
+
+	/* Get the dev_t (major/minor numbers) from the file handle. */
+	fstat(dev->device_handle, &s);
+	/* Open a udev device from the dev_t. 'c' means character device. */
+	udev_dev = udev_device_new_from_devnum(udev, 'c', s.st_rdev);
+	if (udev_dev) {
+		hid_dev = udev_device_get_parent_with_subsystem_devtype(
+			udev_dev,
+			"hid",
+			NULL);
+		if (hid_dev) {
+			unsigned short dev_vid;
+			unsigned short dev_pid;
+			int bus_type;
+			size_t retm;
+
+			ret = parse_uevent_info(
+			           udev_device_get_sysattr_value(hid_dev, "uevent"),
+			           &bus_type,
+			           &dev_vid,
+			           &dev_pid,
+			           &serial_number_utf8,
+			           &product_name_utf8);
+
+			if (bus_type == BUS_BLUETOOTH) {
+				switch (key) {
+					case DEVICE_STRING_MANUFACTURER:
+						wcsncpy(string, L"", maxlen);
+						ret = 0;
+						break;
+					case DEVICE_STRING_PRODUCT:
+						retm = mbstowcs(string, product_name_utf8, maxlen);
+						ret = (retm == (size_t)-1)? -1: 0;
+						break;
+					case DEVICE_STRING_SERIAL:
+						retm = mbstowcs(string, serial_number_utf8, maxlen);
+						ret = (retm == (size_t)-1)? -1: 0;
+						break;
+					case DEVICE_STRING_COUNT:
+					default:
+						ret = -1;
+						break;
+				}
+			}
+			else {
+				/* This is a USB device. Find its parent USB Device node. */
+				parent = udev_device_get_parent_with_subsystem_devtype(
+					   udev_dev,
+					   "usb",
+					   "usb_device");
+				if (parent) {
+					const char *str;
+					const char *key_str = NULL;
+
+					if (key >= 0 && key < DEVICE_STRING_COUNT) {
+						key_str = device_string_names[key];
+					} else {
+						ret = -1;
+						goto end;
+					}
+
+					str = udev_device_get_sysattr_value(parent, key_str);
+					if (str) {
+						/* Convert the string from UTF-8 to wchar_t */
+						retm = mbstowcs(string, str, maxlen);
+						ret = (retm == (size_t)-1)? -1: 0;
+						goto end;
+					}
+				}
+			}
+		}
+	}
+
+end:
+        free(serial_number_utf8);
+        free(product_name_utf8);
+
+	udev_device_unref(udev_dev);
+	/* parent and hid_dev don't need to be (and can't be) unref'd.
+	   I'm not sure why, but they'll throw double-free() errors. */
+	udev_unref(udev);
+
+	return ret;
+}
+
+int HID_API_EXPORT hid_init(void)
+{
+	const char *locale;
+
+	/* Set the locale if it's not set. */
+	locale = setlocale(LC_CTYPE, NULL);
+	if (!locale)
+		setlocale(LC_CTYPE, "");
+
+	kernel_version = detect_kernel_version();
+
+	return 0;
+}
+
+int HID_API_EXPORT hid_exit(void)
+{
+	/* Nothing to do for this in the Linux/hidraw implementation. */
+	return 0;
+}
+
+
+struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id, unsigned short product_id)
+{
+	struct udev *udev;
+	struct udev_enumerate *enumerate;
+	struct udev_list_entry *devices, *dev_list_entry;
+
+	struct hid_device_info *root = NULL; /* return object */
+	struct hid_device_info *cur_dev = NULL;
+	struct hid_device_info *prev_dev = NULL; /* previous device */
+
+	hid_init();
+
+	/* Create the udev object */
+	udev = udev_new();
+	if (!udev) {
+		printf("Can't create udev\n");
+		return NULL;
+	}
+
+	/* Create a list of the devices in the 'hidraw' subsystem. */
+	enumerate = udev_enumerate_new(udev);
+	udev_enumerate_add_match_subsystem(enumerate, "hidraw");
+	udev_enumerate_scan_devices(enumerate);
+	devices = udev_enumerate_get_list_entry(enumerate);
+	/* For each item, see if it matches the vid/pid, and if so
+	   create a udev_device record for it */
+	udev_list_entry_foreach(dev_list_entry, devices) {
+		const char *sysfs_path;
+		const char *dev_path;
+		const char *str;
+		struct udev_device *raw_dev; /* The device's hidraw udev node. */
+		struct udev_device *hid_dev; /* The device's HID udev node. */
+		struct udev_device *usb_dev; /* The device's USB udev node. */
+		struct udev_device *intf_dev; /* The device's interface (in the USB sense). */
+		unsigned short dev_vid;
+		unsigned short dev_pid;
+		char *serial_number_utf8 = NULL;
+		char *product_name_utf8 = NULL;
+		int bus_type;
+		int result;
+
+		/* Get the filename of the /sys entry for the device
+		   and create a udev_device object (dev) representing it */
+		sysfs_path = udev_list_entry_get_name(dev_list_entry);
+		raw_dev = udev_device_new_from_syspath(udev, sysfs_path);
+		dev_path = udev_device_get_devnode(raw_dev);
+
+		hid_dev = udev_device_get_parent_with_subsystem_devtype(
+			raw_dev,
+			"hid",
+			NULL);
+
+		if (!hid_dev) {
+			/* Unable to find parent hid device. */
+			goto next;
+		}
+
+		result = parse_uevent_info(
+			udev_device_get_sysattr_value(hid_dev, "uevent"),
+			&bus_type,
+			&dev_vid,
+			&dev_pid,
+			&serial_number_utf8,
+			&product_name_utf8);
+
+		if (!result) {
+			/* parse_uevent_info() failed for at least one field. */
+			goto next;
+		}
+
+		if (bus_type != BUS_USB && bus_type != BUS_BLUETOOTH) {
+			/* We only know how to handle USB and BT devices. */
+			goto next;
+		}
+
+		/* Check the VID/PID against the arguments */
+		if ((vendor_id == 0x0 || vendor_id == dev_vid) &&
+		    (product_id == 0x0 || product_id == dev_pid)) {
+			struct hid_device_info *tmp;
+
+			/* VID/PID match. Create the record. */
+			tmp = malloc(sizeof(struct hid_device_info));
+			if (cur_dev) {
+				cur_dev->next = tmp;
+			}
+			else {
+				root = tmp;
+			}
+			prev_dev = cur_dev;
+			cur_dev = tmp;
+
+			/* Fill out the record */
+			cur_dev->next = NULL;
+			cur_dev->path = dev_path? strdup(dev_path): NULL;
+
+			/* VID/PID */
+			cur_dev->vendor_id = dev_vid;
+			cur_dev->product_id = dev_pid;
+
+			/* Serial Number */
+			cur_dev->serial_number = utf8_to_wchar_t(serial_number_utf8);
+
+			/* Release Number */
+			cur_dev->release_number = 0x0;
+
+			/* Interface Number */
+			cur_dev->interface_number = -1;
+
+			switch (bus_type) {
+				case BUS_USB:
+					/* The device pointed to by raw_dev contains information about
+					   the hidraw device. In order to get information about the
+					   USB device, get the parent device with the
+					   subsystem/devtype pair of "usb"/"usb_device". This will
+					   be several levels up the tree, but the function will find
+					   it. */
+					usb_dev = udev_device_get_parent_with_subsystem_devtype(
+							raw_dev,
+							"usb",
+							"usb_device");
+
+					if (!usb_dev) {
+						/* Free this device */
+						free(cur_dev->serial_number);
+						free(cur_dev->path);
+						free(cur_dev);
+
+						/* Take it off the device list. */
+						if (prev_dev) {
+							prev_dev->next = NULL;
+							cur_dev = prev_dev;
+						}
+						else {
+							cur_dev = root = NULL;
+						}
+
+						goto next;
+					}
+
+					/* Manufacturer and Product strings */
+					cur_dev->manufacturer_string = copy_udev_string(usb_dev, device_string_names[DEVICE_STRING_MANUFACTURER]);
+					cur_dev->product_string = copy_udev_string(usb_dev, device_string_names[DEVICE_STRING_PRODUCT]);
+
+					/* Release Number */
+					str = udev_device_get_sysattr_value(usb_dev, "bcdDevice");
+					cur_dev->release_number = (str)? strtol(str, NULL, 16): 0x0;
+
+					/* Get a handle to the interface's udev node. */
+					intf_dev = udev_device_get_parent_with_subsystem_devtype(
+							raw_dev,
+							"usb",
+							"usb_interface");
+					if (intf_dev) {
+						str = udev_device_get_sysattr_value(intf_dev, "bInterfaceNumber");
+						cur_dev->interface_number = (str)? strtol(str, NULL, 16): -1;
+					}
+
+					break;
+
+				case BUS_BLUETOOTH:
+					/* Manufacturer and Product strings */
+					cur_dev->manufacturer_string = wcsdup(L"");
+					cur_dev->product_string = utf8_to_wchar_t(product_name_utf8);
+
+					break;
+
+				default:
+					/* Unknown device type - this should never happen, as we
+					 * check for USB and Bluetooth devices above */
+					break;
+			}
+		}
+
+	next:
+		free(serial_number_utf8);
+		free(product_name_utf8);
+		udev_device_unref(raw_dev);
+		/* hid_dev, usb_dev and intf_dev don't need to be (and can't be)
+		   unref()d.  It will cause a double-free() error.  I'm not
+		   sure why.  */
+	}
+	/* Free the enumerator and udev objects. */
+	udev_enumerate_unref(enumerate);
+	udev_unref(udev);
+
+	return root;
+}
+
+void  HID_API_EXPORT hid_free_enumeration(struct hid_device_info *devs)
+{
+	struct hid_device_info *d = devs;
+	while (d) {
+		struct hid_device_info *next = d->next;
+		free(d->path);
+		free(d->serial_number);
+		free(d->manufacturer_string);
+		free(d->product_string);
+		free(d);
+		d = next;
+	}
+}
+
+hid_device * hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number)
+{
+	struct hid_device_info *devs, *cur_dev;
+	const char *path_to_open = NULL;
+	hid_device *handle = NULL;
+
+	devs = hid_enumerate(vendor_id, product_id);
+	cur_dev = devs;
+	while (cur_dev) {
+		if (cur_dev->vendor_id == vendor_id &&
+		    cur_dev->product_id == product_id) {
+			if (serial_number) {
+				if (wcscmp(serial_number, cur_dev->serial_number) == 0) {
+					path_to_open = cur_dev->path;
+					break;
+				}
+			}
+			else {
+				path_to_open = cur_dev->path;
+				break;
+			}
+		}
+		cur_dev = cur_dev->next;
+	}
+
+	if (path_to_open) {
+		/* Open the device */
+		handle = hid_open_path(path_to_open);
+	}
+
+	hid_free_enumeration(devs);
+
+	return handle;
+}
+
+hid_device * HID_API_EXPORT hid_open_path(const char *path)
+{
+	hid_device *dev = NULL;
+
+	hid_init();
+
+	dev = new_hid_device();
+
+	/* OPEN HERE */
+	dev->device_handle = open(path, O_RDWR);
+
+	/* If we have a good handle, return it. */
+	if (dev->device_handle > 0) {
+
+		/* Get the report descriptor */
+		int res, desc_size = 0;
+		struct hidraw_report_descriptor rpt_desc;
+
+		memset(&rpt_desc, 0x0, sizeof(rpt_desc));
+
+		/* Get Report Descriptor Size */
+		res = ioctl(dev->device_handle, HIDIOCGRDESCSIZE, &desc_size);
+		if (res < 0)
+			perror("HIDIOCGRDESCSIZE");
+
+
+		/* Get Report Descriptor */
+		rpt_desc.size = desc_size;
+		res = ioctl(dev->device_handle, HIDIOCGRDESC, &rpt_desc);
+		if (res < 0) {
+			perror("HIDIOCGRDESC");
+		} else {
+			/* Determine if this device uses numbered reports. */
+			dev->uses_numbered_reports =
+				uses_numbered_reports(rpt_desc.value,
+				                      rpt_desc.size);
+		}
+
+		return dev;
+	}
+	else {
+		/* Unable to open any devices. */
+		free(dev);
+		return NULL;
+	}
+}
+
+
+int HID_API_EXPORT hid_write(hid_device *dev, const unsigned char *data, size_t length)
+{
+	int bytes_written;
+
+	bytes_written = write(dev->device_handle, data, length);
+
+	return bytes_written;
+}
+
+
+int HID_API_EXPORT hid_read_timeout(hid_device *dev, unsigned char *data, size_t length, int milliseconds)
+{
+	int bytes_read;
+
+	if (milliseconds >= 0) {
+		/* Milliseconds is either 0 (non-blocking) or > 0 (contains
+		   a valid timeout). In both cases we want to call poll()
+		   and wait for data to arrive.  Don't rely on non-blocking
+		   operation (O_NONBLOCK) since some kernels don't seem to
+		   properly report device disconnection through read() when
+		   in non-blocking mode.  */
+		int ret;
+		struct pollfd fds;
+
+		fds.fd = dev->device_handle;
+		fds.events = POLLIN;
+		fds.revents = 0;
+		ret = poll(&fds, 1, milliseconds);
+		if (ret == -1 || ret == 0) {
+			/* Error or timeout */
+			return ret;
+		}
+		else {
+			/* Check for errors on the file descriptor. This will
+			   indicate a device disconnection. */
+			if (fds.revents & (POLLERR | POLLHUP | POLLNVAL))
+				return -1;
+		}
+	}
+
+	bytes_read = read(dev->device_handle, data, length);
+	if (bytes_read < 0 && (errno == EAGAIN || errno == EINPROGRESS))
+		bytes_read = 0;
+
+	if (bytes_read >= 0 &&
+	    kernel_version != 0 &&
+	    kernel_version < KERNEL_VERSION(2,6,34) &&
+	    dev->uses_numbered_reports) {
+		/* Work around a kernel bug. Chop off the first byte. */
+		memmove(data, data+1, bytes_read);
+		bytes_read--;
+	}
+
+	return bytes_read;
+}
+
+int HID_API_EXPORT hid_read(hid_device *dev, unsigned char *data, size_t length)
+{
+	return hid_read_timeout(dev, data, length, (dev->blocking)? -1: 0);
+}
+
+int HID_API_EXPORT hid_set_nonblocking(hid_device *dev, int nonblock)
+{
+	/* Do all non-blocking in userspace using poll(), since it looks
+	   like there's a bug in the kernel in some versions where
+	   read() will not return -1 on disconnection of the USB device */
+
+	dev->blocking = !nonblock;
+	return 0; /* Success */
+}
+
+
+int HID_API_EXPORT hid_send_feature_report(hid_device *dev, const unsigned char *data, size_t length)
+{
+	int res;
+
+	res = ioctl(dev->device_handle, HIDIOCSFEATURE(length), data);
+	if (res < 0)
+		perror("ioctl (SFEATURE)");
+
+	return res;
+}
+
+int HID_API_EXPORT hid_get_feature_report(hid_device *dev, unsigned char *data, size_t length)
+{
+	int res;
+
+	res = ioctl(dev->device_handle, HIDIOCGFEATURE(length), data);
+	if (res < 0)
+		perror("ioctl (GFEATURE)");
+
+
+	return res;
+}
+
+
+void HID_API_EXPORT hid_close(hid_device *dev)
+{
+	if (!dev)
+		return;
+	close(dev->device_handle);
+	free(dev);
+}
+
+
+int HID_API_EXPORT_CALL hid_get_manufacturer_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return get_device_string(dev, DEVICE_STRING_MANUFACTURER, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_product_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return get_device_string(dev, DEVICE_STRING_PRODUCT, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_serial_number_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+	return get_device_string(dev, DEVICE_STRING_SERIAL, string, maxlen);
+}
+
+int HID_API_EXPORT_CALL hid_get_indexed_string(hid_device *dev, int string_index, wchar_t *string, size_t maxlen)
+{
+	return -1;
+}
+
+
+HID_API_EXPORT const wchar_t * HID_API_CALL  hid_error(hid_device *dev)
+{
+	return NULL;
+}
diff -Nur -x debian -x .git -x .pc ./src/libambit/hidapi/hid-pcapsimulate.c ../openambit.git/src/libambit/hidapi/hid-pcapsimulate.c
--- ./src/libambit/hidapi/hid-pcapsimulate.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/hidapi/hid-pcapsimulate.c	2014-11-05 21:53:14.541131599 +0100
@@ -0,0 +1,442 @@
+/*******************************************************
+ HIDAPI simulation interface for PCAP files
+
+ Set PCAP-file to parse by setting environment variable
+ HIDAPI_PCAPSIMULATE_FILENAME to the file path
+********************************************************/
+
+/* C */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <pcap/pcap.h>
+
+#include "hidapi.h"
+
+/* Local definitions */
+struct hid_device_ {
+    pcap_t *pcap;
+    char errbuf[PCAP_ERRBUF_SIZE];
+    uint16_t last_write_command;
+    uint16_t last_sequence_number;
+    uint8_t reading_parts;
+};
+
+typedef struct device_id_mappings_s {
+    uint16_t vendor_id;
+    uint16_t product_id;
+    char *model;
+    char *manufacturer;
+    char *product;
+} device_id_mappings_t;
+
+// crc16.c
+uint16_t crc16_ccitt_false(unsigned char *buf, size_t buflen);
+uint16_t crc16_ccitt_false_init(unsigned char *buf, size_t buflen, uint16_t crc);
+
+/* Static functions */
+static pcap_t *pcap_file_reopen(pcap_t *old_pcap, char *errbuf);
+static const u_char *pcap_file_get_next(pcap_t *pcap);
+static const u_char *pcap_file_find_next_pkt(pcap_t *pcap, uint16_t command, uint8_t recv_not_send, const u_char *data);
+static uint16_t pcap_file_find_next_pkt_reass(pcap_t *pcap, uint16_t command, uint8_t recv_not_send, const u_char *data, u_char **buf);
+
+static hid_device *new_hid_device(void);
+static wchar_t *utf8_to_wchar_t(const char *utf8);
+
+
+/* Static data */
+static device_id_mappings_t device_id_mapping[] = {
+    { 0x1493, 0x001d, "Greentit", "Suunto", "Ambit" },
+    { 0x1493, 0x001c, "Finch", "Suunto", "Ambit" },
+    { 0x1493, 0x001b, "Emu", "Suunto", "Ambit" },
+    { 0x1493, 0x001a, "Colibri", "Suunto", "Ambit" },
+    { 0x1493, 0x0019, "Duck", "Suunto", "Ambit" },
+    { 0x1493, 0x0010, "Bluebird", "Suunto", "Ambit" }
+};
+static const device_id_mappings_t *detected_device = NULL;
+static char *detected_device_serial = NULL;
+
+int HID_API_EXPORT hid_init(void)
+{
+    pcap_t *pcap;
+    char errbuf[PCAP_ERRBUF_SIZE];
+    u_char *pktbuf;
+    uint16_t pktbuf_len;
+    char *model_string;
+    char *serial_string;
+    int i;
+
+    if (detected_device == NULL) {
+        pcap = pcap_file_reopen(NULL, errbuf);
+        if (pcap == NULL) {
+            return -1;
+        }
+
+        // Try to find device info in PCAP file
+        pktbuf_len = pcap_file_find_next_pkt_reass(pcap, 0x0002, 1, NULL, &pktbuf);
+
+        if (pktbuf_len > 0) {
+            model_string = (char*)pktbuf;
+            serial_string = (char*)(pktbuf + 16);
+
+            // Try to find matching model
+            for (i=0; i<sizeof(device_id_mapping)/sizeof(device_id_mapping[0]); i++) {
+                if (strncmp(device_id_mapping[i].model, model_string, 16) == 0) {
+                    detected_device = &device_id_mapping[i];
+                    detected_device_serial = malloc(17);
+                    strncpy(detected_device_serial, serial_string, 16);
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+int HID_API_EXPORT hid_exit(void)
+{
+    return 0;
+}
+
+
+struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id, unsigned short product_id)
+{
+    struct hid_device_info *root = NULL; /* return object */
+
+    hid_init();
+
+    if (detected_device != NULL) {
+        struct hid_device_info *tmp;
+
+        tmp = malloc(sizeof(struct hid_device_info));
+        tmp->next = NULL;
+
+        tmp->path = calloc(1, 1);
+        tmp->vendor_id = detected_device->vendor_id;
+        tmp->product_id = detected_device->product_id;
+        tmp->serial_number = utf8_to_wchar_t(detected_device_serial);
+        tmp->release_number = 0x0;
+        tmp->interface_number = -1;
+        tmp->manufacturer_string = utf8_to_wchar_t(detected_device->manufacturer);
+        tmp->product_string = utf8_to_wchar_t(detected_device->product);
+
+        root = tmp;
+    }
+
+    return root;
+}
+
+void  HID_API_EXPORT hid_free_enumeration(struct hid_device_info *devs)
+{
+    struct hid_device_info *d = devs;
+    while (d) {
+        struct hid_device_info *next = d->next;
+        free(d->path);
+        free(d->serial_number);
+        free(d->manufacturer_string);
+        free(d->product_string);
+        free(d);
+        d = next;
+    }
+}
+
+hid_device * hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number)
+{
+    hid_device *handle = NULL;
+
+    handle = hid_open_path(NULL);
+
+    return handle;
+}
+
+hid_device * HID_API_EXPORT hid_open_path(const char *path)
+{
+    hid_device *dev = NULL;
+
+    hid_init();
+
+    if (detected_device != NULL) {
+        dev = new_hid_device();
+        dev->pcap = pcap_file_reopen(NULL, dev->errbuf);
+        if (dev->pcap == NULL) {
+            return NULL;
+        }
+    }
+
+    return dev;
+}
+
+
+int HID_API_EXPORT hid_write(hid_device *dev, const unsigned char *data, size_t length)
+{
+    const u_char *pkt;
+    uint16_t command;
+    uint8_t pkt_part;
+    uint8_t len;
+
+    // Parse a few parts of the data
+    len = data[1];
+    pkt_part = data[2];
+    command = be16toh(*(uint16_t*)(data + 8));
+
+    // If this is a contineous write, we have to assume this is just fine, do
+    // nothing
+    if (pkt_part == 0x5d) {
+        // First try, search to end
+        pkt = pcap_file_find_next_pkt(dev->pcap, command, 0, len != 20 ? data + 20 : NULL);
+        if (pkt != NULL) {
+        }
+        // Second try, read from top
+        if (pkt == NULL) {
+            dev->pcap = pcap_file_reopen(dev->pcap, dev->errbuf);
+            pkt = pcap_file_find_next_pkt(dev->pcap, command, 0, len != 20 ? data + 20 : NULL);
+        }
+        if (pkt != NULL) {
+        }
+        // Third try, do not care about data
+        if (pkt == NULL) {
+            dev->pcap = pcap_file_reopen(dev->pcap, dev->errbuf);
+            pkt = pcap_file_find_next_pkt(dev->pcap, command, 0, NULL);
+        }
+        if (pkt != NULL) {
+        }
+
+        dev->last_write_command = command;
+        dev->last_sequence_number = le16toh(*(uint16_t*)(data + 14));
+        dev->reading_parts = 0;
+    }
+    
+    return pkt != NULL ? 0 : -1;
+}
+
+
+int HID_API_EXPORT hid_read_timeout(hid_device *dev, unsigned char *data, size_t length, int milliseconds)
+{
+    const u_char *pkt = NULL;
+    u_char tmpbuf[64];
+    uint16_t *payload_crc, tmpcrc;
+
+    // If we have already started to read parts, we should just continue with
+    // next valid packet, else we need to resolve first packet
+    if (dev->reading_parts) {
+        pkt = pcap_file_get_next(dev->pcap);
+    }
+    else {
+        // Search for next receive packet
+        pkt = pcap_file_find_next_pkt(dev->pcap, 0xffff, 1, NULL);
+    }
+
+    if (pkt != NULL) {
+        if (dev->reading_parts == 0) {
+            // If we found firstpacket, we need to rewrite sequence number and crc
+            memcpy(tmpbuf, pkt, 64);
+            *(uint16_t*)(tmpbuf + 14) = htole16(dev->last_sequence_number);
+            tmpcrc = crc16_ccitt_false(&tmpbuf[2], 4);
+            *(uint16_t*)(tmpbuf + 6) = htole16(tmpcrc);
+            payload_crc = (uint16_t *)&tmpbuf[tmpbuf[1]];
+            *payload_crc = htole16(crc16_ccitt_false_init(&tmpbuf[8], tmpbuf[3], tmpcrc));
+            pkt = tmpbuf;
+        }
+        dev->reading_parts = 1;
+        // Fix length
+        if (length > 64)
+            length = 64;
+        if (data != NULL) {
+            memcpy(data, pkt, length);
+        }
+        return length;
+    }
+    return -1;
+}
+
+int HID_API_EXPORT hid_read(hid_device *dev, unsigned char *data, size_t length)
+{
+    return hid_read_timeout(dev, data, length, 0);
+}
+
+int HID_API_EXPORT hid_set_nonblocking(hid_device *dev, int nonblock)
+{
+    return 0; /* Success */
+}
+
+
+int HID_API_EXPORT hid_send_feature_report(hid_device *dev, const unsigned char *data, size_t length)
+{
+    return 0;
+}
+
+int HID_API_EXPORT hid_get_feature_report(hid_device *dev, unsigned char *data, size_t length)
+{
+    return 0;
+}
+
+
+void HID_API_EXPORT hid_close(hid_device *dev)
+{
+    if (!dev)
+        return;
+
+    pcap_close(dev->pcap);
+}
+
+
+int HID_API_EXPORT_CALL hid_get_manufacturer_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+    return -1;
+}
+
+int HID_API_EXPORT_CALL hid_get_product_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+    return -1;
+}
+
+int HID_API_EXPORT_CALL hid_get_serial_number_string(hid_device *dev, wchar_t *string, size_t maxlen)
+{
+    return -1;
+}
+
+int HID_API_EXPORT_CALL hid_get_indexed_string(hid_device *dev, int string_index, wchar_t *string, size_t maxlen)
+{
+    return -1;
+}
+
+
+HID_API_EXPORT const wchar_t * HID_API_CALL  hid_error(hid_device *dev)
+{
+    return NULL;
+}
+
+static pcap_t *pcap_file_reopen(pcap_t *old_pcap, char *errbuf)
+{
+    char *pcap_file;
+    pcap_t *pcap = NULL;
+
+    if (old_pcap != NULL) {
+        pcap_close(old_pcap);
+    }
+
+    pcap_file = getenv("HIDAPI_PCAPSIMULATE_FILENAME");
+    if (pcap_file != NULL) {
+        pcap = pcap_open_offline(pcap_file, errbuf);
+        if (pcap == NULL) {
+            printf("Error: Failed to open pcap file %s\n", pcap_file);
+        }
+    }
+    else {
+        printf("Error: No HIDAPI_PCAPSIMULATE_FILENAME variable defined\n");
+    }
+
+    return pcap;
+}
+
+static const u_char *pcap_file_get_next(pcap_t *pcap)
+{
+    struct pcap_pkthdr h;
+    const u_char *pktdata;
+    size_t data_offset;
+
+    do {
+        pktdata = pcap_next(pcap, &h);
+        if (h.len == 128 || h.len == 91) { // Linux USB vs USBPcap
+            data_offset = h.len - 64;
+            if (pktdata[data_offset] == 0x3f) { // Sanity check, first byte
+                return pktdata + data_offset;
+            }
+        }
+    } while(pktdata != NULL);
+
+    return NULL;
+}
+
+static const u_char *pcap_file_find_next_pkt(pcap_t *pcap, uint16_t command, uint8_t recv_not_send, const u_char *data)
+{
+    const u_char *pktdata;
+
+    do {
+        pktdata = pcap_file_get_next(pcap);
+        if (pktdata != NULL) {
+            uint8_t len = pktdata[1];
+            uint8_t pkttype = pktdata[2];
+            uint16_t pktcommand = be16toh(*(uint16_t*)(pktdata + 8));
+            uint8_t send_recv = (pktdata[10] & 0x03) >> 1;
+            if (pkttype == 0x5d &&
+                (command == 0xffff || pktcommand == command) &&
+                send_recv == recv_not_send) {
+                if (data != NULL) {
+                    // Compare data as well
+                    if (memcmp(data, pktdata + 20, len - 20) == 0) {
+                        break;
+                    }
+                }
+                else {
+                    break;
+                }
+            }
+        }
+    } while(pktdata != NULL);
+
+    return pktdata;
+}
+
+static uint16_t pcap_file_find_next_pkt_reass(pcap_t *pcap, uint16_t command, uint8_t recv_not_send, const u_char *data, u_char **buf)
+{
+    const u_char *pkt;
+    u_char *retbuf = NULL;
+    uint16_t retlen = 0;
+    uint16_t msg_parts, msg_part;
+    uint16_t pkts_captured = 1;
+
+    pkt = pcap_file_find_next_pkt(pcap, command, recv_not_send, data);
+
+    if (pkt != NULL) {
+        // Check how many packets this entry should consist of
+        msg_parts = le16toh(*(uint16_t*)(pkt + 4));
+        retlen = le32toh(*(uint32_t*)(pkt + 16));
+        retbuf = malloc(44 + 56*(msg_parts-1));
+
+        if (retbuf != NULL) {
+            memcpy(retbuf, pkt + 20, 44);
+            while (msg_parts > pkts_captured) {
+                pkt = pcap_file_get_next(pcap);
+                if (pkt == NULL) {
+                    free(retbuf);
+                    retbuf = NULL;
+                    retlen = 0;
+                    break;
+                }
+                msg_part = le16toh(*(uint16_t*)(pkt + 4));
+                memcpy(retbuf + 44 + 56*(msg_part-1), pkt + 8, 56);
+                pkts_captured++;
+            }
+        }
+    }
+
+    *buf = retbuf;
+    return retlen;
+}
+
+static hid_device *new_hid_device(void)
+{
+    hid_device *dev = calloc(1, sizeof(hid_device));
+
+    return dev;
+}
+
+/* The caller must free the returned string with free(). */
+static wchar_t *utf8_to_wchar_t(const char *utf8)
+{
+    wchar_t *ret = NULL;
+
+    if (utf8) {
+        size_t wlen = mbstowcs(NULL, utf8, 0);
+        if ((size_t) -1 == wlen) {
+            return wcsdup(L"");
+        }
+        ret = calloc(wlen+1, sizeof(wchar_t));
+        mbstowcs(ret, utf8, wlen+1);
+        ret[wlen] = 0x0000;
+    }
+
+    return ret;
+}
diff -Nur -x debian -x .git -x .pc ./src/libambit/hid.c ../openambit.git/src/libambit/hid.c
--- ./src/libambit/hid.c	2014-09-17 21:24:42.966329637 +0200
+++ ../openambit.git/src/libambit/hid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,795 +0,0 @@
-/*******************************************************
- HIDAPI - Multi-Platform library for
- communication with HID devices.
-
- Alan Ott
- Signal 11 Software
-
- 8/22/2009
- Linux Version - 6/2/2009
-
- Copyright 2009, All Rights Reserved.
-
- At the discretion of the user of this library,
- this software may be licensed under the terms of the
- GNU General Public License v3, a BSD-Style license, or the
- original HIDAPI license as outlined in the LICENSE.txt,
- LICENSE-gpl3.txt, LICENSE-bsd.txt, and LICENSE-orig.txt
- files located at the root of the source distribution.
- These files may also be found in the public source
- code repository located at:
-        http://github.com/signal11/hidapi .
-********************************************************/
-
-/* C */
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <locale.h>
-#include <errno.h>
-
-/* Unix */
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <sys/utsname.h>
-#include <fcntl.h>
-#include <poll.h>
-
-/* Linux */
-#include <linux/hidraw.h>
-#include <linux/version.h>
-#include <linux/input.h>
-#include <libudev.h>
-
-#include "hidapi.h"
-
-/* Definitions from linux/hidraw.h. Since these are new, some distros
-   may not have header files which contain them. */
-#ifndef HIDIOCSFEATURE
-#define HIDIOCSFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x06, len)
-#endif
-#ifndef HIDIOCGFEATURE
-#define HIDIOCGFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x07, len)
-#endif
-
-
-/* USB HID device property names */
-const char *device_string_names[] = {
-	"manufacturer",
-	"product",
-	"serial",
-};
-
-/* Symbolic names for the properties above */
-enum device_string_id {
-	DEVICE_STRING_MANUFACTURER,
-	DEVICE_STRING_PRODUCT,
-	DEVICE_STRING_SERIAL,
-
-	DEVICE_STRING_COUNT,
-};
-
-struct hid_device_ {
-	int device_handle;
-	int blocking;
-	int uses_numbered_reports;
-};
-
-
-static __u32 kernel_version = 0;
-
-static __u32 detect_kernel_version(void)
-{
-	struct utsname name;
-	int major, minor, release;
-	int ret;
-
-	uname(&name);
-	ret = sscanf(name.release, "%d.%d.%d", &major, &minor, &release);
-	if (ret == 3) {
-		return KERNEL_VERSION(major, minor, release);
-	}
-
-	ret = sscanf(name.release, "%d.%d", &major, &minor);
-	if (ret == 2) {
-		return KERNEL_VERSION(major, minor, 0);
-	}
-
-	printf("Couldn't determine kernel version from version string \"%s\"\n", name.release);
-	return 0;
-}
-
-static hid_device *new_hid_device(void)
-{
-	hid_device *dev = calloc(1, sizeof(hid_device));
-	dev->device_handle = -1;
-	dev->blocking = 1;
-	dev->uses_numbered_reports = 0;
-
-	return dev;
-}
-
-
-/* The caller must free the returned string with free(). */
-static wchar_t *utf8_to_wchar_t(const char *utf8)
-{
-	wchar_t *ret = NULL;
-
-	if (utf8) {
-		size_t wlen = mbstowcs(NULL, utf8, 0);
-		if ((size_t) -1 == wlen) {
-			return wcsdup(L"");
-		}
-		ret = calloc(wlen+1, sizeof(wchar_t));
-		mbstowcs(ret, utf8, wlen+1);
-		ret[wlen] = 0x0000;
-	}
-
-	return ret;
-}
-
-/* Get an attribute value from a udev_device and return it as a whar_t
-   string. The returned string must be freed with free() when done.*/
-static wchar_t *copy_udev_string(struct udev_device *dev, const char *udev_name)
-{
-	return utf8_to_wchar_t(udev_device_get_sysattr_value(dev, udev_name));
-}
-
-/* uses_numbered_reports() returns 1 if report_descriptor describes a device
-   which contains numbered reports. */
-static int uses_numbered_reports(__u8 *report_descriptor, __u32 size) {
-	unsigned int i = 0;
-	int size_code;
-	int data_len, key_size;
-
-	while (i < size) {
-		int key = report_descriptor[i];
-
-		/* Check for the Report ID key */
-		if (key == 0x85/*Report ID*/) {
-			/* This device has a Report ID, which means it uses
-			   numbered reports. */
-			return 1;
-		}
-
-		//printf("key: %02hhx\n", key);
-
-		if ((key & 0xf0) == 0xf0) {
-			/* This is a Long Item. The next byte contains the
-			   length of the data section (value) for this key.
-			   See the HID specification, version 1.11, section
-			   6.2.2.3, titled "Long Items." */
-			if (i+1 < size)
-				data_len = report_descriptor[i+1];
-			else
-				data_len = 0; /* malformed report */
-			key_size = 3;
-		}
-		else {
-			/* This is a Short Item. The bottom two bits of the
-			   key contain the size code for the data section
-			   (value) for this key.  Refer to the HID
-			   specification, version 1.11, section 6.2.2.2,
-			   titled "Short Items." */
-			size_code = key & 0x3;
-			switch (size_code) {
-			case 0:
-			case 1:
-			case 2:
-				data_len = size_code;
-				break;
-			case 3:
-				data_len = 4;
-				break;
-			default:
-				/* Can't ever happen since size_code is & 0x3 */
-				data_len = 0;
-				break;
-			};
-			key_size = 1;
-		}
-
-		/* Skip over this key and it's associated data */
-		i += data_len + key_size;
-	}
-
-	/* Didn't find a Report ID key. Device doesn't use numbered reports. */
-	return 0;
-}
-
-/*
- * The caller is responsible for free()ing the (newly-allocated) character
- * strings pointed to by serial_number_utf8 and product_name_utf8 after use.
- */
-static int
-parse_uevent_info(const char *uevent, int *bus_type,
-	unsigned short *vendor_id, unsigned short *product_id,
-	char **serial_number_utf8, char **product_name_utf8)
-{
-	char *tmp = strdup(uevent);
-	char *saveptr = NULL;
-	char *line;
-	char *key;
-	char *value;
-
-	int found_id = 0;
-	int found_serial = 0;
-	int found_name = 0;
-
-	line = strtok_r(tmp, "\n", &saveptr);
-	while (line != NULL) {
-		/* line: "KEY=value" */
-		key = line;
-		value = strchr(line, '=');
-		if (!value) {
-			goto next_line;
-		}
-		*value = '\0';
-		value++;
-
-		if (strcmp(key, "HID_ID") == 0) {
-			/**
-			 *        type vendor   product
-			 * HID_ID=0003:000005AC:00008242
-			 **/
-			int ret = sscanf(value, "%x:%hx:%hx", bus_type, vendor_id, product_id);
-			if (ret == 3) {
-				found_id = 1;
-			}
-		} else if (strcmp(key, "HID_NAME") == 0) {
-			/* The caller has to free the product name */
-			*product_name_utf8 = strdup(value);
-			found_name = 1;
-		} else if (strcmp(key, "HID_UNIQ") == 0) {
-			/* The caller has to free the serial number */
-			*serial_number_utf8 = strdup(value);
-			found_serial = 1;
-		}
-
-next_line:
-		line = strtok_r(NULL, "\n", &saveptr);
-	}
-
-	free(tmp);
-	return (found_id && found_name && found_serial);
-}
-
-
-static int get_device_string(hid_device *dev, enum device_string_id key, wchar_t *string, size_t maxlen)
-{
-	struct udev *udev;
-	struct udev_device *udev_dev, *parent, *hid_dev;
-	struct stat s;
-	int ret = -1;
-        char *serial_number_utf8 = NULL;
-        char *product_name_utf8 = NULL;
-
-	/* Create the udev object */
-	udev = udev_new();
-	if (!udev) {
-		printf("Can't create udev\n");
-		return -1;
-	}
-
-	/* Get the dev_t (major/minor numbers) from the file handle. */
-	fstat(dev->device_handle, &s);
-	/* Open a udev device from the dev_t. 'c' means character device. */
-	udev_dev = udev_device_new_from_devnum(udev, 'c', s.st_rdev);
-	if (udev_dev) {
-		hid_dev = udev_device_get_parent_with_subsystem_devtype(
-			udev_dev,
-			"hid",
-			NULL);
-		if (hid_dev) {
-			unsigned short dev_vid;
-			unsigned short dev_pid;
-			int bus_type;
-			size_t retm;
-
-			ret = parse_uevent_info(
-			           udev_device_get_sysattr_value(hid_dev, "uevent"),
-			           &bus_type,
-			           &dev_vid,
-			           &dev_pid,
-			           &serial_number_utf8,
-			           &product_name_utf8);
-
-			if (bus_type == BUS_BLUETOOTH) {
-				switch (key) {
-					case DEVICE_STRING_MANUFACTURER:
-						wcsncpy(string, L"", maxlen);
-						ret = 0;
-						break;
-					case DEVICE_STRING_PRODUCT:
-						retm = mbstowcs(string, product_name_utf8, maxlen);
-						ret = (retm == (size_t)-1)? -1: 0;
-						break;
-					case DEVICE_STRING_SERIAL:
-						retm = mbstowcs(string, serial_number_utf8, maxlen);
-						ret = (retm == (size_t)-1)? -1: 0;
-						break;
-					case DEVICE_STRING_COUNT:
-					default:
-						ret = -1;
-						break;
-				}
-			}
-			else {
-				/* This is a USB device. Find its parent USB Device node. */
-				parent = udev_device_get_parent_with_subsystem_devtype(
-					   udev_dev,
-					   "usb",
-					   "usb_device");
-				if (parent) {
-					const char *str;
-					const char *key_str = NULL;
-
-					if (key >= 0 && key < DEVICE_STRING_COUNT) {
-						key_str = device_string_names[key];
-					} else {
-						ret = -1;
-						goto end;
-					}
-
-					str = udev_device_get_sysattr_value(parent, key_str);
-					if (str) {
-						/* Convert the string from UTF-8 to wchar_t */
-						retm = mbstowcs(string, str, maxlen);
-						ret = (retm == (size_t)-1)? -1: 0;
-						goto end;
-					}
-				}
-			}
-		}
-	}
-
-end:
-        free(serial_number_utf8);
-        free(product_name_utf8);
-
-	udev_device_unref(udev_dev);
-	/* parent and hid_dev don't need to be (and can't be) unref'd.
-	   I'm not sure why, but they'll throw double-free() errors. */
-	udev_unref(udev);
-
-	return ret;
-}
-
-int HID_API_EXPORT hid_init(void)
-{
-	const char *locale;
-
-	/* Set the locale if it's not set. */
-	locale = setlocale(LC_CTYPE, NULL);
-	if (!locale)
-		setlocale(LC_CTYPE, "");
-
-	kernel_version = detect_kernel_version();
-
-	return 0;
-}
-
-int HID_API_EXPORT hid_exit(void)
-{
-	/* Nothing to do for this in the Linux/hidraw implementation. */
-	return 0;
-}
-
-
-struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id, unsigned short product_id)
-{
-	struct udev *udev;
-	struct udev_enumerate *enumerate;
-	struct udev_list_entry *devices, *dev_list_entry;
-
-	struct hid_device_info *root = NULL; /* return object */
-	struct hid_device_info *cur_dev = NULL;
-	struct hid_device_info *prev_dev = NULL; /* previous device */
-
-	hid_init();
-
-	/* Create the udev object */
-	udev = udev_new();
-	if (!udev) {
-		printf("Can't create udev\n");
-		return NULL;
-	}
-
-	/* Create a list of the devices in the 'hidraw' subsystem. */
-	enumerate = udev_enumerate_new(udev);
-	udev_enumerate_add_match_subsystem(enumerate, "hidraw");
-	udev_enumerate_scan_devices(enumerate);
-	devices = udev_enumerate_get_list_entry(enumerate);
-	/* For each item, see if it matches the vid/pid, and if so
-	   create a udev_device record for it */
-	udev_list_entry_foreach(dev_list_entry, devices) {
-		const char *sysfs_path;
-		const char *dev_path;
-		const char *str;
-		struct udev_device *raw_dev; /* The device's hidraw udev node. */
-		struct udev_device *hid_dev; /* The device's HID udev node. */
-		struct udev_device *usb_dev; /* The device's USB udev node. */
-		struct udev_device *intf_dev; /* The device's interface (in the USB sense). */
-		unsigned short dev_vid;
-		unsigned short dev_pid;
-		char *serial_number_utf8 = NULL;
-		char *product_name_utf8 = NULL;
-		int bus_type;
-		int result;
-
-		/* Get the filename of the /sys entry for the device
-		   and create a udev_device object (dev) representing it */
-		sysfs_path = udev_list_entry_get_name(dev_list_entry);
-		raw_dev = udev_device_new_from_syspath(udev, sysfs_path);
-		dev_path = udev_device_get_devnode(raw_dev);
-
-		hid_dev = udev_device_get_parent_with_subsystem_devtype(
-			raw_dev,
-			"hid",
-			NULL);
-
-		if (!hid_dev) {
-			/* Unable to find parent hid device. */
-			goto next;
-		}
-
-		result = parse_uevent_info(
-			udev_device_get_sysattr_value(hid_dev, "uevent"),
-			&bus_type,
-			&dev_vid,
-			&dev_pid,
-			&serial_number_utf8,
-			&product_name_utf8);
-
-		if (!result) {
-			/* parse_uevent_info() failed for at least one field. */
-			goto next;
-		}
-
-		if (bus_type != BUS_USB && bus_type != BUS_BLUETOOTH) {
-			/* We only know how to handle USB and BT devices. */
-			goto next;
-		}
-
-		/* Check the VID/PID against the arguments */
-		if ((vendor_id == 0x0 || vendor_id == dev_vid) &&
-		    (product_id == 0x0 || product_id == dev_pid)) {
-			struct hid_device_info *tmp;
-
-			/* VID/PID match. Create the record. */
-			tmp = malloc(sizeof(struct hid_device_info));
-			if (cur_dev) {
-				cur_dev->next = tmp;
-			}
-			else {
-				root = tmp;
-			}
-			prev_dev = cur_dev;
-			cur_dev = tmp;
-
-			/* Fill out the record */
-			cur_dev->next = NULL;
-			cur_dev->path = dev_path? strdup(dev_path): NULL;
-
-			/* VID/PID */
-			cur_dev->vendor_id = dev_vid;
-			cur_dev->product_id = dev_pid;
-
-			/* Serial Number */
-			cur_dev->serial_number = utf8_to_wchar_t(serial_number_utf8);
-
-			/* Release Number */
-			cur_dev->release_number = 0x0;
-
-			/* Interface Number */
-			cur_dev->interface_number = -1;
-
-			switch (bus_type) {
-				case BUS_USB:
-					/* The device pointed to by raw_dev contains information about
-					   the hidraw device. In order to get information about the
-					   USB device, get the parent device with the
-					   subsystem/devtype pair of "usb"/"usb_device". This will
-					   be several levels up the tree, but the function will find
-					   it. */
-					usb_dev = udev_device_get_parent_with_subsystem_devtype(
-							raw_dev,
-							"usb",
-							"usb_device");
-
-					if (!usb_dev) {
-						/* Free this device */
-						free(cur_dev->serial_number);
-						free(cur_dev->path);
-						free(cur_dev);
-
-						/* Take it off the device list. */
-						if (prev_dev) {
-							prev_dev->next = NULL;
-							cur_dev = prev_dev;
-						}
-						else {
-							cur_dev = root = NULL;
-						}
-
-						goto next;
-					}
-
-					/* Manufacturer and Product strings */
-					cur_dev->manufacturer_string = copy_udev_string(usb_dev, device_string_names[DEVICE_STRING_MANUFACTURER]);
-					cur_dev->product_string = copy_udev_string(usb_dev, device_string_names[DEVICE_STRING_PRODUCT]);
-
-					/* Release Number */
-					str = udev_device_get_sysattr_value(usb_dev, "bcdDevice");
-					cur_dev->release_number = (str)? strtol(str, NULL, 16): 0x0;
-
-					/* Get a handle to the interface's udev node. */
-					intf_dev = udev_device_get_parent_with_subsystem_devtype(
-							raw_dev,
-							"usb",
-							"usb_interface");
-					if (intf_dev) {
-						str = udev_device_get_sysattr_value(intf_dev, "bInterfaceNumber");
-						cur_dev->interface_number = (str)? strtol(str, NULL, 16): -1;
-					}
-
-					break;
-
-				case BUS_BLUETOOTH:
-					/* Manufacturer and Product strings */
-					cur_dev->manufacturer_string = wcsdup(L"");
-					cur_dev->product_string = utf8_to_wchar_t(product_name_utf8);
-
-					break;
-
-				default:
-					/* Unknown device type - this should never happen, as we
-					 * check for USB and Bluetooth devices above */
-					break;
-			}
-		}
-
-	next:
-		free(serial_number_utf8);
-		free(product_name_utf8);
-		udev_device_unref(raw_dev);
-		/* hid_dev, usb_dev and intf_dev don't need to be (and can't be)
-		   unref()d.  It will cause a double-free() error.  I'm not
-		   sure why.  */
-	}
-	/* Free the enumerator and udev objects. */
-	udev_enumerate_unref(enumerate);
-	udev_unref(udev);
-
-	return root;
-}
-
-void  HID_API_EXPORT hid_free_enumeration(struct hid_device_info *devs)
-{
-	struct hid_device_info *d = devs;
-	while (d) {
-		struct hid_device_info *next = d->next;
-		free(d->path);
-		free(d->serial_number);
-		free(d->manufacturer_string);
-		free(d->product_string);
-		free(d);
-		d = next;
-	}
-}
-
-hid_device * hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number)
-{
-	struct hid_device_info *devs, *cur_dev;
-	const char *path_to_open = NULL;
-	hid_device *handle = NULL;
-
-	devs = hid_enumerate(vendor_id, product_id);
-	cur_dev = devs;
-	while (cur_dev) {
-		if (cur_dev->vendor_id == vendor_id &&
-		    cur_dev->product_id == product_id) {
-			if (serial_number) {
-				if (wcscmp(serial_number, cur_dev->serial_number) == 0) {
-					path_to_open = cur_dev->path;
-					break;
-				}
-			}
-			else {
-				path_to_open = cur_dev->path;
-				break;
-			}
-		}
-		cur_dev = cur_dev->next;
-	}
-
-	if (path_to_open) {
-		/* Open the device */
-		handle = hid_open_path(path_to_open);
-	}
-
-	hid_free_enumeration(devs);
-
-	return handle;
-}
-
-hid_device * HID_API_EXPORT hid_open_path(const char *path)
-{
-	hid_device *dev = NULL;
-
-	hid_init();
-
-	dev = new_hid_device();
-
-	/* OPEN HERE */
-	dev->device_handle = open(path, O_RDWR);
-
-	/* If we have a good handle, return it. */
-	if (dev->device_handle > 0) {
-
-		/* Get the report descriptor */
-		int res, desc_size = 0;
-		struct hidraw_report_descriptor rpt_desc;
-
-		memset(&rpt_desc, 0x0, sizeof(rpt_desc));
-
-		/* Get Report Descriptor Size */
-		res = ioctl(dev->device_handle, HIDIOCGRDESCSIZE, &desc_size);
-		if (res < 0)
-			perror("HIDIOCGRDESCSIZE");
-
-
-		/* Get Report Descriptor */
-		rpt_desc.size = desc_size;
-		res = ioctl(dev->device_handle, HIDIOCGRDESC, &rpt_desc);
-		if (res < 0) {
-			perror("HIDIOCGRDESC");
-		} else {
-			/* Determine if this device uses numbered reports. */
-			dev->uses_numbered_reports =
-				uses_numbered_reports(rpt_desc.value,
-				                      rpt_desc.size);
-		}
-
-		return dev;
-	}
-	else {
-		/* Unable to open any devices. */
-		free(dev);
-		return NULL;
-	}
-}
-
-
-int HID_API_EXPORT hid_write(hid_device *dev, const unsigned char *data, size_t length)
-{
-	int bytes_written;
-
-	bytes_written = write(dev->device_handle, data, length);
-
-	return bytes_written;
-}
-
-
-int HID_API_EXPORT hid_read_timeout(hid_device *dev, unsigned char *data, size_t length, int milliseconds)
-{
-	int bytes_read;
-
-	if (milliseconds >= 0) {
-		/* Milliseconds is either 0 (non-blocking) or > 0 (contains
-		   a valid timeout). In both cases we want to call poll()
-		   and wait for data to arrive.  Don't rely on non-blocking
-		   operation (O_NONBLOCK) since some kernels don't seem to
-		   properly report device disconnection through read() when
-		   in non-blocking mode.  */
-		int ret;
-		struct pollfd fds;
-
-		fds.fd = dev->device_handle;
-		fds.events = POLLIN;
-		fds.revents = 0;
-		ret = poll(&fds, 1, milliseconds);
-		if (ret == -1 || ret == 0) {
-			/* Error or timeout */
-			return ret;
-		}
-		else {
-			/* Check for errors on the file descriptor. This will
-			   indicate a device disconnection. */
-			if (fds.revents & (POLLERR | POLLHUP | POLLNVAL))
-				return -1;
-		}
-	}
-
-	bytes_read = read(dev->device_handle, data, length);
-	if (bytes_read < 0 && (errno == EAGAIN || errno == EINPROGRESS))
-		bytes_read = 0;
-
-	if (bytes_read >= 0 &&
-	    kernel_version != 0 &&
-	    kernel_version < KERNEL_VERSION(2,6,34) &&
-	    dev->uses_numbered_reports) {
-		/* Work around a kernel bug. Chop off the first byte. */
-		memmove(data, data+1, bytes_read);
-		bytes_read--;
-	}
-
-	return bytes_read;
-}
-
-int HID_API_EXPORT hid_read(hid_device *dev, unsigned char *data, size_t length)
-{
-	return hid_read_timeout(dev, data, length, (dev->blocking)? -1: 0);
-}
-
-int HID_API_EXPORT hid_set_nonblocking(hid_device *dev, int nonblock)
-{
-	/* Do all non-blocking in userspace using poll(), since it looks
-	   like there's a bug in the kernel in some versions where
-	   read() will not return -1 on disconnection of the USB device */
-
-	dev->blocking = !nonblock;
-	return 0; /* Success */
-}
-
-
-int HID_API_EXPORT hid_send_feature_report(hid_device *dev, const unsigned char *data, size_t length)
-{
-	int res;
-
-	res = ioctl(dev->device_handle, HIDIOCSFEATURE(length), data);
-	if (res < 0)
-		perror("ioctl (SFEATURE)");
-
-	return res;
-}
-
-int HID_API_EXPORT hid_get_feature_report(hid_device *dev, unsigned char *data, size_t length)
-{
-	int res;
-
-	res = ioctl(dev->device_handle, HIDIOCGFEATURE(length), data);
-	if (res < 0)
-		perror("ioctl (GFEATURE)");
-
-
-	return res;
-}
-
-
-void HID_API_EXPORT hid_close(hid_device *dev)
-{
-	if (!dev)
-		return;
-	close(dev->device_handle);
-	free(dev);
-}
-
-
-int HID_API_EXPORT_CALL hid_get_manufacturer_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return get_device_string(dev, DEVICE_STRING_MANUFACTURER, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_product_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return get_device_string(dev, DEVICE_STRING_PRODUCT, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_serial_number_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return get_device_string(dev, DEVICE_STRING_SERIAL, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_indexed_string(hid_device *dev, int string_index, wchar_t *string, size_t maxlen)
-{
-	return -1;
-}
-
-
-HID_API_EXPORT const wchar_t * HID_API_CALL  hid_error(hid_device *dev)
-{
-	return NULL;
-}
diff -Nur -x debian -x .git -x .pc ./src/libambit/hid-libusb.c ../openambit.git/src/libambit/hid-libusb.c
--- ./src/libambit/hid-libusb.c	2014-09-17 21:24:42.966329637 +0200
+++ ../openambit.git/src/libambit/hid-libusb.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1427 +0,0 @@
-/*******************************************************
- HIDAPI - Multi-Platform library for
- communication with HID devices.
-
- Alan Ott
- Signal 11 Software
-
- 8/22/2009
- Linux Version - 6/2/2010
- Libusb Version - 8/13/2010
- FreeBSD Version - 11/1/2011
-
- Copyright 2009, All Rights Reserved.
-
- At the discretion of the user of this library,
- this software may be licensed under the terms of the
- GNU General Public License v3, a BSD-Style license, or the
- original HIDAPI license as outlined in the LICENSE.txt,
- LICENSE-gpl3.txt, LICENSE-bsd.txt, and LICENSE-orig.txt
- files located at the root of the source distribution.
- These files may also be found in the public source
- code repository located at:
-        http://github.com/signal11/hidapi .
-********************************************************/
-
-#define _GNU_SOURCE /* needed for wcsdup() before glibc 2.10 */
-
-/* C */
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <ctype.h>
-#include <locale.h>
-#include <errno.h>
-
-/* Unix */
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <sys/utsname.h>
-#include <fcntl.h>
-#include <pthread.h>
-#include <wchar.h>
-
-/* GNU / LibUSB */
-#include "libusb.h"
-#include "iconv.h"
-
-#include "hidapi.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef DEBUG_PRINTF
-#define LOG(...) fprintf(stderr, __VA_ARGS__)
-#else
-#define LOG(...) do {} while (0)
-#endif
-
-#ifndef __FreeBSD__
-#define DETACH_KERNEL_DRIVER
-#endif
-
-/* Uncomment to enable the retrieval of Usage and Usage Page in
-hid_enumerate(). Warning, on platforms different from FreeBSD
-this is very invasive as it requires the detach
-and re-attach of the kernel driver. See comments inside hid_enumerate().
-libusb HIDAPI programs are encouraged to use the interface number
-instead to differentiate between interfaces on a composite HID device. */
-/*#define INVASIVE_GET_USAGE*/
-
-/* Linked List of input reports received from the device. */
-struct input_report {
-	uint8_t *data;
-	size_t len;
-	struct input_report *next;
-};
-
-
-struct hid_device_ {
-	/* Handle to the actual device. */
-	libusb_device_handle *device_handle;
-
-	/* Endpoint information */
-	int input_endpoint;
-	int output_endpoint;
-	int input_ep_max_packet_size;
-
-	/* The interface number of the HID */
-	int interface;
-
-	/* Indexes of Strings */
-	int manufacturer_index;
-	int product_index;
-	int serial_index;
-
-	/* Whether blocking reads are used */
-	int blocking; /* boolean */
-
-	/* Read thread objects */
-	pthread_t thread;
-	pthread_mutex_t mutex; /* Protects input_reports */
-	pthread_cond_t condition;
-	pthread_barrier_t barrier; /* Ensures correct startup sequence */
-	int shutdown_thread;
-	int cancelled;
-	struct libusb_transfer *transfer;
-
-	/* List of received input reports. */
-	struct input_report *input_reports;
-};
-
-static libusb_context *usb_context = NULL;
-
-uint16_t get_usb_code_for_current_locale(void);
-static int return_data(hid_device *dev, unsigned char *data, size_t length);
-
-static hid_device *new_hid_device(void)
-{
-	hid_device *dev = calloc(1, sizeof(hid_device));
-	dev->blocking = 1;
-
-	pthread_mutex_init(&dev->mutex, NULL);
-	pthread_cond_init(&dev->condition, NULL);
-	pthread_barrier_init(&dev->barrier, NULL, 2);
-
-	return dev;
-}
-
-static void free_hid_device(hid_device *dev)
-{
-	/* Clean up the thread objects */
-	pthread_barrier_destroy(&dev->barrier);
-	pthread_cond_destroy(&dev->condition);
-	pthread_mutex_destroy(&dev->mutex);
-
-	/* Free the device itself */
-	free(dev);
-}
-
-#if 0
-/*TODO: Implement this funciton on hidapi/libusb.. */
-static void register_error(hid_device *device, const char *op)
-{
-
-}
-#endif
-
-#ifdef INVASIVE_GET_USAGE
-/* Get bytes from a HID Report Descriptor.
-   Only call with a num_bytes of 0, 1, 2, or 4. */
-static uint32_t get_bytes(uint8_t *rpt, size_t len, size_t num_bytes, size_t cur)
-{
-	/* Return if there aren't enough bytes. */
-	if (cur + num_bytes >= len)
-		return 0;
-
-	if (num_bytes == 0)
-		return 0;
-	else if (num_bytes == 1) {
-		return rpt[cur+1];
-	}
-	else if (num_bytes == 2) {
-		return (rpt[cur+2] * 256 + rpt[cur+1]);
-	}
-	else if (num_bytes == 4) {
-		return (rpt[cur+4] * 0x01000000 +
-		        rpt[cur+3] * 0x00010000 +
-		        rpt[cur+2] * 0x00000100 +
-		        rpt[cur+1] * 0x00000001);
-	}
-	else
-		return 0;
-}
-
-/* Retrieves the device's Usage Page and Usage from the report
-   descriptor. The algorithm is simple, as it just returns the first
-   Usage and Usage Page that it finds in the descriptor.
-   The return value is 0 on success and -1 on failure. */
-static int get_usage(uint8_t *report_descriptor, size_t size,
-                     unsigned short *usage_page, unsigned short *usage)
-{
-	unsigned int i = 0;
-	int size_code;
-	int data_len, key_size;
-	int usage_found = 0, usage_page_found = 0;
-
-	while (i < size) {
-		int key = report_descriptor[i];
-		int key_cmd = key & 0xfc;
-
-		//printf("key: %02hhx\n", key);
-
-		if ((key & 0xf0) == 0xf0) {
-			/* This is a Long Item. The next byte contains the
-			   length of the data section (value) for this key.
-			   See the HID specification, version 1.11, section
-			   6.2.2.3, titled "Long Items." */
-			if (i+1 < size)
-				data_len = report_descriptor[i+1];
-			else
-				data_len = 0; /* malformed report */
-			key_size = 3;
-		}
-		else {
-			/* This is a Short Item. The bottom two bits of the
-			   key contain the size code for the data section
-			   (value) for this key.  Refer to the HID
-			   specification, version 1.11, section 6.2.2.2,
-			   titled "Short Items." */
-			size_code = key & 0x3;
-			switch (size_code) {
-			case 0:
-			case 1:
-			case 2:
-				data_len = size_code;
-				break;
-			case 3:
-				data_len = 4;
-				break;
-			default:
-				/* Can't ever happen since size_code is & 0x3 */
-				data_len = 0;
-				break;
-			};
-			key_size = 1;
-		}
-
-		if (key_cmd == 0x4) {
-			*usage_page  = get_bytes(report_descriptor, size, data_len, i);
-			usage_page_found = 1;
-			//printf("Usage Page: %x\n", (uint32_t)*usage_page);
-		}
-		if (key_cmd == 0x8) {
-			*usage = get_bytes(report_descriptor, size, data_len, i);
-			usage_found = 1;
-			//printf("Usage: %x\n", (uint32_t)*usage);
-		}
-
-		if (usage_page_found && usage_found)
-			return 0; /* success */
-
-		/* Skip over this key and it's associated data */
-		i += data_len + key_size;
-	}
-
-	return -1; /* failure */
-}
-#endif /* INVASIVE_GET_USAGE */
-
-#ifdef __FreeBSD__
-/* The FreeBSD version of libusb doesn't have this funciton. In mainline
-   libusb, it's inlined in libusb.h. This function will bear a striking
-   resemblence to that one, because there's about one way to code it.
-
-   Note that the data parameter is Unicode in UTF-16LE encoding.
-   Return value is the number of bytes in data, or LIBUSB_ERROR_*.
- */
-static inline int libusb_get_string_descriptor(libusb_device_handle *dev,
-	uint8_t descriptor_index, uint16_t lang_id,
-	unsigned char *data, int length)
-{
-	return libusb_control_transfer(dev,
-		LIBUSB_ENDPOINT_IN | 0x0, /* Endpoint 0 IN */
-		LIBUSB_REQUEST_GET_DESCRIPTOR,
-		(LIBUSB_DT_STRING << 8) | descriptor_index,
-		lang_id, data, (uint16_t) length, 1000);
-}
-
-#endif
-
-
-/* Get the first language the device says it reports. This comes from
-   USB string #0. */
-static uint16_t get_first_language(libusb_device_handle *dev)
-{
-	uint16_t buf[32];
-	int len;
-
-	/* Get the string from libusb. */
-	len = libusb_get_string_descriptor(dev,
-			0x0, /* String ID */
-			0x0, /* Language */
-			(unsigned char*)buf,
-			sizeof(buf));
-	if (len < 4)
-		return 0x0;
-
-	return buf[1]; /* First two bytes are len and descriptor type. */
-}
-
-static int is_language_supported(libusb_device_handle *dev, uint16_t lang)
-{
-	uint16_t buf[32];
-	int len;
-	int i;
-
-	/* Get the string from libusb. */
-	len = libusb_get_string_descriptor(dev,
-			0x0, /* String ID */
-			0x0, /* Language */
-			(unsigned char*)buf,
-			sizeof(buf));
-	if (len < 4)
-		return 0x0;
-
-
-	len /= 2; /* language IDs are two-bytes each. */
-	/* Start at index 1 because there are two bytes of protocol data. */
-	for (i = 1; i < len; i++) {
-		if (buf[i] == lang)
-			return 1;
-	}
-
-	return 0;
-}
-
-
-/* This function returns a newly allocated wide string containing the USB
-   device string numbered by the index. The returned string must be freed
-   by using free(). */
-static wchar_t *get_usb_string(libusb_device_handle *dev, uint8_t idx)
-{
-	char buf[512];
-	int len;
-	wchar_t *str = NULL;
-	wchar_t wbuf[256];
-
-	/* iconv variables */
-	iconv_t ic;
-	size_t inbytes;
-	size_t outbytes;
-	size_t res;
-#ifdef __FreeBSD__
-	const char *inptr;
-#else
-	char *inptr;
-#endif
-	char *outptr;
-
-	/* Determine which language to use. */
-	uint16_t lang;
-	lang = get_usb_code_for_current_locale();
-	if (!is_language_supported(dev, lang))
-		lang = get_first_language(dev);
-
-	/* Get the string from libusb. */
-	len = libusb_get_string_descriptor(dev,
-			idx,
-			lang,
-			(unsigned char*)buf,
-			sizeof(buf));
-	if (len < 0)
-		return NULL;
-
-	/* buf does not need to be explicitly NULL-terminated because
-	   it is only passed into iconv() which does not need it. */
-
-	/* Initialize iconv. */
-	ic = iconv_open("WCHAR_T", "UTF-16LE");
-	if (ic == (iconv_t)-1) {
-		LOG("iconv_open() failed\n");
-		return NULL;
-	}
-
-	/* Convert to native wchar_t (UTF-32 on glibc/BSD systems).
-	   Skip the first character (2-bytes). */
-	inptr = buf+2;
-	inbytes = len-2;
-	outptr = (char*) wbuf;
-	outbytes = sizeof(wbuf);
-	res = iconv(ic, &inptr, &inbytes, &outptr, &outbytes);
-	if (res == (size_t)-1) {
-		LOG("iconv() failed\n");
-		goto err;
-	}
-
-	/* Write the terminating NULL. */
-	wbuf[sizeof(wbuf)/sizeof(wbuf[0])-1] = 0x00000000;
-	if (outbytes >= sizeof(wbuf[0]))
-		*((wchar_t*)outptr) = 0x00000000;
-
-	/* Allocate and copy the string. */
-	str = wcsdup(wbuf);
-
-err:
-	iconv_close(ic);
-
-	return str;
-}
-
-static char *make_path(libusb_device *dev, int interface_number)
-{
-	char str[64];
-	snprintf(str, sizeof(str), "%04x:%04x:%02x",
-		libusb_get_bus_number(dev),
-		libusb_get_device_address(dev),
-		interface_number);
-	str[sizeof(str)-1] = '\0';
-
-	return strdup(str);
-}
-
-
-int HID_API_EXPORT hid_init(void)
-{
-	if (!usb_context) {
-		const char *locale;
-
-		/* Init Libusb */
-		if (libusb_init(&usb_context))
-			return -1;
-
-		/* Set the locale if it's not set. */
-		locale = setlocale(LC_CTYPE, NULL);
-		if (!locale)
-			setlocale(LC_CTYPE, "");
-	}
-
-	return 0;
-}
-
-int HID_API_EXPORT hid_exit(void)
-{
-	if (usb_context) {
-		libusb_exit(usb_context);
-		usb_context = NULL;
-	}
-
-	return 0;
-}
-
-struct hid_device_info  HID_API_EXPORT *hid_enumerate(unsigned short vendor_id, unsigned short product_id)
-{
-	libusb_device **devs;
-	libusb_device *dev;
-	libusb_device_handle *handle;
-	ssize_t num_devs;
-	int i = 0;
-
-	struct hid_device_info *root = NULL; /* return object */
-	struct hid_device_info *cur_dev = NULL;
-
-	if(hid_init() < 0)
-		return NULL;
-
-	num_devs = libusb_get_device_list(usb_context, &devs);
-	if (num_devs < 0)
-		return NULL;
-	while ((dev = devs[i++]) != NULL) {
-		struct libusb_device_descriptor desc;
-		struct libusb_config_descriptor *conf_desc = NULL;
-		int j, k;
-		int interface_num = 0;
-
-		int res = libusb_get_device_descriptor(dev, &desc);
-		unsigned short dev_vid = desc.idVendor;
-		unsigned short dev_pid = desc.idProduct;
-
-		res = libusb_get_active_config_descriptor(dev, &conf_desc);
-		if (res < 0)
-			libusb_get_config_descriptor(dev, 0, &conf_desc);
-		if (conf_desc) {
-			for (j = 0; j < conf_desc->bNumInterfaces; j++) {
-				const struct libusb_interface *intf = &conf_desc->interface[j];
-				for (k = 0; k < intf->num_altsetting; k++) {
-					const struct libusb_interface_descriptor *intf_desc;
-					intf_desc = &intf->altsetting[k];
-					if (intf_desc->bInterfaceClass == LIBUSB_CLASS_HID) {
-						interface_num = intf_desc->bInterfaceNumber;
-
-						/* Check the VID/PID against the arguments */
-						if ((vendor_id == 0x0 || vendor_id == dev_vid) &&
-						    (product_id == 0x0 || product_id == dev_pid)) {
-							struct hid_device_info *tmp;
-
-							/* VID/PID match. Create the record. */
-							tmp = calloc(1, sizeof(struct hid_device_info));
-							if (cur_dev) {
-								cur_dev->next = tmp;
-							}
-							else {
-								root = tmp;
-							}
-							cur_dev = tmp;
-
-							/* Fill out the record */
-							cur_dev->next = NULL;
-							cur_dev->path = make_path(dev, interface_num);
-
-							res = libusb_open(dev, &handle);
-
-							if (res >= 0) {
-								/* Serial Number */
-								if (desc.iSerialNumber > 0)
-									cur_dev->serial_number =
-										get_usb_string(handle, desc.iSerialNumber);
-
-								/* Manufacturer and Product strings */
-								if (desc.iManufacturer > 0)
-									cur_dev->manufacturer_string =
-										get_usb_string(handle, desc.iManufacturer);
-								if (desc.iProduct > 0)
-									cur_dev->product_string =
-										get_usb_string(handle, desc.iProduct);
-
-#ifdef INVASIVE_GET_USAGE
-{
-							/*
-							This section is removed because it is too
-							invasive on the system. Getting a Usage Page
-							and Usage requires parsing the HID Report
-							descriptor. Getting a HID Report descriptor
-							involves claiming the interface. Claiming the
-							interface involves detaching the kernel driver.
-							Detaching the kernel driver is hard on the system
-							because it will unclaim interfaces (if another
-							app has them claimed) and the re-attachment of
-							the driver will sometimes change /dev entry names.
-							It is for these reasons that this section is
-							#if 0. For composite devices, use the interface
-							field in the hid_device_info struct to distinguish
-							between interfaces. */
-								unsigned char data[256];
-#ifdef DETACH_KERNEL_DRIVER
-								int detached = 0;
-								/* Usage Page and Usage */
-								res = libusb_kernel_driver_active(handle, interface_num);
-								if (res == 1) {
-									res = libusb_detach_kernel_driver(handle, interface_num);
-									if (res < 0)
-										LOG("Couldn't detach kernel driver, even though a kernel driver was attached.");
-									else
-										detached = 1;
-								}
-#endif
-								res = libusb_claim_interface(handle, interface_num);
-								if (res >= 0) {
-									/* Get the HID Report Descriptor. */
-									res = libusb_control_transfer(handle, LIBUSB_ENDPOINT_IN|LIBUSB_RECIPIENT_INTERFACE, LIBUSB_REQUEST_GET_DESCRIPTOR, (LIBUSB_DT_REPORT << 8)|interface_num, 0, data, sizeof(data), 5000);
-									if (res >= 0) {
-										unsigned short page=0, usage=0;
-										/* Parse the usage and usage page
-										   out of the report descriptor. */
-										get_usage(data, res,  &page, &usage);
-										cur_dev->usage_page = page;
-										cur_dev->usage = usage;
-									}
-									else
-										LOG("libusb_control_transfer() for getting the HID report failed with %d\n", res);
-
-									/* Release the interface */
-									res = libusb_release_interface(handle, interface_num);
-									if (res < 0)
-										LOG("Can't release the interface.\n");
-								}
-								else
-									LOG("Can't claim interface %d\n", res);
-#ifdef DETACH_KERNEL_DRIVER
-								/* Re-attach kernel driver if necessary. */
-								if (detached) {
-									res = libusb_attach_kernel_driver(handle, interface_num);
-									if (res < 0)
-										LOG("Couldn't re-attach kernel driver.\n");
-								}
-#endif
-}
-#endif /* INVASIVE_GET_USAGE */
-
-								libusb_close(handle);
-							}
-							/* VID/PID */
-							cur_dev->vendor_id = dev_vid;
-							cur_dev->product_id = dev_pid;
-
-							/* Release Number */
-							cur_dev->release_number = desc.bcdDevice;
-
-							/* Interface Number */
-							cur_dev->interface_number = interface_num;
-						}
-					}
-				} /* altsettings */
-			} /* interfaces */
-			libusb_free_config_descriptor(conf_desc);
-		}
-	}
-
-	libusb_free_device_list(devs, 1);
-
-	return root;
-}
-
-void  HID_API_EXPORT hid_free_enumeration(struct hid_device_info *devs)
-{
-	struct hid_device_info *d = devs;
-	while (d) {
-		struct hid_device_info *next = d->next;
-		free(d->path);
-		free(d->serial_number);
-		free(d->manufacturer_string);
-		free(d->product_string);
-		free(d);
-		d = next;
-	}
-}
-
-hid_device * hid_open(unsigned short vendor_id, unsigned short product_id, const wchar_t *serial_number)
-{
-	struct hid_device_info *devs, *cur_dev;
-	const char *path_to_open = NULL;
-	hid_device *handle = NULL;
-
-	devs = hid_enumerate(vendor_id, product_id);
-	cur_dev = devs;
-	while (cur_dev) {
-		if (cur_dev->vendor_id == vendor_id &&
-		    cur_dev->product_id == product_id) {
-			if (serial_number) {
-				if (wcscmp(serial_number, cur_dev->serial_number) == 0) {
-					path_to_open = cur_dev->path;
-					break;
-				}
-			}
-			else {
-				path_to_open = cur_dev->path;
-				break;
-			}
-		}
-		cur_dev = cur_dev->next;
-	}
-
-	if (path_to_open) {
-		/* Open the device */
-		handle = hid_open_path(path_to_open);
-	}
-
-	hid_free_enumeration(devs);
-
-	return handle;
-}
-
-static void read_callback(struct libusb_transfer *transfer)
-{
-	hid_device *dev = transfer->user_data;
-	int res;
-
-	if (transfer->status == LIBUSB_TRANSFER_COMPLETED) {
-
-		struct input_report *rpt = malloc(sizeof(*rpt));
-		rpt->data = malloc(transfer->actual_length);
-		memcpy(rpt->data, transfer->buffer, transfer->actual_length);
-		rpt->len = transfer->actual_length;
-		rpt->next = NULL;
-
-		pthread_mutex_lock(&dev->mutex);
-
-		/* Attach the new report object to the end of the list. */
-		if (dev->input_reports == NULL) {
-			/* The list is empty. Put it at the root. */
-			dev->input_reports = rpt;
-			pthread_cond_signal(&dev->condition);
-		}
-		else {
-			/* Find the end of the list and attach. */
-			struct input_report *cur = dev->input_reports;
-			int num_queued = 0;
-			while (cur->next != NULL) {
-				cur = cur->next;
-				num_queued++;
-			}
-			cur->next = rpt;
-
-			/* Pop one off if we've reached 30 in the queue. This
-			   way we don't grow forever if the user never reads
-			   anything from the device. */
-			if (num_queued > 30) {
-				return_data(dev, NULL, 0);
-			}
-		}
-		pthread_mutex_unlock(&dev->mutex);
-	}
-	else if (transfer->status == LIBUSB_TRANSFER_CANCELLED) {
-		dev->shutdown_thread = 1;
-		dev->cancelled = 1;
-		return;
-	}
-	else if (transfer->status == LIBUSB_TRANSFER_NO_DEVICE) {
-		dev->shutdown_thread = 1;
-		dev->cancelled = 1;
-		return;
-	}
-	else if (transfer->status == LIBUSB_TRANSFER_TIMED_OUT) {
-		//LOG("Timeout (normal)\n");
-	}
-	else {
-		LOG("Unknown transfer code: %d\n", transfer->status);
-	}
-
-	/* Re-submit the transfer object. */
-	res = libusb_submit_transfer(transfer);
-	if (res != 0) {
-		LOG("Unable to submit URB. libusb error code: %d\n", res);
-		dev->shutdown_thread = 1;
-		dev->cancelled = 1;
-	}
-}
-
-
-static void *read_thread(void *param)
-{
-	hid_device *dev = param;
-	unsigned char *buf;
-	const size_t length = dev->input_ep_max_packet_size;
-
-	/* Set up the transfer object. */
-	buf = malloc(length);
-	dev->transfer = libusb_alloc_transfer(0);
-	libusb_fill_interrupt_transfer(dev->transfer,
-		dev->device_handle,
-		dev->input_endpoint,
-		buf,
-		length,
-		read_callback,
-		dev,
-		5000/*timeout*/);
-
-	/* Make the first submission. Further submissions are made
-	   from inside read_callback() */
-	libusb_submit_transfer(dev->transfer);
-
-	/* Notify the main thread that the read thread is up and running. */
-	pthread_barrier_wait(&dev->barrier);
-
-	/* Handle all the events. */
-	while (!dev->shutdown_thread) {
-		int res;
-		res = libusb_handle_events(usb_context);
-		if (res < 0) {
-			/* There was an error. */
-			LOG("read_thread(): libusb reports error # %d\n", res);
-
-			/* Break out of this loop only on fatal error.*/
-			if (res != LIBUSB_ERROR_BUSY &&
-			    res != LIBUSB_ERROR_TIMEOUT &&
-			    res != LIBUSB_ERROR_OVERFLOW &&
-			    res != LIBUSB_ERROR_INTERRUPTED) {
-				break;
-			}
-		}
-	}
-
-	/* Cancel any transfer that may be pending. This call will fail
-	   if no transfers are pending, but that's OK. */
-	libusb_cancel_transfer(dev->transfer);
-
-	while (!dev->cancelled)
-		libusb_handle_events_completed(usb_context, &dev->cancelled);
-
-	/* Now that the read thread is stopping, Wake any threads which are
-	   waiting on data (in hid_read_timeout()). Do this under a mutex to
-	   make sure that a thread which is about to go to sleep waiting on
-	   the condition acutally will go to sleep before the condition is
-	   signaled. */
-	pthread_mutex_lock(&dev->mutex);
-	pthread_cond_broadcast(&dev->condition);
-	pthread_mutex_unlock(&dev->mutex);
-
-	/* The dev->transfer->buffer and dev->transfer objects are cleaned up
-	   in hid_close(). They are not cleaned up here because this thread
-	   could end either due to a disconnect or due to a user
-	   call to hid_close(). In both cases the objects can be safely
-	   cleaned up after the call to pthread_join() (in hid_close()), but
-	   since hid_close() calls libusb_cancel_transfer(), on these objects,
-	   they can not be cleaned up here. */
-
-	return NULL;
-}
-
-
-hid_device * HID_API_EXPORT hid_open_path(const char *path)
-{
-	hid_device *dev = NULL;
-
-	libusb_device **devs;
-	libusb_device *usb_dev;
-	int res;
-	int d = 0;
-	int good_open = 0;
-
-	if(hid_init() < 0)
-		return NULL;
-
-	dev = new_hid_device();
-
-	libusb_get_device_list(usb_context, &devs);
-	while ((usb_dev = devs[d++]) != NULL) {
-		struct libusb_device_descriptor desc;
-		struct libusb_config_descriptor *conf_desc = NULL;
-		int i,j,k;
-		libusb_get_device_descriptor(usb_dev, &desc);
-
-		if (libusb_get_active_config_descriptor(usb_dev, &conf_desc) < 0)
-			continue;
-		for (j = 0; j < conf_desc->bNumInterfaces; j++) {
-			const struct libusb_interface *intf = &conf_desc->interface[j];
-			for (k = 0; k < intf->num_altsetting; k++) {
-				const struct libusb_interface_descriptor *intf_desc;
-				intf_desc = &intf->altsetting[k];
-				if (intf_desc->bInterfaceClass == LIBUSB_CLASS_HID) {
-					char *dev_path = make_path(usb_dev, intf_desc->bInterfaceNumber);
-					if (!strcmp(dev_path, path)) {
-						/* Matched Paths. Open this device */
-
-						/* OPEN HERE */
-						res = libusb_open(usb_dev, &dev->device_handle);
-						if (res < 0) {
-							LOG("can't open device\n");
-							free(dev_path);
-							break;
-						}
-						good_open = 1;
-#ifdef DETACH_KERNEL_DRIVER
-						/* Detach the kernel driver, but only if the
-						   device is managed by the kernel */
-						if (libusb_kernel_driver_active(dev->device_handle, intf_desc->bInterfaceNumber) == 1) {
-							res = libusb_detach_kernel_driver(dev->device_handle, intf_desc->bInterfaceNumber);
-							if (res < 0) {
-								libusb_close(dev->device_handle);
-								LOG("Unable to detach Kernel Driver\n");
-								free(dev_path);
-								good_open = 0;
-								break;
-							}
-						}
-#endif
-						res = libusb_claim_interface(dev->device_handle, intf_desc->bInterfaceNumber);
-						if (res < 0) {
-							LOG("can't claim interface %d: %d\n", intf_desc->bInterfaceNumber, res);
-							free(dev_path);
-							libusb_close(dev->device_handle);
-							good_open = 0;
-							break;
-						}
-
-						/* Store off the string descriptor indexes */
-						dev->manufacturer_index = desc.iManufacturer;
-						dev->product_index      = desc.iProduct;
-						dev->serial_index       = desc.iSerialNumber;
-
-						/* Store off the interface number */
-						dev->interface = intf_desc->bInterfaceNumber;
-
-						/* Find the INPUT and OUTPUT endpoints. An
-						   OUTPUT endpoint is not required. */
-						for (i = 0; i < intf_desc->bNumEndpoints; i++) {
-							const struct libusb_endpoint_descriptor *ep
-								= &intf_desc->endpoint[i];
-
-							/* Determine the type and direction of this
-							   endpoint. */
-							int is_interrupt =
-								(ep->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK)
-							      == LIBUSB_TRANSFER_TYPE_INTERRUPT;
-							int is_output =
-								(ep->bEndpointAddress & LIBUSB_ENDPOINT_DIR_MASK)
-							      == LIBUSB_ENDPOINT_OUT;
-							int is_input =
-								(ep->bEndpointAddress & LIBUSB_ENDPOINT_DIR_MASK)
-							      == LIBUSB_ENDPOINT_IN;
-
-							/* Decide whether to use it for intput or output. */
-							if (dev->input_endpoint == 0 &&
-							    is_interrupt && is_input) {
-								/* Use this endpoint for INPUT */
-								dev->input_endpoint = ep->bEndpointAddress;
-								dev->input_ep_max_packet_size = ep->wMaxPacketSize;
-							}
-							if (dev->output_endpoint == 0 &&
-							    is_interrupt && is_output) {
-								/* Use this endpoint for OUTPUT */
-								dev->output_endpoint = ep->bEndpointAddress;
-							}
-						}
-
-						pthread_create(&dev->thread, NULL, read_thread, dev);
-
-						/* Wait here for the read thread to be initialized. */
-						pthread_barrier_wait(&dev->barrier);
-
-					}
-					free(dev_path);
-				}
-			}
-		}
-		libusb_free_config_descriptor(conf_desc);
-
-	}
-
-	libusb_free_device_list(devs, 1);
-
-	/* If we have a good handle, return it. */
-	if (good_open) {
-		return dev;
-	}
-	else {
-		/* Unable to open any devices. */
-		free_hid_device(dev);
-		return NULL;
-	}
-}
-
-
-int HID_API_EXPORT hid_write(hid_device *dev, const unsigned char *data, size_t length)
-{
-	int res;
-	int report_number = data[0];
-	int skipped_report_id = 0;
-
-	if (report_number == 0x0) {
-		data++;
-		length--;
-		skipped_report_id = 1;
-	}
-
-
-	if (dev->output_endpoint <= 0) {
-		/* No interrput out endpoint. Use the Control Endpoint */
-		res = libusb_control_transfer(dev->device_handle,
-			LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_OUT,
-			0x09/*HID Set_Report*/,
-			(2/*HID output*/ << 8) | report_number,
-			dev->interface,
-			(unsigned char *)data, length,
-			1000/*timeout millis*/);
-
-		if (res < 0)
-			return -1;
-
-		if (skipped_report_id)
-			length++;
-
-		return length;
-	}
-	else {
-		/* Use the interrupt out endpoint */
-		int actual_length;
-		res = libusb_interrupt_transfer(dev->device_handle,
-			dev->output_endpoint,
-			(unsigned char*)data,
-			length,
-			&actual_length, 1000);
-
-		if (res < 0)
-			return -1;
-
-		if (skipped_report_id)
-			actual_length++;
-
-		return actual_length;
-	}
-}
-
-/* Helper function, to simplify hid_read().
-   This should be called with dev->mutex locked. */
-static int return_data(hid_device *dev, unsigned char *data, size_t length)
-{
-	/* Copy the data out of the linked list item (rpt) into the
-	   return buffer (data), and delete the liked list item. */
-	struct input_report *rpt = dev->input_reports;
-	size_t len = (length < rpt->len)? length: rpt->len;
-	if (len > 0)
-		memcpy(data, rpt->data, len);
-	dev->input_reports = rpt->next;
-	free(rpt->data);
-	free(rpt);
-	return len;
-}
-
-static void cleanup_mutex(void *param)
-{
-	hid_device *dev = param;
-	pthread_mutex_unlock(&dev->mutex);
-}
-
-
-int HID_API_EXPORT hid_read_timeout(hid_device *dev, unsigned char *data, size_t length, int milliseconds)
-{
-	int bytes_read = -1;
-
-#if 0
-	int transferred;
-	int res = libusb_interrupt_transfer(dev->device_handle, dev->input_endpoint, data, length, &transferred, 5000);
-	LOG("transferred: %d\n", transferred);
-	return transferred;
-#endif
-
-	pthread_mutex_lock(&dev->mutex);
-	pthread_cleanup_push(&cleanup_mutex, dev);
-
-	/* There's an input report queued up. Return it. */
-	if (dev->input_reports) {
-		/* Return the first one */
-		bytes_read = return_data(dev, data, length);
-		goto ret;
-	}
-
-	if (dev->shutdown_thread) {
-		/* This means the device has been disconnected.
-		   An error code of -1 should be returned. */
-		bytes_read = -1;
-		goto ret;
-	}
-
-	if (milliseconds == -1) {
-		/* Blocking */
-		while (!dev->input_reports && !dev->shutdown_thread) {
-			pthread_cond_wait(&dev->condition, &dev->mutex);
-		}
-		if (dev->input_reports) {
-			bytes_read = return_data(dev, data, length);
-		}
-	}
-	else if (milliseconds > 0) {
-		/* Non-blocking, but called with timeout. */
-		int res;
-		struct timespec ts;
-		clock_gettime(CLOCK_REALTIME, &ts);
-		ts.tv_sec += milliseconds / 1000;
-		ts.tv_nsec += (milliseconds % 1000) * 1000000;
-		if (ts.tv_nsec >= 1000000000L) {
-			ts.tv_sec++;
-			ts.tv_nsec -= 1000000000L;
-		}
-
-		while (!dev->input_reports && !dev->shutdown_thread) {
-			res = pthread_cond_timedwait(&dev->condition, &dev->mutex, &ts);
-			if (res == 0) {
-				if (dev->input_reports) {
-					bytes_read = return_data(dev, data, length);
-					break;
-				}
-
-				/* If we're here, there was a spurious wake up
-				   or the read thread was shutdown. Run the
-				   loop again (ie: don't break). */
-			}
-			else if (res == ETIMEDOUT) {
-				/* Timed out. */
-				bytes_read = 0;
-				break;
-			}
-			else {
-				/* Error. */
-				bytes_read = -1;
-				break;
-			}
-		}
-	}
-	else {
-		/* Purely non-blocking */
-		bytes_read = 0;
-	}
-
-ret:
-	pthread_mutex_unlock(&dev->mutex);
-	pthread_cleanup_pop(0);
-
-	return bytes_read;
-}
-
-int HID_API_EXPORT hid_read(hid_device *dev, unsigned char *data, size_t length)
-{
-	return hid_read_timeout(dev, data, length, dev->blocking ? -1 : 0);
-}
-
-int HID_API_EXPORT hid_set_nonblocking(hid_device *dev, int nonblock)
-{
-	dev->blocking = !nonblock;
-
-	return 0;
-}
-
-
-int HID_API_EXPORT hid_send_feature_report(hid_device *dev, const unsigned char *data, size_t length)
-{
-	int res = -1;
-	int skipped_report_id = 0;
-	int report_number = data[0];
-
-	if (report_number == 0x0) {
-		data++;
-		length--;
-		skipped_report_id = 1;
-	}
-
-	res = libusb_control_transfer(dev->device_handle,
-		LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_OUT,
-		0x09/*HID set_report*/,
-		(3/*HID feature*/ << 8) | report_number,
-		dev->interface,
-		(unsigned char *)data, length,
-		1000/*timeout millis*/);
-
-	if (res < 0)
-		return -1;
-
-	/* Account for the report ID */
-	if (skipped_report_id)
-		length++;
-
-	return length;
-}
-
-int HID_API_EXPORT hid_get_feature_report(hid_device *dev, unsigned char *data, size_t length)
-{
-	int res = -1;
-	int skipped_report_id = 0;
-	int report_number = data[0];
-
-	if (report_number == 0x0) {
-		/* Offset the return buffer by 1, so that the report ID
-		   will remain in byte 0. */
-		data++;
-		length--;
-		skipped_report_id = 1;
-	}
-	res = libusb_control_transfer(dev->device_handle,
-		LIBUSB_REQUEST_TYPE_CLASS|LIBUSB_RECIPIENT_INTERFACE|LIBUSB_ENDPOINT_IN,
-		0x01/*HID get_report*/,
-		(3/*HID feature*/ << 8) | report_number,
-		dev->interface,
-		(unsigned char *)data, length,
-		1000/*timeout millis*/);
-
-	if (res < 0)
-		return -1;
-
-	if (skipped_report_id)
-		res++;
-
-	return res;
-}
-
-
-void HID_API_EXPORT hid_close(hid_device *dev)
-{
-	if (!dev)
-		return;
-
-	/* Cause read_thread() to stop. */
-	dev->shutdown_thread = 1;
-	libusb_cancel_transfer(dev->transfer);
-
-	/* Wait for read_thread() to end. */
-	pthread_join(dev->thread, NULL);
-
-	/* Clean up the Transfer objects allocated in read_thread(). */
-	free(dev->transfer->buffer);
-	libusb_free_transfer(dev->transfer);
-
-	/* release the interface */
-	libusb_release_interface(dev->device_handle, dev->interface);
-
-	/* Close the handle */
-	libusb_close(dev->device_handle);
-
-	/* Clear out the queue of received reports. */
-	pthread_mutex_lock(&dev->mutex);
-	while (dev->input_reports) {
-		return_data(dev, NULL, 0);
-	}
-	pthread_mutex_unlock(&dev->mutex);
-
-	free_hid_device(dev);
-}
-
-
-int HID_API_EXPORT_CALL hid_get_manufacturer_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return hid_get_indexed_string(dev, dev->manufacturer_index, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_product_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return hid_get_indexed_string(dev, dev->product_index, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_serial_number_string(hid_device *dev, wchar_t *string, size_t maxlen)
-{
-	return hid_get_indexed_string(dev, dev->serial_index, string, maxlen);
-}
-
-int HID_API_EXPORT_CALL hid_get_indexed_string(hid_device *dev, int string_index, wchar_t *string, size_t maxlen)
-{
-	wchar_t *str;
-
-	str = get_usb_string(dev->device_handle, string_index);
-	if (str) {
-		wcsncpy(string, str, maxlen);
-		string[maxlen-1] = L'\0';
-		free(str);
-		return 0;
-	}
-	else
-		return -1;
-}
-
-
-HID_API_EXPORT const wchar_t * HID_API_CALL  hid_error(hid_device *dev)
-{
-	return NULL;
-}
-
-
-struct lang_map_entry {
-	const char *name;
-	const char *string_code;
-	uint16_t usb_code;
-};
-
-#define LANG(name,code,usb_code) { name, code, usb_code }
-static struct lang_map_entry lang_map[] = {
-	LANG("Afrikaans", "af", 0x0436),
-	LANG("Albanian", "sq", 0x041C),
-	LANG("Arabic - United Arab Emirates", "ar_ae", 0x3801),
-	LANG("Arabic - Bahrain", "ar_bh", 0x3C01),
-	LANG("Arabic - Algeria", "ar_dz", 0x1401),
-	LANG("Arabic - Egypt", "ar_eg", 0x0C01),
-	LANG("Arabic - Iraq", "ar_iq", 0x0801),
-	LANG("Arabic - Jordan", "ar_jo", 0x2C01),
-	LANG("Arabic - Kuwait", "ar_kw", 0x3401),
-	LANG("Arabic - Lebanon", "ar_lb", 0x3001),
-	LANG("Arabic - Libya", "ar_ly", 0x1001),
-	LANG("Arabic - Morocco", "ar_ma", 0x1801),
-	LANG("Arabic - Oman", "ar_om", 0x2001),
-	LANG("Arabic - Qatar", "ar_qa", 0x4001),
-	LANG("Arabic - Saudi Arabia", "ar_sa", 0x0401),
-	LANG("Arabic - Syria", "ar_sy", 0x2801),
-	LANG("Arabic - Tunisia", "ar_tn", 0x1C01),
-	LANG("Arabic - Yemen", "ar_ye", 0x2401),
-	LANG("Armenian", "hy", 0x042B),
-	LANG("Azeri - Latin", "az_az", 0x042C),
-	LANG("Azeri - Cyrillic", "az_az", 0x082C),
-	LANG("Basque", "eu", 0x042D),
-	LANG("Belarusian", "be", 0x0423),
-	LANG("Bulgarian", "bg", 0x0402),
-	LANG("Catalan", "ca", 0x0403),
-	LANG("Chinese - China", "zh_cn", 0x0804),
-	LANG("Chinese - Hong Kong SAR", "zh_hk", 0x0C04),
-	LANG("Chinese - Macau SAR", "zh_mo", 0x1404),
-	LANG("Chinese - Singapore", "zh_sg", 0x1004),
-	LANG("Chinese - Taiwan", "zh_tw", 0x0404),
-	LANG("Croatian", "hr", 0x041A),
-	LANG("Czech", "cs", 0x0405),
-	LANG("Danish", "da", 0x0406),
-	LANG("Dutch - Netherlands", "nl_nl", 0x0413),
-	LANG("Dutch - Belgium", "nl_be", 0x0813),
-	LANG("English - Australia", "en_au", 0x0C09),
-	LANG("English - Belize", "en_bz", 0x2809),
-	LANG("English - Canada", "en_ca", 0x1009),
-	LANG("English - Caribbean", "en_cb", 0x2409),
-	LANG("English - Ireland", "en_ie", 0x1809),
-	LANG("English - Jamaica", "en_jm", 0x2009),
-	LANG("English - New Zealand", "en_nz", 0x1409),
-	LANG("English - Phillippines", "en_ph", 0x3409),
-	LANG("English - Southern Africa", "en_za", 0x1C09),
-	LANG("English - Trinidad", "en_tt", 0x2C09),
-	LANG("English - Great Britain", "en_gb", 0x0809),
-	LANG("English - United States", "en_us", 0x0409),
-	LANG("Estonian", "et", 0x0425),
-	LANG("Farsi", "fa", 0x0429),
-	LANG("Finnish", "fi", 0x040B),
-	LANG("Faroese", "fo", 0x0438),
-	LANG("French - France", "fr_fr", 0x040C),
-	LANG("French - Belgium", "fr_be", 0x080C),
-	LANG("French - Canada", "fr_ca", 0x0C0C),
-	LANG("French - Luxembourg", "fr_lu", 0x140C),
-	LANG("French - Switzerland", "fr_ch", 0x100C),
-	LANG("Gaelic - Ireland", "gd_ie", 0x083C),
-	LANG("Gaelic - Scotland", "gd", 0x043C),
-	LANG("German - Germany", "de_de", 0x0407),
-	LANG("German - Austria", "de_at", 0x0C07),
-	LANG("German - Liechtenstein", "de_li", 0x1407),
-	LANG("German - Luxembourg", "de_lu", 0x1007),
-	LANG("German - Switzerland", "de_ch", 0x0807),
-	LANG("Greek", "el", 0x0408),
-	LANG("Hebrew", "he", 0x040D),
-	LANG("Hindi", "hi", 0x0439),
-	LANG("Hungarian", "hu", 0x040E),
-	LANG("Icelandic", "is", 0x040F),
-	LANG("Indonesian", "id", 0x0421),
-	LANG("Italian - Italy", "it_it", 0x0410),
-	LANG("Italian - Switzerland", "it_ch", 0x0810),
-	LANG("Japanese", "ja", 0x0411),
-	LANG("Korean", "ko", 0x0412),
-	LANG("Latvian", "lv", 0x0426),
-	LANG("Lithuanian", "lt", 0x0427),
-	LANG("F.Y.R.O. Macedonia", "mk", 0x042F),
-	LANG("Malay - Malaysia", "ms_my", 0x043E),
-	LANG("Malay – Brunei", "ms_bn", 0x083E),
-	LANG("Maltese", "mt", 0x043A),
-	LANG("Marathi", "mr", 0x044E),
-	LANG("Norwegian - Bokml", "no_no", 0x0414),
-	LANG("Norwegian - Nynorsk", "no_no", 0x0814),
-	LANG("Polish", "pl", 0x0415),
-	LANG("Portuguese - Portugal", "pt_pt", 0x0816),
-	LANG("Portuguese - Brazil", "pt_br", 0x0416),
-	LANG("Raeto-Romance", "rm", 0x0417),
-	LANG("Romanian - Romania", "ro", 0x0418),
-	LANG("Romanian - Republic of Moldova", "ro_mo", 0x0818),
-	LANG("Russian", "ru", 0x0419),
-	LANG("Russian - Republic of Moldova", "ru_mo", 0x0819),
-	LANG("Sanskrit", "sa", 0x044F),
-	LANG("Serbian - Cyrillic", "sr_sp", 0x0C1A),
-	LANG("Serbian - Latin", "sr_sp", 0x081A),
-	LANG("Setsuana", "tn", 0x0432),
-	LANG("Slovenian", "sl", 0x0424),
-	LANG("Slovak", "sk", 0x041B),
-	LANG("Sorbian", "sb", 0x042E),
-	LANG("Spanish - Spain (Traditional)", "es_es", 0x040A),
-	LANG("Spanish - Argentina", "es_ar", 0x2C0A),
-	LANG("Spanish - Bolivia", "es_bo", 0x400A),
-	LANG("Spanish - Chile", "es_cl", 0x340A),
-	LANG("Spanish - Colombia", "es_co", 0x240A),
-	LANG("Spanish - Costa Rica", "es_cr", 0x140A),
-	LANG("Spanish - Dominican Republic", "es_do", 0x1C0A),
-	LANG("Spanish - Ecuador", "es_ec", 0x300A),
-	LANG("Spanish - Guatemala", "es_gt", 0x100A),
-	LANG("Spanish - Honduras", "es_hn", 0x480A),
-	LANG("Spanish - Mexico", "es_mx", 0x080A),
-	LANG("Spanish - Nicaragua", "es_ni", 0x4C0A),
-	LANG("Spanish - Panama", "es_pa", 0x180A),
-	LANG("Spanish - Peru", "es_pe", 0x280A),
-	LANG("Spanish - Puerto Rico", "es_pr", 0x500A),
-	LANG("Spanish - Paraguay", "es_py", 0x3C0A),
-	LANG("Spanish - El Salvador", "es_sv", 0x440A),
-	LANG("Spanish - Uruguay", "es_uy", 0x380A),
-	LANG("Spanish - Venezuela", "es_ve", 0x200A),
-	LANG("Southern Sotho", "st", 0x0430),
-	LANG("Swahili", "sw", 0x0441),
-	LANG("Swedish - Sweden", "sv_se", 0x041D),
-	LANG("Swedish - Finland", "sv_fi", 0x081D),
-	LANG("Tamil", "ta", 0x0449),
-	LANG("Tatar", "tt", 0X0444),
-	LANG("Thai", "th", 0x041E),
-	LANG("Turkish", "tr", 0x041F),
-	LANG("Tsonga", "ts", 0x0431),
-	LANG("Ukrainian", "uk", 0x0422),
-	LANG("Urdu", "ur", 0x0420),
-	LANG("Uzbek - Cyrillic", "uz_uz", 0x0843),
-	LANG("Uzbek – Latin", "uz_uz", 0x0443),
-	LANG("Vietnamese", "vi", 0x042A),
-	LANG("Xhosa", "xh", 0x0434),
-	LANG("Yiddish", "yi", 0x043D),
-	LANG("Zulu", "zu", 0x0435),
-	LANG(NULL, NULL, 0x0),
-};
-
-uint16_t get_usb_code_for_current_locale(void)
-{
-	char *locale;
-	char search_string[64];
-	char *ptr;
-	struct lang_map_entry *lang;
-
-	/* Get the current locale. */
-	locale = setlocale(0, NULL);
-	if (!locale)
-		return 0x0;
-
-	/* Make a copy of the current locale string. */
-	strncpy(search_string, locale, sizeof(search_string));
-	search_string[sizeof(search_string)-1] = '\0';
-
-	/* Chop off the encoding part, and make it lower case. */
-	ptr = search_string;
-	while (*ptr) {
-		*ptr = tolower(*ptr);
-		if (*ptr == '.') {
-			*ptr = '\0';
-			break;
-		}
-		ptr++;
-	}
-
-	/* Find the entry which matches the string code of our locale. */
-	lang = lang_map;
-	while (lang->string_code) {
-		if (!strcmp(lang->string_code, search_string)) {
-			return lang->usb_code;
-		}
-		lang++;
-	}
-
-	/* There was no match. Find with just the language only. */
-	/* Chop off the variant. Chop it off at the '_'. */
-	ptr = search_string;
-	while (*ptr) {
-		*ptr = tolower(*ptr);
-		if (*ptr == '_') {
-			*ptr = '\0';
-			break;
-		}
-		ptr++;
-	}
-
-#if 0 /* TODO: Do we need this? */
-	/* Find the entry which matches the string code of our language. */
-	lang = lang_map;
-	while (lang->string_code) {
-		if (!strcmp(lang->string_code, search_string)) {
-			return lang->usb_code;
-		}
-		lang++;
-	}
-#endif
-
-	/* Found nothing. */
-	return 0x0;
-}
-
-#ifdef __cplusplus
-}
-#endif
diff -Nur -x debian -x .git -x .pc ./src/libambit/libambit.c ../openambit.git/src/libambit/libambit.c
--- ./src/libambit/libambit.c	2014-09-17 21:28:00.560501284 +0200
+++ ../openambit.git/src/libambit/libambit.c	2014-11-05 21:53:14.561132025 +0100
@@ -21,10 +21,17 @@
  */
 #include "libambit.h"
 #include "libambit_int.h"
+#include "device_support.h"
+#include "device_driver.h"
+#include "protocol.h"
+#include "debug.h"
 
 #include <errno.h>
+#include <iconv.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <wchar.h>
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -34,221 +41,172 @@
 /*
  * Local definitions
  */
-#define SUUNTO_USB_VENDOR_ID 0x1493
-
-typedef struct ambit_known_device_s ambit_known_device_t;
-
-struct ambit_known_device_s {
-    uint16_t vid;
-    uint16_t pid;
-    char *model;
-    uint8_t min_sw_version[4];
-    char *name;
-    bool supported;
-    uint16_t pmem20_chunksize;
-};
 
 /*
  * Static functions
  */
 static int device_info_get(ambit_object_t *object, ambit_device_info_t *info);
-static int lock_log(ambit_object_t *object, bool lock);
-static uint32_t version_number(const uint8_t version[4]);
+static ambit_device_info_t * ambit_device_info_new(const struct hid_device_info *dev);
 
 /*
  * Static variables
  */
-static ambit_known_device_t known_devices[] = {
-    { SUUNTO_USB_VENDOR_ID, 0x001c, "Finch", {0x00,0x00,0x00,0x00}, "Suunto Ambit3 Sport", false, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x001b, "Emu", {0x00,0x00,0x00,0x00}, "Suunto Ambit3 Peak", false, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x001d, "Greentit", {0x00,0x00,0x00,0x00}, "Suunto Ambit2 R", true, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x01,0x01,0x02,0x00}, "Suunto Ambit2 S", true, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x01,0x01,0x02,0x00}, "Suunto Ambit2", true, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x00,0x02,0x03,0x00}, "Suunto Ambit2 S", false, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x00,0x02,0x03,0x00}, "Suunto Ambit2", false, 0x0400 },
-    { SUUNTO_USB_VENDOR_ID, 0x001a, "Colibri", {0x00,0x02,0x02,0x00}, "Suunto Ambit2 S (up to 0.2.2)", false, 0x0200 },
-    { SUUNTO_USB_VENDOR_ID, 0x0019, "Duck", {0x00,0x02,0x02,0x00}, "Suunto Ambit2 (up to 0.2.2)", false, 0x0200 },
-    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x02,0x01,0x00,0x00}, "Suunto Ambit", true, 0x0200 },
-    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x09,0x00,0x00}, "Suunto Ambit", false, 0x0200 }, /* First with PMEM 2.0!? */
-    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x06,0x00,0x00}, "Suunto Ambit", false, 0 },
-    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x01,0x01,0x00,0x00}, "Suunto Ambit", false, 0 },
-    { SUUNTO_USB_VENDOR_ID, 0x0010, "Bluebird", {0x00,0x00,0x00,0x00}, "Suunto Ambit", false, 0 },
-    { 0x0000, 0x0000, NULL, {0x00,0x00,0x00,0x00}, NULL, false }
-};
-
 static uint8_t komposti_version[] = { 0x01, 0x08, 0x01, 0x00 };
 
 /*
  * Public functions
  */
-ambit_object_t *libambit_detect(void)
+ambit_device_info_t * libambit_enumerate(void)
 {
-    hid_device *handle;
-    struct hid_device_info *devs, *cur_dev;
-    ambit_object_t *ret_object = NULL;
-    int i;
-    ambit_known_device_t *device = NULL;
-    char *path = NULL;
+    ambit_device_info_t *devices = NULL;
 
-    LOG_INFO("Searching devices");
+    struct hid_device_info *devs = hid_enumerate(0, 0);
+    struct hid_device_info *current;
 
-    devs = hid_enumerate(0x0, 0x0);
-    cur_dev = devs;
-    while (cur_dev) {
-        LOG_INFO("vendor_id=%04x, product_id=%04x", cur_dev->vendor_id, cur_dev->product_id);
-        for (i=0; i<sizeof(known_devices)/sizeof(known_devices[0]); i++) {
-            if (cur_dev->vendor_id == known_devices[i].vid && cur_dev->product_id == known_devices[i].pid) {
-                LOG_INFO("match!");
-                // Found at least one supported row, lets remember that!
-                device = &known_devices[i];
-                path = strdup (cur_dev->path);
-                break;
-            }
-        }
-        if (device != NULL) {
-            // Devcice was found, we can stop looping through devices now...
-            break;
-        }
-        cur_dev = cur_dev->next;
+    if (!devs) {
+      LOG_WARNING("HID: no USB HID devices found");
+      return NULL;
     }
-    hid_free_enumeration(devs);
 
-    if (device != NULL) {
-        LOG_INFO("Trying to open device");
-        handle = hid_open(device->vid, device->pid, NULL);
-        if (handle != NULL) {
-            // Setup hid device correctly
-            hid_set_nonblocking(handle, 1);
-
-            ret_object = malloc(sizeof(ambit_object_t));
-            memset(ret_object, 0, sizeof(ambit_object_t));
-            ret_object->handle = handle;
-            ret_object->vendor_id = device->vid;
-            ret_object->product_id = device->pid;
-
-            // Get device info to resolve supported functionality
-            if (device_info_get(ret_object, &ret_object->device_info) == 0) {
-                // Let's resolve the correct device
-                for (i=0; i<sizeof(known_devices)/sizeof(known_devices[0]); i++) {
-                    if (ret_object->vendor_id == known_devices[i].vid &&
-                        ret_object->product_id == known_devices[i].pid &&
-                        strncmp(ret_object->device_info.model, known_devices[i].model, LIBAMBIT_MODEL_NAME_LENGTH) == 0 &&
-                        (version_number (ret_object->device_info.fw_version) >= version_number (known_devices[i].min_sw_version))) {
-                        // Found matching entry, reset to this one!
-                        device = &known_devices[i];
-                        break;
-                    }
-                }
-                strncpy(ret_object->device_info.name, device->name, LIBAMBIT_PRODUCT_NAME_LENGTH);
-                ret_object->device_info.is_supported = device->supported;
+    current = devs;
+    while (current) {
+        ambit_device_info_t *tmp = ambit_device_info_new(current);
 
-                // Initialize pmem
-                libambit_pmem20_init(ret_object, device->pmem20_chunksize);
-
-                LOG_INFO("Successfully opened device \"%s (%s)\" SW: %d.%d.%d, Supported: %s", device->name, device->model, ret_object->device_info.fw_version[0], ret_object->device_info.fw_version[1], ret_object->device_info.fw_version[3] << 8 | ret_object->device_info.fw_version[2], device->supported ? "YES" : "NO");
+        if (tmp) {
+            if (devices) {
+                tmp->next = devices;
             }
             else {
-                free(ret_object);
-                ret_object = NULL;
-                LOG_ERROR("Failed to get device info from \"%s (%s)\"", device->name, device->model);
+                devices = tmp;
             }
         }
-        else {
-#ifdef DEBUG_PRINT_ERROR
-            int error = 0;
-            int fd = 0;
-            if (path) fd = open (path, O_RDWR);
-            if (-1 == fd) error = errno;
-            else close (fd);
-#endif
-            LOG_ERROR("Failed to open device \"%s (%s)\"", device->name, device->model);
-            LOG_ERROR("Reason: %s", (error ? strerror(error) : "Unknown"));
-        }
+        current = current->next;
     }
+    hid_free_enumeration(devs);
 
-    if (path) free (path);
-    return ret_object;
+    return devices;
 }
 
-void libambit_close(ambit_object_t *object)
+void libambit_free_enumeration(ambit_device_info_t *devices)
 {
-    LOG_INFO("Closing");
-    if (object != NULL) {
-        if (object->handle != NULL) {
-            // Make sure to clear log lock (if possible)
-            lock_log(object, false);
-            hid_close(object->handle);
-        }
-
-        libambit_pmem20_deinit(object);
-        free(object);
+    while (devices) {
+        ambit_device_info_t *next = devices->next;
+        free((char *) devices->path);
+        free(devices);
+        devices = next;
     }
 }
 
-bool libambit_device_supported(ambit_object_t *object)
+ambit_object_t * libambit_new(const ambit_device_info_t *device)
 {
-    bool ret = false;
+    ambit_object_t *object = NULL;
+    const ambit_known_device_t *known_device = NULL;
+    const char *path = NULL;
 
-    if (object != NULL) {
-        ret = object->device_info.is_supported;
+    if (!device || !device->path) {
+        LOG_ERROR("%s", strerror(EINVAL));
+        return NULL;
     }
 
-    return ret;
+    path = strdup (device->path);
+    if (!path) return NULL;
+
+    if (0 == device->access_status && device->is_supported) {
+        // Note, this should never fail if device was properly received with libambit_enumerate
+        known_device = libambit_device_support_find(device->vendor_id, device->product_id, device->model, device->fw_version);
+        if (known_device != NULL) {
+            object = calloc(1, sizeof(*object));
+            if (object) {
+                object->handle = hid_open_path(path);
+                memcpy(&object->device_info, device, sizeof(*device));
+                object->device_info.path = path;
+                object->driver = known_device->driver;
+
+                if (object->handle) {
+                    hid_set_nonblocking(object->handle, true);
+                }
+
+                // Initialize driver
+                object->driver->init(object, known_device->driver_param);
+            }
+        }
+    }
+    if (!object) {
+        free((char *) path);
+    }
+
+    return object;
 }
 
-int libambit_device_info_get(ambit_object_t *object, ambit_device_info_t *info)
+ambit_object_t * libambit_new_from_pathname(const char* pathname)
 {
-    int ret = -1;
+    ambit_object_t *object = NULL;
+    ambit_device_info_t *info;
+    ambit_device_info_t *current;
 
-    if (object != NULL) {
-        if (info != NULL) {
-            memcpy(info, &object->device_info, sizeof(ambit_device_info_t));
+    if (!pathname) {
+        LOG_ERROR("%s", strerror(EINVAL));
+        return NULL;
+    }
+
+    info = libambit_enumerate();
+    current = info;
+    while (!object && current) {
+        if (0 == strcmp(pathname, current->path)) {
+            object = libambit_new(current);
         }
-        ret = 0;
+        current = current->next;
     }
+    libambit_free_enumeration(info);
 
-    return ret;
+    return object;
+}
+
+void libambit_close(ambit_object_t *object)
+{
+    LOG_INFO("Closing");
+    if (object != NULL) {
+        if (object->driver != NULL) {
+            // Make sure to clear log lock (if possible)
+            if (object->driver->lock_log != NULL) {
+                object->driver->lock_log(object, false);
+            }
+            if (object->driver->deinit != NULL) {
+                object->driver->deinit(object);
+            }
+        }
+        if (object->handle != NULL) {
+            hid_close(object->handle);
+        }
+
+        free((char *) object->device_info.path);
+        free(object);
+    }
 }
 
 void libambit_sync_display_show(ambit_object_t *object)
 {
-    lock_log(object, true);
+    if (object->driver != NULL && object->driver->lock_log != NULL) {
+        object->driver->lock_log(object, true);
+    }
 }
 
 void libambit_sync_display_clear(ambit_object_t *object)
 {
-    lock_log(object, false);
+    if (object->driver != NULL && object->driver->lock_log != NULL) {
+        object->driver->lock_log(object, false);
+    }
 }
 
 int libambit_date_time_set(ambit_object_t *object, struct tm *tm)
 {
-    uint8_t date_data[8] = { 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00 };
-    uint8_t time_data[8];
     int ret = -1;
 
-    LOG_INFO("Writing date and time to clock");
-
-    // Set date
-    *(uint16_t*)(&date_data[0]) = htole16(1900 + tm->tm_year);
-    date_data[2] = 1 + tm->tm_mon;
-    date_data[3] = tm->tm_mday;
-    // byte[4-7] unknown (but set to 0x28000000 in moveslink)
-
-    // Set time (+date)
-    *(uint16_t*)(&time_data[0]) = htole16(1900 + tm->tm_year);
-    time_data[2] = 1 + tm->tm_mon;
-    time_data[3] = tm->tm_mday;
-    time_data[4] = tm->tm_hour;
-    time_data[5] = tm->tm_min;
-    *(uint16_t*)(&time_data[6]) = htole16(1000*tm->tm_sec);
-
-    if (libambit_protocol_command(object, ambit_command_date, date_data, sizeof(date_data), NULL, NULL, 0) == 0 &&
-        libambit_protocol_command(object, ambit_command_time, time_data, sizeof(time_data), NULL, NULL, 0) == 0) {
-
-        ret = 0;
+    if (object->driver != NULL && object->driver->date_time_set != NULL) {
+        ret = object->driver->date_time_set(object, tm);
     }
     else {
-        LOG_WARNING("Failed to write date and time");
+        LOG_WARNING("Driver does not support date_time_set");
     }
 
     return ret;
@@ -256,41 +214,27 @@
 
 int libambit_device_status_get(ambit_object_t *object, ambit_device_status_t *status)
 {
-    uint8_t *reply_data = NULL;
-    size_t replylen;
     int ret = -1;
 
-    LOG_INFO("Reading device status");
-
-    if (libambit_protocol_command(object, ambit_command_status, NULL, 0, &reply_data, &replylen, 0) == 0) {
-        if (status != NULL) {
-            status->charge = reply_data[1];
-        }
-        ret = 0;
+    if (object->driver != NULL && object->driver->status_get != NULL) {
+        ret = object->driver->status_get(object, status);
     }
     else {
-        LOG_WARNING("Failed to read device status");
+        LOG_WARNING("Driver does not support status_get");
     }
 
-    libambit_protocol_free(reply_data);
-
     return ret;
 }
 
 int libambit_personal_settings_get(ambit_object_t *object, ambit_personal_settings_t *settings)
 {
-    uint8_t *reply_data = NULL;
-    size_t replylen = 0;
     int ret = -1;
 
-    LOG_INFO("Reading personal settings");
-
-    if (libambit_protocol_command(object, ambit_command_personal_settings, NULL, 0, &reply_data, &replylen, 0) == 0) {
-        ret = libambit_personal_settings_parse(reply_data, replylen, settings);
-        libambit_protocol_free(reply_data);
+    if (object->driver != NULL && object->driver->personal_settings_get != NULL) {
+        ret = object->driver->personal_settings_get(object, settings);
     }
     else {
-        LOG_WARNING("Failed to read personal settings");
+        LOG_WARNING("Driver does not support personal_settings_get");
     }
 
     return ret;
@@ -298,18 +242,13 @@
 
 int libambit_gps_orbit_header_read(ambit_object_t *object, uint8_t data[8])
 {
-    uint8_t *reply_data = NULL;
-    size_t replylen = 0;
     int ret = -1;
 
-    if (libambit_protocol_command(object, ambit_command_gps_orbit_head, NULL, 0, &reply_data, &replylen, 0) == 0 && replylen >= 9) {
-        memcpy(data, &reply_data[1], 8);
-        libambit_protocol_free(reply_data);
-
-        ret = 0;
+    if (object->driver != NULL && object->driver->gps_orbit_header_read != NULL) {
+        ret = object->driver->gps_orbit_header_read(object, data);
     }
     else {
-        LOG_WARNING("Failed to read GPS orbit header");
+        LOG_WARNING("Driver does not support gps_orbit_header_read");
     }
 
     return ret;
@@ -317,31 +256,13 @@
 
 int libambit_gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen)
 {
-    uint8_t header[8], cmpheader[8];
     int ret = -1;
 
-    LOG_INFO("Writing GPS orbit data");
-
-    libambit_protocol_command(object, ambit_command_write_start, NULL, 0, NULL, NULL, 0);
-
-    if (libambit_gps_orbit_header_read(object, header) == 0) {
-        cmpheader[0] = data[7]; // Year, swap bytes
-        cmpheader[1] = data[6];
-        cmpheader[2] = data[8];
-        cmpheader[3] = data[9];
-        cmpheader[4] = data[13]; // 4 byte swap
-        cmpheader[5] = data[12];
-        cmpheader[6] = data[11];
-        cmpheader[7] = data[10];
-
-        // Check if new data differs 
-        if (memcmp(header, cmpheader, 8) != 0) {
-            ret = libambit_pmem20_gps_orbit_write(object, data, datalen);
-        }
-        else {
-            LOG_INFO("Current GPS orbit data is already up to date, skipping");
-            ret = 0;
-        }
+    if (object->driver != NULL && object->driver->gps_orbit_write != NULL) {
+        ret = object->driver->gps_orbit_write(object, data, datalen);
+    }
+    else {
+        LOG_WARNING("Driver does not support gps_orbit_write");
     }
 
     return ret;
@@ -349,138 +270,16 @@
 
 int libambit_log_read(ambit_object_t *object, ambit_log_skip_cb skip_cb, ambit_log_push_cb push_cb, ambit_log_progress_cb progress_cb, void *userref)
 {
-    int entries_read = 0;
-
-    uint8_t *reply_data = NULL;
-    size_t replylen = 0;
-    uint16_t log_entries_total = 0;
-    uint16_t log_entries_walked = 0;
-
-    uint32_t more = 0x00000400;
-
-    bool read_pmem = false;
-
-    ambit_log_header_t log_header;
-    ambit_log_entry_t *log_entry;
-
-    LOG_INFO("Reading number of logs");
-
-    /*
-     * Read number of log entries
-     */
-    if (libambit_protocol_command(object, ambit_command_log_count, NULL, 0, &reply_data, &replylen, 0) != 0) {
-        LOG_WARNING("Failed to read number of log entries");
-        return -1;
-    }
-    log_entries_total = le16toh(*(uint16_t*)(reply_data + 2));
-    libambit_protocol_free(reply_data);
-
-    LOG_INFO("Number of logs=%d", log_entries_total);
-
-    /*
-     * First part walks through headers to check if there is any point in start
-     * reading the PMEM content. If no skip callback is defined, there is no
-     * point in checking the headers, because no one can tell us to not include
-     * the logs...
-     */
-
-    if (skip_cb != NULL) {
-        LOG_INFO("Look in headers for new logs");
-        // Rewind
-        if (libambit_protocol_command(object, ambit_command_log_head_first, NULL, 0, &reply_data, &replylen, 0) != 0) {
-            LOG_WARNING("Failed to rewind header pointer");
-            return -1;
-        }
-        more = le32toh(*(uint32_t*)reply_data);
-        libambit_protocol_free(reply_data);
-
-        // Loop through logs while more entries exists
-        while (more == 0x00000400) {
-            LOG_INFO("Reading next header");
-            // Go to next entry
-            if (libambit_protocol_command(object, ambit_command_log_head_step, NULL, 0, &reply_data, &replylen, 0) != 0) {
-                LOG_WARNING("Failed to walk to next header");
-                return -1;
-            }
-            libambit_protocol_free(reply_data);
-
-            // Assume every header is composited by 2 parts, where only the
-            // second is of interrest right now
-            if (libambit_protocol_command(object, ambit_command_log_head, NULL, 0, &reply_data, &replylen, 0) != 0) {
-                LOG_WARNING("Failed to read first part of header");
-                return -1;
-            }
-            libambit_protocol_free(reply_data);
-
-            if (libambit_protocol_command(object, ambit_command_log_head, NULL, 0, &reply_data, &replylen, 0) == 0) {
-                if (replylen > 8 && libambit_pmem20_log_parse_header(reply_data + 8, replylen - 8, &log_header) == 0) {
-                    if (skip_cb(userref, &log_header) != 0) {
-                        // Header was NOT skipped, break out!
-                        read_pmem = true;
-                        LOG_INFO("Found new entry, start reading log data");
-                        break;
-                    }
-                }
-                else {
-                    LOG_ERROR("Failed to parse log header");
-                    return -1;
-                }
-                libambit_protocol_free(reply_data);
-            }
-            else {
-                LOG_WARNING("Failed to read second part of header");
-                return -1;
-            }
+    int ret = -1;
 
-            // Is there more entries to read?
-            if (libambit_protocol_command(object, ambit_command_log_head_peek, NULL, 0, &reply_data, &replylen, 0) != 0) {
-                LOG_WARNING("Failed to check for more headers");
-                return -1;
-            }
-            more = le32toh(*(uint32_t*)reply_data);
-            libambit_protocol_free(reply_data);
-        }
+    if (object->driver != NULL && object->driver->log_read != NULL) {
+        ret = object->driver->log_read(object, skip_cb, push_cb, progress_cb, userref);
     }
     else {
-        LOG_INFO("No skip callback defined, reading log data");
-        read_pmem = true;
-    }
-
-    if (read_pmem) {
-        if (libambit_pmem20_log_init(object) != 0) {
-            return -1;
-        }
-
-        // Loop through all log entries, first check headers
-        while (log_entries_walked < log_entries_total && libambit_pmem20_log_next_header(object, &log_header) == 1) {
-            LOG_INFO("Reading header of log %d of %d", log_entries_walked + 1, log_entries_total);
-            if (progress_cb != NULL) {
-                progress_cb(userref, log_entries_total, log_entries_walked+1, 100*log_entries_walked/log_entries_total);
-            }
-            // Check if this entry needs to be read
-            if (skip_cb == NULL || skip_cb(userref, &log_header) != 0) {
-                LOG_INFO("Reading data of log %d of %d", log_entries_walked + 1, log_entries_total);
-                log_entry = libambit_pmem20_log_read_entry(object);
-                if (log_entry != NULL) {
-                    if (push_cb != NULL) {
-                        push_cb(userref, log_entry);
-                    }
-                    entries_read++;
-                }
-            }
-            else {
-                LOG_INFO("Log %d of %d already exists, skip reading data", log_entries_walked + 1, log_entries_total);
-            }
-            log_entries_walked++;
-            if (progress_cb != NULL) {
-                progress_cb(userref, log_entries_total, log_entries_walked, 100*log_entries_walked/log_entries_total);
-            }
-        }
+        LOG_WARNING("Driver does not support log_read");
     }
 
-    LOG_INFO("%d entries read", entries_read);
-
-    return entries_read;
+    return ret;
 }
 
 void libambit_log_entry_free(ambit_log_entry_t *log_entry)
@@ -540,40 +339,188 @@
     return ret;
 }
 
-static int lock_log(ambit_object_t *object, bool lock)
+const size_t LIBAMBIT_VERSION_LENGTH = 13;      /* max: 255.255.65535 */
+static inline void version_string(char string[LIBAMBIT_VERSION_LENGTH+1],
+                                  const uint8_t version[4])
 {
-    int ret = -1;
-    uint8_t send_data[] = { 0x00, 0x00, 0x00, 0x00 };
-    uint8_t *reply_data = NULL;
-    size_t replylen;
+  if (!string || !version) return;
 
-    uint32_t current_lock = 0xffffffff;
+  snprintf(string, LIBAMBIT_VERSION_LENGTH+1, "%d.%d.%d",
+           version[0], version[1], (version[2] << 0) | (version[3] << 8));
+}
 
-    if ((ret = libambit_protocol_command(object, ambit_command_lock_check, NULL, 0, &reply_data, &replylen, 0)) == 0) {
-        current_lock = le32toh(*(uint32_t*)reply_data);
-        libambit_protocol_free(reply_data);
-    }
-
-    if (lock && current_lock == 0) {
-        LOG_INFO("Setting Sync message to device display");
-        send_data[0] = 1;
-        ret = libambit_protocol_command(object, ambit_command_lock_set, send_data, sizeof(send_data), &reply_data, &replylen, 0);
-        libambit_protocol_free(reply_data);
-    }
-    else if (!lock && current_lock == 1) {
-        LOG_INFO("Clearing Sync message to device display");
-        send_data[0] = 0;
-        ret = libambit_protocol_command(object, ambit_command_lock_set, send_data, sizeof(send_data), &reply_data, &replylen, 0);
-        libambit_protocol_free(reply_data);
+/* Converts a wide-character string to a limited length UTF-8 string.
+ * This produces the longest valid UTF-8 string that doesn't exceed n
+ * bytes.  If the converted string would be too long, it is shortened
+ * one wchar_t at a time until the result is short enough.  Invalid
+ * and incomplete multibyte sequences will result in an empty string.
+ */
+static const char * wcs2nutf8(char *dest, const wchar_t *src, size_t n)
+{
+    const char *rv = NULL;
+
+    iconv_t cd = iconv_open("UTF-8", "WCHAR_T");
+
+    if ((iconv_t) -1 == cd) {
+        LOG_ERROR("iconv_open: %s", strerror(errno));
     }
+    else {
+        char  *s = (char *) malloc((n + 1) * sizeof(char));
+        size_t m = wcslen(src) + 1;
 
-    return ret;
+        if (s) {
+            size_t sz;
+
+            do {
+                char  *ibuf = (char *) src;
+                char  *obuf = s;
+                size_t ilen = --m * sizeof(wchar_t);
+                size_t olen = n;
+
+                sz = iconv(cd, &ibuf, &ilen, &obuf, &olen);
+
+                if ((size_t) -1 == sz) {
+                    s[0] = '\0';
+                }
+                else {          /* we're good, terminate string */
+                    s[n - olen] = '\0';
+                }
+            } while ((size_t) -1 == sz && E2BIG == errno && 0 < m);
+
+            if ((size_t) -1 == sz && E2BIG != errno) {
+                LOG_ERROR("iconv: %s", strerror(errno));
+            }
+
+            strncpy(dest, s, n);
+            rv = s;
+        }
+
+        iconv_close(cd);
+    }
+
+    return rv;
 }
 
-static uint32_t version_number(const uint8_t version[4])
+static ambit_device_info_t * ambit_device_info_new(const struct hid_device_info *dev)
 {
-    return (  (version[0] << 24)
-            | (version[1] << 16)
-            | (version[2] <<  0)
-            | (version[3] <<  8));
+    ambit_device_info_t *device = NULL;
+    const ambit_known_device_t *known_device = NULL;
+
+    const char *dev_path;
+    const char *name = NULL;
+    const char *uniq = NULL;
+
+    uint16_t vid;
+    uint16_t pid;
+
+    hid_device *hid;
+
+    
+
+    if (!dev || !dev->path) {
+        LOG_ERROR("internal error: expecting hidraw device");
+        return NULL;
+    }
+
+    dev_path = dev->path;
+    vid = dev->vendor_id;
+    pid = dev->product_id;
+
+    if (!libambit_device_support_known(vid, pid)) {
+        LOG_INFO("ignoring unknown device (VID/PID: %04x/%04x)", vid, pid);
+        return NULL;
+    }
+
+    dev_path = strdup(dev_path);
+    if (!dev_path) return NULL;
+
+    device = calloc(1, sizeof(*device));
+    if (!device) {
+        free ((char *) dev_path);
+        return NULL;
+    }
+
+    device->path = dev_path;
+    device->vendor_id  = vid;
+    device->product_id = pid;
+
+    if (dev->product_string) {
+        name = wcs2nutf8(device->name, dev->product_string,
+                         LIBAMBIT_PRODUCT_NAME_LENGTH);
+    }
+
+    if (dev->serial_number) {
+        uniq = wcs2nutf8(device->serial, dev->serial_number,
+                         LIBAMBIT_SERIAL_LENGTH);
+    }
+
+    LOG_INFO("HID  : %s: '%s' (serial: %s, VID/PID: %04x/%04x)",
+             device->path, device->name, device->serial,
+             device->vendor_id, device->product_id);
+
+    hid = hid_open_path(device->path);
+    if (hid) {
+        /* HACK ALERT: minimally initialize an ambit object so we can
+         * call device_info_get() */
+        ambit_object_t obj;
+        obj.handle = hid;
+        obj.sequence_no = 0;
+        if (0 == device_info_get(&obj, device)) {
+            if (name && 0 != strcmp(name, device->name)) {
+                LOG_INFO("preferring F/W name over '%s'", name);
+            }
+            if (uniq && 0 != strcmp(uniq, device->serial)) {
+                LOG_INFO("preferring F/W serial number over '%s'", uniq);
+            }
+
+            known_device = libambit_device_support_find(device->vendor_id, device->product_id, device->model, device->fw_version);
+            if (known_device != NULL) {
+                device->is_supported = known_device->supported;
+                if (0 != strcmp(device->name, known_device->name)) {
+                    LOG_INFO("preferring know device name over '%s'", device->name);
+                    strcpy(device->name, known_device->name);
+                }
+            }
+
+#ifdef DEBUG_PRINT_INFO
+            char fw_version[LIBAMBIT_VERSION_LENGTH+1];
+            char hw_version[LIBAMBIT_VERSION_LENGTH+1];
+            version_string(fw_version, device->fw_version);
+            version_string(hw_version, device->hw_version);
+#endif
+            LOG_INFO("Ambit: %s: '%s' (serial: %s, VID/PID: %04x/%04x, "
+                     "nick: %s, F/W: %s, H/W: %s, supported: %s)",
+                     device->path, device->name, device->serial,
+                     device->vendor_id, device->product_id,
+                     device->model, fw_version, hw_version,
+                     (device->is_supported ? "YES" : "NO"));
+        }
+        else {
+            LOG_ERROR("cannot get device info from %s", device->path);
+        }
+        hid_close(hid);
+    }
+    else {
+        /* Store an educated guess as to why we cannot open the HID
+         * device.  Without read/write access we cannot communicate
+         * to begin with but there may be other reasons.
+         */
+        int fd = open(device->path, O_RDWR);
+
+        if (-1 == fd) {
+            device->access_status = errno;
+            LOG_ERROR("cannot open HID device (%s): %s", device->path,
+                      strerror (device->access_status));
+        }
+        else {
+            LOG_WARNING("have read/write access to %s but cannot open HID "
+                        "device", device->path);
+            close(fd);
+        }
+    }
+
+    if (name) free((char *) name);
+    if (uniq) free((char *) uniq);
+
+    return device;
 }
diff -Nur -x debian -x .git -x .pc ./src/libambit/libambit.h ../openambit.git/src/libambit/libambit.h
--- ./src/libambit/libambit.h	2014-09-17 21:28:00.560501284 +0200
+++ ../openambit.git/src/libambit/libambit.h	2014-11-05 21:53:14.561132025 +0100
@@ -42,7 +42,14 @@
     char serial[LIBAMBIT_SERIAL_LENGTH+1];
     uint8_t fw_version[4];
     uint8_t hw_version[4];
-    bool is_supported;
+
+    const char *path;
+    uint16_t    vendor_id;
+    uint16_t    product_id;
+    bool        is_supported;
+    int         access_status;
+
+    struct ambit_device_info_s *next;
 } ambit_device_info_t;
 
 typedef struct ambit_device_status_s {
@@ -124,8 +131,12 @@
     ambit_log_sample_type_gps_small = 0x0310,
     ambit_log_sample_type_gps_tiny = 0x0311,
     ambit_log_sample_type_time = 0x0312,
+    ambit_log_sample_type_swimming_turn = 0x0314,
+    ambit_log_sample_type_swimming_stroke = 0x0315,
     ambit_log_sample_type_activity = 0x0318,
+    ambit_log_sample_type_cadence_source = 0x031a,
     ambit_log_sample_type_position = 0x031b,
+    ambit_log_sample_type_fwinfo = 0x031c,
     ambit_log_sample_type_unknown = 0xf000
 } ambit_log_sample_type_t;
 
@@ -224,7 +235,12 @@
             uint16_t ibi[32];
         } ibi;
         uint16_t ttff;
-        uint8_t  distance_source;               /* 2 = GPS, 3 = Wrist */
+        uint8_t  distance_source;               /* 0x00 = Bikepod,
+                                                   0x01 = Footpod,
+                                                   0x02 = GPS,
+                                                   0x03 = Wrist,
+                                                   0x04 = Indoorswimming,
+                                                   0x05 = Outdoorswimming */
         struct {
             uint8_t event_type;                 /* 0x01 = manual lap,
                                                    0x14 = high interval end,
@@ -274,14 +290,31 @@
             uint8_t  second;
         } time;
         struct {
+            uint32_t distance;                  /* Total distance, meters scale: 0.01 */
+            uint16_t lengths;                   /* Total pool lengths */
+            uint16_t classification[4];
+            uint8_t  style;                     /* (style of previous length)
+                                                   0x00 = Other,
+                                                   0x01 = Butterfly,
+                                                   0x02 = Backstroke,
+                                                   0x03 = Breaststroke,
+                                                   0x04 = Freestyle,
+                                                   0x05 = Drill */
+        } swimming_turn;
+        struct {
             uint16_t activitytype;
             uint32_t custommode;
         } activity;
+        uint8_t cadence_source;                 /* 0x40 = Wrist */
         struct {
             int32_t  latitude;                  /* degree, scale: 0.0000001, -90 <= latitude <= 90 */
             int32_t  longitude;                 /* degree, scale: 0.0000001, -180 <= latitude <= 180 */
         } position;
         struct {
+            uint8_t version[4];
+            ambit_date_time_t build_date;
+        } fwinfo;
+        struct {
             size_t datalen;
             uint8_t *data;
         } unknown;
@@ -327,9 +360,10 @@
     uint8_t  unknown2;
     uint8_t  cadence_max;           /* rpm */
     uint8_t  cadence_avg;           /* rpm */
-    uint8_t  unknown3[4];
+    uint8_t  unknown3[2];
+    uint16_t swimming_pool_lengths;
     uint32_t cadence_max_time;      /* ms */
-    uint8_t  unknown4[4];
+    uint32_t swimming_pool_length;  /* m */
     uint8_t  unknown5[4];
     uint8_t  unknown6[24];
 } ambit_log_header_t;
@@ -340,33 +374,37 @@
     ambit_log_sample_t *samples;
 } ambit_log_entry_t;
 
-/**
- * Try to detect clock
- * If clock detected, object handle is returned
- * \return object handle if clock found, else NULL
+/** \brief Create a list of all known Ambit clocks on the system
+ *
+ *  The list may include clocks that are not supported or cannot be
+ *  accessed.
  */
-ambit_object_t *libambit_detect(void);
+ambit_device_info_t * libambit_enumerate(void);
 
-/**
- * Close open Ambit object
- * \param object Object to close
+/** \brief Release resources acquired by libambit_enumerate()
  */
-void libambit_close(ambit_object_t *object);
+void libambit_free_enumeration(ambit_device_info_t *devices);
 
-/**
- * Check if detected device is currently supported
- * \param object Object to check
- * \return true if device supported, else false
+/** \brief Create an Ambit object for a clock
+ *
+ *  The pointer returned corresponds to a known, accessible and
+ *  supported clock.  In case no such clock is found \c NULL is
+ *  returned.
+ */
+ambit_object_t * libambit_new(const ambit_device_info_t *device);
+
+/** \brief Create an Ambit object from a \a pathname
+ *
+ *  Convenience function for when the path name for a clock is known.
+ *  These path names are platform dependent.
  */
-bool libambit_device_supported(ambit_object_t *object);
+ambit_object_t * libambit_new_from_pathname(const char *pathname);
 
 /**
- * Get device info on connected dev
- * \param object Object to get info from
- * \param status Status object to be filled
- * \return 0 on success, else -1
+ * Close open Ambit object
+ * \param object Object to close
  */
-int libambit_device_info_get(ambit_object_t *object, ambit_device_info_t *status);
+void libambit_close(ambit_object_t *object);
 
 /**
  * Set sync message to device display
diff -Nur -x debian -x .git -x .pc ./src/libambit/libambit_int.h ../openambit.git/src/libambit/libambit_int.h
--- ./src/libambit/libambit_int.h	2014-09-17 21:24:42.978329427 +0200
+++ ../openambit.git/src/libambit/libambit_int.h	2014-11-05 21:53:14.577132360 +0100
@@ -28,127 +28,13 @@
 
 struct ambit_object_s {
     hid_device *handle;
-    uint16_t vendor_id;
-    uint16_t product_id;
     uint16_t sequence_no;
     ambit_device_info_t device_info;
 
-    struct {
-        uint16_t chunk_size;
-        struct {
-            bool initialized;
-            uint32_t first_entry;
-            uint32_t last_entry;
-            uint32_t entries;
-            uint32_t next_free_address;
-            struct {
-                uint32_t current;
-                uint32_t next;
-                uint32_t prev;
-            } current;
-            uint8_t *buffer;
-            uint8_t *chunks_read;
-        } log;
-    } pmem20;
+    struct ambit_device_driver_s *driver;
+    struct ambit_device_driver_data_s *driver_data; // Driver specific struct,
+                                                    // should be defined
+                                                    // locally for each driver
 };
 
-enum ambit_commands_e {
-    ambit_command_device_info        = 0x0000,
-    ambit_command_time               = 0x0300,
-    ambit_command_date               = 0x0302,
-    ambit_command_status             = 0x0306,
-    ambit_command_personal_settings  = 0x0b00,
-    ambit_command_unknown1           = 0x0b04,
-    ambit_command_log_count          = 0x0b06,
-    ambit_command_log_head_first     = 0x0b07,
-    ambit_command_log_head_peek      = 0x0b08,
-    ambit_command_log_head_step      = 0x0b0a,
-    ambit_command_log_head           = 0x0b0b,
-    ambit_command_gps_orbit_head     = 0x0b15,
-    ambit_command_data_write         = 0x0b16,
-    ambit_command_log_read           = 0x0b17,
-    ambit_command_data_tail_len      = 0x0b18,
-    ambit_command_lock_check         = 0x0b19,
-    ambit_command_lock_set           = 0x0b1a,
-    ambit_command_write_start        = 0x0b1b // Really!? Just a guess...
-};
-
-// crc16.c
-uint16_t crc16_ccitt_false(unsigned char *buf, size_t buflen);
-uint16_t crc16_ccitt_false_init(unsigned char *buf, size_t buflen, uint16_t crc);
-
-// personal.c
-int libambit_personal_settings_parse(uint8_t *data, size_t datalen, ambit_personal_settings_t *settings);
-
-// pmem20.c
-int libambit_pmem20_init(ambit_object_t *object, uint16_t chunk_size);
-int libambit_pmem20_deinit(ambit_object_t *object);
-int libambit_pmem20_log_init(ambit_object_t *object);
-int libambit_pmem20_log_deinit(ambit_object_t *object);
-int libambit_pmem20_log_next_header(ambit_object_t *object, ambit_log_header_t *log_header);
-ambit_log_entry_t *libambit_pmem20_log_read_entry(ambit_object_t *object);
-int libambit_pmem20_log_parse_header(uint8_t *data, size_t datalen, ambit_log_header_t *log_header);
-int libambit_pmem20_gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen);
-
-// protocol.c
-int libambit_protocol_command(ambit_object_t *object, uint16_t command, uint8_t *data, size_t datalen, uint8_t **reply_data, size_t *replylen, uint8_t legacy_format);
-void libambit_protocol_free(uint8_t *data);
-
-// debug.c
-typedef enum debug_level_e {
-    debug_level_err,
-    debug_level_warn,
-    debug_level_info
-} debug_level_t;
-void debug_printf(debug_level_t level, const char *file, int line, const char *func, const char *fmt, ...);
-#ifdef DEBUG_PRINT_ERROR
-#define LOG_ERROR(fmt, ...) debug_printf(debug_level_err, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
-#else
-#define LOG_ERROR(fmt, ...)
-#endif
-#ifdef DEBUG_PRINT_WARNING
-#define LOG_WARNING(fmt, ...) debug_printf(debug_level_warn, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
-#else
-#define LOG_WARNING(fmt, ...)
-#endif
-#ifdef DEBUG_PRINT_INFO
-#define LOG_INFO(fmt, ...) debug_printf(debug_level_info, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
-#else
-#define LOG_INFO(fmt, ...)
-#endif
-
-// static helpers
-static inline uint8_t read8(uint8_t *buf, size_t offset)
-{
-    return buf[offset];
-}
-
-static inline uint16_t read16(uint8_t *buf, size_t offset)
-{
-    return (buf[offset] | (buf[offset+1] << 8));
-}
-
-static inline uint32_t read32(uint8_t *buf, size_t offset)
-{
-    return (buf[offset] | (buf[offset+1] << 8) | (buf[offset+2] << 16) | (buf[offset+3] << 24));
-}
-
-static inline uint8_t read8inc(uint8_t *buf, size_t *offset)
-{
-    *offset += 1;
-    return buf[(*offset)-1];
-}
-
-static inline uint16_t read16inc(uint8_t *buf, size_t *offset)
-{
-    *offset += 2;
-    return (buf[(*offset)-2] | (buf[(*offset)-1] << 8));
-}
-
-static inline uint32_t read32inc(uint8_t *buf, size_t *offset)
-{
-    *offset += 4;
-    return (buf[(*offset)-4] | (buf[(*offset)-3] << 8) | (buf[(*offset)-2] << 16) | (buf[(*offset)-1] << 24));
-}
-
 #endif /* __LIBAMBIT_INT_H__ */
diff -Nur -x debian -x .git -x .pc ./src/libambit/personal.c ../openambit.git/src/libambit/personal.c
--- ./src/libambit/personal.c	2014-09-17 21:24:42.978329427 +0200
+++ ../openambit.git/src/libambit/personal.c	2014-11-05 21:53:14.577132360 +0100
@@ -19,8 +19,8 @@
  * Contributors:
  *
  */
-#include "libambit.h"
-#include "libambit_int.h"
+#include "personal.h"
+#include "utils.h"
 
 #include <stdlib.h>
 #include <string.h>
diff -Nur -x debian -x .git -x .pc ./src/libambit/personal.h ../openambit.git/src/libambit/personal.h
--- ./src/libambit/personal.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/personal.h	2014-11-05 21:53:14.577132360 +0100
@@ -0,0 +1,31 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __PERSONAL_H__
+#define __PERSONAL_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include "libambit.h"
+
+int libambit_personal_settings_parse(uint8_t *data, size_t datalen, ambit_personal_settings_t *settings);
+
+#endif /* __PERSONAL_H__ */
diff -Nur -x debian -x .git -x .pc ./src/libambit/pmem20.c ../openambit.git/src/libambit/pmem20.c
--- ./src/libambit/pmem20.c	2014-09-17 21:24:42.978329427 +0200
+++ ../openambit.git/src/libambit/pmem20.c	2014-11-05 21:53:14.577132360 +0100
@@ -19,8 +19,11 @@
  * Contributors:
  *
  */
-#include "libambit.h"
-#include "libambit_int.h"
+#include "pmem20.h"
+#include "protocol.h"
+#include "sha256.h"
+#include "utils.h"
+#include "debug.h"
 
 #include <stdlib.h>
 #include <string.h>
@@ -29,8 +32,6 @@
 /*
  * Local definitions
  */
-#define PMEM20_LOG_START                  0x000f4240
-#define PMEM20_LOG_SIZE                   0x0029f630 /* 2 750 000 */
 #define PMEM20_LOG_WRAP_START_OFFSET      0x00000012
 #define PMEM20_LOG_WRAP_BUFFER_MARGIN     0x00010000 /* Max theoretical size of sample */
 #define PMEM20_LOG_HEADER_MIN_LEN                512 /* Header actually longer, but not interesting*/
@@ -46,10 +47,11 @@
 /*
  * Static functions
  */
-static int parse_sample(uint8_t *buf, size_t offset, uint8_t **spec, ambit_log_entry_t *log_entry, size_t *sample_count);
-static int read_upto(ambit_object_t *object, uint32_t address, uint32_t length);
-static int read_log_chunk(ambit_object_t *object, uint32_t address);
-static int write_data_chunk(ambit_object_t *object, uint32_t address, size_t buffer_count, uint8_t **buffers, size_t *buffer_sizes);
+static int parse_sample(uint8_t *buf, size_t offset, uint8_t **spec, ambit_log_entry_t *log_entry, size_t *sample_count, int32_t *time_compensators);
+static void correct_samples(ambit_log_entry_t *log_entry, int32_t *time_compensators);
+static int read_upto(libambit_pmem20_t *object, uint32_t address, uint32_t length);
+static int read_log_chunk(libambit_pmem20_t *object, uint32_t address, uint32_t length, uint8_t *buffer);
+static int write_data_chunk(ambit_object_t *object, uint32_t address, size_t buffer_count, const uint8_t **buffers, const size_t *buffer_sizes);
 static void add_time(ambit_date_time_t *intime, int32_t offset, ambit_date_time_t *outtime);
 static int is_leap(unsigned int y);
 static void to_timeval(ambit_date_time_t *ambit_time, struct timeval *timeval);
@@ -63,53 +65,58 @@
 /*
  * Public functions
  */
-int libambit_pmem20_init(ambit_object_t *object, uint16_t chunk_size)
+int libambit_pmem20_init(libambit_pmem20_t *object, ambit_object_t *ambit_object, uint16_t chunk_size)
 {
-    object->pmem20.chunk_size = chunk_size;
+    object->ambit_object = ambit_object;
+    object->chunk_size = chunk_size;
 
     return 0;
 }
 
-int libambit_pmem20_log_init(ambit_object_t *object)
+int libambit_pmem20_log_init(libambit_pmem20_t *object, uint32_t mem_start, uint32_t mem_size)
 {
     int ret = -1;
     size_t offset;
 
     // Allocate buffer for complete memory
-    if (object->pmem20.log.buffer != NULL) {
-        free(object->pmem20.log.buffer);
+    if (object->log.buffer != NULL) {
+        free(object->log.buffer);
     }
-    if (object->pmem20.log.chunks_read != NULL) {
-        free(object->pmem20.log.chunks_read);
+    if (object->log.chunks_read != NULL) {
+        free(object->log.chunks_read);
     }
-    memset(&object->pmem20.log, 0, sizeof(object->pmem20.log));
+    memset(&object->log, 0, sizeof(object->log));
 
-    object->pmem20.log.buffer = malloc(PMEM20_LOG_SIZE + PMEM20_LOG_WRAP_BUFFER_MARGIN);
-    object->pmem20.log.chunks_read = malloc((PMEM20_LOG_SIZE/object->pmem20.chunk_size)+1);
+    // Set memory structure
+    object->log.mem_start = mem_start;
+    object->log.mem_size = mem_size;
 
-    if (object->pmem20.log.buffer != NULL && object->pmem20.log.chunks_read != NULL) {
+    object->log.buffer = malloc(object->log.mem_size + PMEM20_LOG_WRAP_BUFFER_MARGIN);
+    object->log.chunks_read = malloc((object->log.mem_size/object->chunk_size)+1);
+
+    if (object->log.buffer != NULL && object->log.chunks_read != NULL) {
         // Set all chunks to NOT read
-        memset(object->pmem20.log.chunks_read, 0, (PMEM20_LOG_SIZE/object->pmem20.chunk_size)+1);
+        memset(object->log.chunks_read, 0, (object->log.mem_size/object->chunk_size)+1);
 
         // Read initial log header
         LOG_INFO("Reading first log data chunk");
-        ret = read_log_chunk(object, PMEM20_LOG_START);
-        
+        ret = read_log_chunk(object, object->log.mem_start, object->chunk_size, object->log.buffer);
+
         if (ret == 0) {
             // Parse PMEM header
             offset = 0;
-            object->pmem20.log.last_entry = read32inc(object->pmem20.log.buffer, &offset);
-            object->pmem20.log.first_entry = read32inc(object->pmem20.log.buffer, &offset);
-            object->pmem20.log.entries = read32inc(object->pmem20.log.buffer, &offset);
-            object->pmem20.log.next_free_address = read32inc(object->pmem20.log.buffer, &offset);
-            object->pmem20.log.current.current = PMEM20_LOG_START;
-            object->pmem20.log.current.next = object->pmem20.log.first_entry;
-            object->pmem20.log.current.prev = PMEM20_LOG_START;
+            object->log.last_entry = read32inc(object->log.buffer, &offset);
+            object->log.first_entry = read32inc(object->log.buffer, &offset);
+            object->log.entries = read32inc(object->log.buffer, &offset);
+            object->log.next_free_address = read32inc(object->log.buffer, &offset);
+            object->log.current.current = object->log.mem_start;
+            object->log.current.next = object->log.first_entry;
+            object->log.current.prev = object->log.mem_start;
 
-            LOG_INFO("log data header read, entries=%d, first_entry=%08x, last_entry=%08x, next_free_address=%08x", object->pmem20.log.entries, object->pmem20.log.first_entry, object->pmem20.log.last_entry, object->pmem20.log.next_free_address);
+            LOG_INFO("log data header read, entries=%d, first_entry=%08x, last_entry=%08x, next_free_address=%08x", object->log.entries, object->log.first_entry, object->log.last_entry, object->log.next_free_address);
 
             // Set initialized
-            object->pmem20.log.initialized = true;
+            object->log.initialized = true;
         }
         else {
             LOG_WARNING("Failed to read first data chunk");
@@ -119,20 +126,20 @@
     return ret;
 }
 
-int libambit_pmem20_deinit(ambit_object_t *object)
+int libambit_pmem20_deinit(libambit_pmem20_t *object)
 {
-    if (object->pmem20.log.buffer != NULL) {
-        free(object->pmem20.log.buffer);
+    if (object->log.buffer != NULL) {
+        free(object->log.buffer);
     }
-    if (object->pmem20.log.chunks_read != NULL) {
-        free(object->pmem20.log.chunks_read);
+    if (object->log.chunks_read != NULL) {
+        free(object->log.chunks_read);
     }
-    memset(&object->pmem20.log, 0, sizeof(object->pmem20.log));
+    memset(&object->log, 0, sizeof(object->log));
 
     return 0;
 }
 
-int libambit_pmem20_log_next_header(ambit_object_t *object, ambit_log_header_t *log_header)
+int libambit_pmem20_log_next_header(libambit_pmem20_t *object, ambit_log_header_t *log_header)
 {
     int ret = -1;
     size_t buffer_offset;
@@ -140,29 +147,29 @@
 
     LOG_INFO("Reading header of next log entry");
 
-    if (!object->pmem20.log.initialized) {
+    if (!object->log.initialized) {
         LOG_ERROR("Trying to get next log without initialization");
         return -1;
     }
 
     // Check if we reached end of entries
-    if (object->pmem20.log.current.current == object->pmem20.log.current.next) {
+    if (object->log.current.current == object->log.current.next) {
         LOG_INFO("No more entries to read");
         return 0;
     }
 
-    if (read_upto(object, object->pmem20.log.current.next, PMEM20_LOG_HEADER_MIN_LEN) == 0) {
-        buffer_offset = (object->pmem20.log.current.next - PMEM20_LOG_START);
+    if (read_upto(object, object->log.current.next, PMEM20_LOG_HEADER_MIN_LEN) == 0) {
+        buffer_offset = (object->log.current.next - object->log.mem_start);
         // First check that header seems to be correctly present
-        if (strncmp((char*)object->pmem20.log.buffer + buffer_offset, "PMEM", 4) == 0) {
-            object->pmem20.log.current.current = object->pmem20.log.current.next;
+        if (strncmp((char*)object->log.buffer + buffer_offset, "PMEM", 4) == 0) {
+            object->log.current.current = object->log.current.next;
             buffer_offset += 4;
-            object->pmem20.log.current.next = read32inc(object->pmem20.log.buffer, &buffer_offset);
-            object->pmem20.log.current.prev = read32inc(object->pmem20.log.buffer, &buffer_offset);
-            tmp_len = read16inc(object->pmem20.log.buffer, &buffer_offset);
+            object->log.current.next = read32inc(object->log.buffer, &buffer_offset);
+            object->log.current.prev = read32inc(object->log.buffer, &buffer_offset);
+            tmp_len = read16inc(object->log.buffer, &buffer_offset);
             buffer_offset += tmp_len;
-            tmp_len = read16inc(object->pmem20.log.buffer, &buffer_offset);
-            if (libambit_pmem20_log_parse_header(object->pmem20.log.buffer + buffer_offset, tmp_len, log_header) == 0) {
+            tmp_len = read16inc(object->log.buffer, &buffer_offset);
+            if (libambit_pmem20_log_parse_header(object->log.buffer + buffer_offset, tmp_len, log_header) == 0) {
                 LOG_INFO("Log entry header parsed");
                 ret = 1;
             }
@@ -180,61 +187,62 @@
 
     // Unset initialized of something went wrong
     if (ret < 0) {
-        object->pmem20.log.initialized = false;
+        object->log.initialized = false;
     }
 
     return ret;
 }
 
-ambit_log_entry_t *libambit_pmem20_log_read_entry(ambit_object_t *object)
+ambit_log_entry_t *libambit_pmem20_log_read_entry(libambit_pmem20_t *object)
 {
     // Note! We assume that the caller has called libambit_pmem20_log_next_header just before
     uint8_t *periodic_sample_spec;
     uint16_t tmp_len, sample_len;
-    size_t buffer_offset, sample_count = 0, i;
+    size_t buffer_offset, sample_count = 0;
     ambit_log_entry_t *log_entry;
-    ambit_log_sample_t *last_periodic = NULL, *utcsource = NULL, *altisource = NULL;
-    ambit_date_time_t utcbase;
-    uint32_t altisource_index = 0;
-    uint32_t last_base_lat = 0, last_base_long = 0;
-    uint32_t last_small_lat = 0, last_small_long = 0;
-    uint32_t last_ehpe = 0;
+    int32_t *time_compensators;
 
-    if (!object->pmem20.log.initialized) {
+    if (!object->log.initialized) {
         LOG_ERROR("Trying to get log entry without initialization");
         return NULL;
     }
 
     // Allocate log entry
     if ((log_entry = calloc(1, sizeof(ambit_log_entry_t))) == NULL) {
-        object->pmem20.log.initialized = false;
+        object->log.initialized = false;
         return NULL;
     }
 
-    LOG_INFO("Reading log entry from address=%08x", object->pmem20.log.current.current);
+    LOG_INFO("Reading log entry from address=%08x", object->log.current.current);
 
-    buffer_offset = (object->pmem20.log.current.current - PMEM20_LOG_START);
+    buffer_offset = (object->log.current.current - object->log.mem_start);
     buffer_offset += 12;
     // Read samples content definition
-    tmp_len = read16inc(object->pmem20.log.buffer, &buffer_offset);
-    periodic_sample_spec = object->pmem20.log.buffer + buffer_offset;
+    tmp_len = read16inc(object->log.buffer, &buffer_offset);
+    periodic_sample_spec = object->log.buffer + buffer_offset;
     buffer_offset += tmp_len;
     // Parse header
-    tmp_len = read16inc(object->pmem20.log.buffer, &buffer_offset);
-    if (libambit_pmem20_log_parse_header(object->pmem20.log.buffer + buffer_offset, tmp_len, &log_entry->header) != 0) {
+    tmp_len = read16inc(object->log.buffer, &buffer_offset);
+    if (libambit_pmem20_log_parse_header(object->log.buffer + buffer_offset, tmp_len, &log_entry->header) != 0) {
         LOG_ERROR("Failed to parse log entry header correctly");
         free(log_entry);
-        object->pmem20.log.initialized = false;
+        object->log.initialized = false;
         return NULL;
     }
     buffer_offset += tmp_len;
     // Now that we know number of samples, allocate space for them!
     if ((log_entry->samples = calloc(log_entry->header.samples_count, sizeof(ambit_log_sample_t))) == NULL) {
         free(log_entry);
-        object->pmem20.log.initialized = false;
+        object->log.initialized = false;
         return NULL;
     }
     log_entry->samples_count = log_entry->header.samples_count;
+    if ((time_compensators = calloc(log_entry->header.samples_count, sizeof(int32_t))) == NULL) {
+        free(log_entry->samples);
+        free(log_entry);
+        object->log.initialized = false;
+        return NULL;
+    }
 
     LOG_INFO("Log entry got %d samples, reading", log_entry->samples_count);
 
@@ -247,100 +255,131 @@
            to the end of the buffer. */
 
         // First check for log area wrap
-        if (buffer_offset >= PMEM20_LOG_SIZE - 1) {
-            read_upto(object, PMEM20_LOG_START + PMEM20_LOG_WRAP_START_OFFSET, 2);
-            sample_len = read16(object->pmem20.log.buffer, PMEM20_LOG_WRAP_START_OFFSET);
-        }
-        else if (buffer_offset == PMEM20_LOG_SIZE - 2) {
-            read_upto(object, PMEM20_LOG_START + PMEM20_LOG_WRAP_START_OFFSET, 1);
-            sample_len = object->pmem20.log.buffer[buffer_offset] | (object->pmem20.log.buffer[PMEM20_LOG_WRAP_START_OFFSET] << 8);
+        if (buffer_offset >= object->log.mem_size - 1) {
+            read_upto(object, object->log.mem_start + PMEM20_LOG_WRAP_START_OFFSET, 2);
+            sample_len = read16(object->log.buffer, PMEM20_LOG_WRAP_START_OFFSET);
+        }
+        else if (buffer_offset == object->log.mem_size - 2) {
+            read_upto(object, object->log.mem_start + PMEM20_LOG_WRAP_START_OFFSET, 1);
+            sample_len = object->log.buffer[buffer_offset] | (object->log.buffer[PMEM20_LOG_WRAP_START_OFFSET] << 8);
         }
         else {
-            read_upto(object, PMEM20_LOG_START + buffer_offset, 2);
-            sample_len = read16(object->pmem20.log.buffer, buffer_offset);
+            read_upto(object, object->log.mem_start + buffer_offset, 2);
+            sample_len = read16(object->log.buffer, buffer_offset);
         }
 
         // Read all data
-        if (buffer_offset + 2 < (PMEM20_LOG_SIZE-1)) {
-            read_upto(object, PMEM20_LOG_START + buffer_offset + 2, sample_len);
+        if (buffer_offset + 2 < (object->log.mem_size-1)) {
+            read_upto(object, object->log.mem_start + buffer_offset + 2, sample_len);
         }
-        if (buffer_offset + 2 + sample_len > PMEM20_LOG_SIZE) {
-            read_upto(object, PMEM20_LOG_START + PMEM20_LOG_WRAP_START_OFFSET, (buffer_offset + 2 + sample_len) - PMEM20_LOG_SIZE);
-            memcpy(object->pmem20.log.buffer + PMEM20_LOG_SIZE, object->pmem20.log.buffer + PMEM20_LOG_WRAP_START_OFFSET, (buffer_offset + 2 + sample_len) - PMEM20_LOG_SIZE);
+        if (buffer_offset + 2 + sample_len > object->log.mem_size) {
+            read_upto(object, object->log.mem_start + PMEM20_LOG_WRAP_START_OFFSET, (buffer_offset + 2 + sample_len) - object->log.mem_size);
+            memcpy(object->log.buffer + object->log.mem_size, object->log.buffer + PMEM20_LOG_WRAP_START_OFFSET, (buffer_offset + 2 + sample_len) - object->log.mem_size);
         }
 
-        if (parse_sample(object->pmem20.log.buffer, buffer_offset, &periodic_sample_spec, log_entry, &sample_count) == 1) {
-            // Calculate times
-            if (log_entry->samples[sample_count-1].type == ambit_log_sample_type_periodic) {
-                last_periodic = &log_entry->samples[sample_count-1];
-            }
-            else if (last_periodic != NULL) {
-                log_entry->samples[sample_count-1].time += last_periodic->time;
-            }
-            else {
-                log_entry->samples[sample_count-1].time = 0;
-            }
-
-            if (utcsource == NULL && log_entry->samples[sample_count-1].type == ambit_log_sample_type_gps_base) {
-                utcsource = &log_entry->samples[sample_count-1];
-                // Calculate UTC base time
-                add_time(&utcsource->u.gps_base.utc_base_time, 0-utcsource->time, &utcbase);
-            }
-
-            // Calculate positions
-            if (log_entry->samples[sample_count-1].type == ambit_log_sample_type_gps_base) {
-                last_base_lat = log_entry->samples[sample_count-1].u.gps_base.latitude;
-                last_base_long = log_entry->samples[sample_count-1].u.gps_base.longitude;
-                last_small_lat = log_entry->samples[sample_count-1].u.gps_base.latitude;
-                last_small_long = log_entry->samples[sample_count-1].u.gps_base.longitude;
-                last_ehpe = log_entry->samples[sample_count-1].u.gps_base.ehpe;
-            }
-            else if (log_entry->samples[sample_count-1].type == ambit_log_sample_type_gps_small) {
-                log_entry->samples[sample_count-1].u.gps_small.latitude = last_base_lat + log_entry->samples[sample_count-1].u.gps_small.latitude*10;
-                log_entry->samples[sample_count-1].u.gps_small.longitude = last_base_long + log_entry->samples[sample_count-1].u.gps_small.longitude*10;
-                last_small_lat = log_entry->samples[sample_count-1].u.gps_small.latitude;
-                last_small_long = log_entry->samples[sample_count-1].u.gps_small.longitude;
-                last_ehpe = log_entry->samples[sample_count-1].u.gps_small.ehpe;
-            }
-            else if (log_entry->samples[sample_count-1].type == ambit_log_sample_type_gps_tiny) {
-                log_entry->samples[sample_count-1].u.gps_tiny.latitude = last_small_lat + log_entry->samples[sample_count-1].u.gps_tiny.latitude*10;
-                log_entry->samples[sample_count-1].u.gps_tiny.longitude = last_small_long + log_entry->samples[sample_count-1].u.gps_tiny.longitude*10;
-                log_entry->samples[sample_count-1].u.gps_tiny.ehpe = (last_ehpe > 700 ? 700 : last_ehpe);
-                last_small_lat = log_entry->samples[sample_count-1].u.gps_tiny.latitude;
-                last_small_long = log_entry->samples[sample_count-1].u.gps_tiny.longitude;
-            }
-
-            if (altisource == NULL && log_entry->samples[sample_count-1].type == ambit_log_sample_type_altitude_source) {
-                altisource = &log_entry->samples[sample_count-1];
-                altisource_index = sample_count-1;
-            }
-        }
+        parse_sample(object->log.buffer, buffer_offset, &periodic_sample_spec, log_entry, &sample_count, time_compensators);
         buffer_offset += 2 + sample_len;
         // Wrap
-        if (buffer_offset >= PMEM20_LOG_SIZE) {
-            buffer_offset = PMEM20_LOG_WRAP_START_OFFSET + (buffer_offset - PMEM20_LOG_SIZE);
+        if (buffer_offset >= object->log.mem_size) {
+            buffer_offset = PMEM20_LOG_WRAP_START_OFFSET + (buffer_offset - object->log.mem_size);
         }
     }
 
-    // Loop through samples again and correct times etc
-    for (sample_count = 0; sample_count < log_entry->header.samples_count; sample_count++) {
-        // Set UTC times (if UTC source found)
-        if (utcsource != NULL) {
-            add_time(&utcbase, log_entry->samples[sample_count].time, &log_entry->samples[sample_count].utc_time);
+    correct_samples(log_entry, time_compensators);
+
+    free(time_compensators);
+
+    return log_entry;
+}
+
+ambit_log_entry_t *libambit_pmem20_log_read_entry_address(libambit_pmem20_t *object, uint32_t address, uint32_t length)
+{
+    uint8_t *buffer;
+    uint8_t *periodic_sample_spec;
+    uint32_t next_address;
+    uint32_t buffer_read = 0, read_length;
+    uint16_t tmp_len, sample_len;
+    size_t buffer_offset, sample_count = 0;
+    ambit_log_entry_t *log_entry;
+    int32_t *time_compensators;
+
+    // Allocate log entry
+    if ((log_entry = calloc(1, sizeof(ambit_log_entry_t))) == NULL) {
+        object->log.initialized = false;
+        return NULL;
+    }
+
+    // Allocate temporary log buffer
+    if ((buffer = calloc(1, length)) == NULL) {
+        object->log.initialized = false;
+        free(log_entry);
+        return NULL;
+    }
+
+    LOG_INFO("Reading log entry from address=%08x", address);
+
+    // Handle wrap in "the middle" of the log
+    next_address = address;
+    while (buffer_read < length) {
+        if (next_address >= object->log.mem_start + object->log.mem_size) {
+            next_address = object->log.mem_start + PMEM20_LOG_WRAP_START_OFFSET;
         }
-        // Correct altitude based on altitude offset in altitude source
-        if (altisource != NULL && log_entry->samples[sample_count].type == ambit_log_sample_type_periodic && sample_count < altisource_index) {
-            for (i=0; i<log_entry->samples[sample_count].u.periodic.value_count; i++) {
-                if (log_entry->samples[sample_count].u.periodic.values[i].type == ambit_log_sample_periodic_type_sealevelpressure) {
-                    log_entry->samples[sample_count].u.periodic.values[i].u.sealevelpressure += altisource->u.altitude_source.pressure_offset;
-                }
-                if (log_entry->samples[sample_count].u.periodic.values[i].type == ambit_log_sample_periodic_type_altitude) {
-                    log_entry->samples[sample_count].u.periodic.values[i].u.altitude += altisource->u.altitude_source.altitude_offset;
-                }
-            }
+        if (length - buffer_read >= object->chunk_size) {
+            read_length = object->chunk_size;
+        }
+        else {
+            read_length = length - buffer_read;
         }
+        if (next_address + read_length > object->log.mem_start + object->log.mem_size) {
+            read_length = object->log.mem_start + object->log.mem_size - next_address;
+        }
+
+        read_log_chunk(object, next_address, read_length, buffer + buffer_read);
+
+        next_address += read_length;
+        buffer_read += read_length;
     }
 
+    buffer_offset = 12;
+    // Read samples content definition
+    tmp_len = read16inc(buffer, &buffer_offset);
+    periodic_sample_spec = buffer + buffer_offset;
+    buffer_offset += tmp_len;
+    // Parse header
+    tmp_len = read16inc(buffer, &buffer_offset);
+    if (libambit_pmem20_log_parse_header(buffer + buffer_offset, tmp_len, &log_entry->header) != 0) {
+        LOG_ERROR("Failed to parse log entry header correctly");
+        free(log_entry);
+        object->log.initialized = false;
+        return NULL;
+    }
+    buffer_offset += tmp_len;
+    // Now that we know number of samples, allocate space for them!
+    if ((log_entry->samples = calloc(log_entry->header.samples_count, sizeof(ambit_log_sample_t))) == NULL) {
+        free(log_entry);
+        object->log.initialized = false;
+        return NULL;
+    }
+    log_entry->samples_count = log_entry->header.samples_count;
+    if ((time_compensators = calloc(log_entry->header.samples_count, sizeof(int32_t))) == NULL) {
+        free(log_entry->samples);
+        free(log_entry);
+        object->log.initialized = false;
+        return NULL;
+    }
+
+    LOG_INFO("Log entry got %d samples, reading", log_entry->samples_count);
+
+    // OK, so we are at start of samples, get them all!
+    while (sample_count < log_entry->samples_count) {
+        sample_len = read16(buffer, buffer_offset);
+
+        parse_sample(buffer, buffer_offset, &periodic_sample_spec, log_entry, &sample_count, time_compensators);
+        buffer_offset += 2 + sample_len;
+    }
+
+    correct_samples(log_entry, time_compensators);
+
     return log_entry;
 }
 
@@ -394,9 +433,10 @@
     log_header->cadence_max = read8inc(data, &offset);
     log_header->cadence_avg = read8inc(data, &offset);
 
-    memcpy(log_header->unknown3, data+offset, 4);
-    offset += 4;
+    memcpy(log_header->unknown3, data+offset, 2);
+    offset += 2;
 
+    log_header->swimming_pool_lengths = read16inc(data, &offset);
     log_header->speed_max_time = read32inc(data, &offset);
     log_header->altitude_max_time = read32inc(data, &offset);
     log_header->altitude_min_time = read32inc(data, &offset);
@@ -405,10 +445,7 @@
     log_header->temperature_max_time = read32inc(data, &offset);
     log_header->temperature_min_time = read32inc(data, &offset);
     log_header->cadence_max_time = read32inc(data, &offset);
-
-    memcpy(log_header->unknown4, data+offset, 4);
-    offset += 4;
-
+    log_header->swimming_pool_length = read32inc(data, &offset);
     log_header->first_fix_time = read16inc(data, &offset)*1000;
     log_header->battery_start = read8inc(data, &offset);
     log_header->battery_end = read8inc(data, &offset);
@@ -426,13 +463,16 @@
     return 0;
 }
 
-int libambit_pmem20_gps_orbit_write(ambit_object_t *object, uint8_t *data, size_t datalen)
+int libambit_pmem20_gps_orbit_write(libambit_pmem20_t *object, const uint8_t *data, size_t datalen, bool include_sha256_hash)
 {
-    int ret = -1;
-    uint8_t *bufptrs[2];
+    int i, ret = -1;
+    const uint8_t *bufptrs[2];
     size_t bufsizes[2];
+    uint8_t *tailbuf;
+    size_t tail_datalen = 8;
     uint8_t startheader[4];
-    uint8_t tailbuf[8];
+    sha256_ctx ctx;
+    uint8_t hash[32];
     uint32_t *_sizeptr = (uint32_t*)&startheader[0];
     uint32_t address = PMEM20_GPS_ORBIT_START;
     size_t offset = 0;
@@ -441,29 +481,45 @@
     bufptrs[0] = startheader;
     bufsizes[0] = 4;
     bufptrs[1] = data;
-    bufsizes[1] = object->pmem20.chunk_size - 4; // We assume that data is
-                                                 // always > chunk_size
+    bufsizes[1] = object->chunk_size - 4; // We assume that data is
+                                          // always > chunk_size
 
     // Write first chunk (including length)
-    ret = write_data_chunk(object, address, 2, bufptrs, bufsizes);
+    ret = write_data_chunk(object->ambit_object, address, 2, bufptrs, bufsizes);
     offset += bufsizes[1];
-    address += object->pmem20.chunk_size;
+    address += object->chunk_size;
 
     // Write rest of the chunks
     while (ret == 0 && offset < datalen) {
         bufptrs[0] = data + offset;
-        bufsizes[0] = (datalen - offset > object->pmem20.chunk_size ? object->pmem20.chunk_size : datalen - offset);
+        bufsizes[0] = (datalen - offset > object->chunk_size ? object->chunk_size : datalen - offset);
 
-        ret = write_data_chunk(object, address, 1, bufptrs, bufsizes);
+        ret = write_data_chunk(object->ambit_object, address, 1, bufptrs, bufsizes);
         offset += bufsizes[0];
         address += bufsizes[0];
     }
 
     // Write tail length (or what is really!?)
     if (ret == 0) {
-        *((uint32_t*)(&tailbuf[0])) = htole32(PMEM20_GPS_ORBIT_START);
-        *((uint32_t*)(&tailbuf[4])) = htole32(bufsizes[0]);
-        ret = libambit_protocol_command(object, ambit_command_data_tail_len, tailbuf, sizeof(tailbuf), NULL, NULL, 0);
+        // Handle hash (if wanted)
+        if (include_sha256_hash) {
+            sha256_init(&ctx);
+            sha256_update(&ctx, startheader, sizeof(startheader));
+            sha256_update(&ctx, data, datalen);
+            sha256_final(&ctx, hash);
+            tail_datalen += 64;
+        }
+        if ((tailbuf = malloc(tail_datalen + 1)) != NULL) {
+            *((uint32_t*)(&tailbuf[0])) = htole32(PMEM20_GPS_ORBIT_START);
+            *((uint32_t*)(&tailbuf[4])) = htole32(bufsizes[0]);
+            if (include_sha256_hash) {
+                for (i=0; i<32; i++) {
+                    sprintf((char*)tailbuf+8+i*2, "%02X", hash[i]);
+                }
+            }
+            ret = libambit_protocol_command(object->ambit_object, ambit_command_data_tail_len, tailbuf, tail_datalen, NULL, NULL, 0);
+            free(tailbuf);
+        }
     }
 
     return ret;
@@ -473,7 +529,7 @@
  * Parse the given sample
  * \return number of samples added (1 or 0)
  */
-static int parse_sample(uint8_t *buf, size_t offset, uint8_t **spec, ambit_log_entry_t *log_entry, size_t *sample_count)
+static int parse_sample(uint8_t *buf, size_t offset, uint8_t **spec, ambit_log_entry_t *log_entry, size_t *sample_count, int32_t *time_compensators)
 {
     int ret = 0;
     size_t int_offset = offset;
@@ -728,16 +784,51 @@
             log_entry->samples[*sample_count].u.time.minute = read8inc(buf, &int_offset);
             log_entry->samples[*sample_count].u.time.second = read8inc(buf, &int_offset);
             break;
+          case 0x14:
+            log_entry->samples[*sample_count].type = ambit_log_sample_type_swimming_turn;
+            int_offset += 1;
+            // Time compensation offset in 0.1 second format, convert to ms
+            time_compensators[*sample_count] = 0 - read16inc(buf, &int_offset) * 100;
+            int_offset += 1;
+            log_entry->samples[*sample_count].u.swimming_turn.distance = read32inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.swimming_turn.lengths = read16inc(buf, &int_offset);
+            int_offset += 18;
+            log_entry->samples[*sample_count].u.swimming_turn.classification[0] = read16inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.swimming_turn.classification[1] = read16inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.swimming_turn.classification[2] = read16inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.swimming_turn.classification[3] = read16inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.swimming_turn.style = read8inc(buf, &int_offset);
+            break;
+          case 0x15:
+            log_entry->samples[*sample_count].type = ambit_log_sample_type_swimming_stroke;
+            // Time compensation offset in 0.1 second format, convert to ms
+            time_compensators[*sample_count] = 0 - read16inc(buf, &int_offset) * 100;
+            break;
           case 0x18:
             log_entry->samples[*sample_count].type = ambit_log_sample_type_activity;
             log_entry->samples[*sample_count].u.activity.activitytype = read16inc(buf, &int_offset);
             log_entry->samples[*sample_count].u.activity.custommode = read32inc(buf, &int_offset);
             break;
+          case 0x1a:
+            log_entry->samples[*sample_count].type = ambit_log_sample_type_cadence_source;
+            log_entry->samples[*sample_count].u.cadence_source = read8inc(buf, &int_offset);
+            break;
           case 0x1b:
             log_entry->samples[*sample_count].type = ambit_log_sample_type_position;
             log_entry->samples[*sample_count].u.position.latitude = read32inc(buf, &int_offset);
             log_entry->samples[*sample_count].u.position.longitude = read32inc(buf, &int_offset);
             break;
+          case 0x1c:
+            log_entry->samples[*sample_count].type = ambit_log_sample_type_fwinfo;
+            memcpy(log_entry->samples[*sample_count].u.fwinfo.version, buf + int_offset, 4);
+            int_offset += 4;
+            log_entry->samples[*sample_count].u.fwinfo.build_date.year = read16inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.fwinfo.build_date.month = read8inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.fwinfo.build_date.day = read8inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.fwinfo.build_date.hour = read8inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.fwinfo.build_date.minute = read8inc(buf, &int_offset);
+            log_entry->samples[*sample_count].u.fwinfo.build_date.msec = read16inc(buf, &int_offset);
+            break;
           default:
             LOG_WARNING("Found unknown episodic sample type (0x%02x)", episodic_type);
             log_entry->samples[*sample_count].type = ambit_log_sample_type_unknown;
@@ -763,30 +854,129 @@
     return ret;
 }
 
-static int read_upto(ambit_object_t *object, uint32_t address, uint32_t length)
+static void correct_samples(ambit_log_entry_t *log_entry, int32_t *time_compensators)
+{
+    size_t sample_count, i;
+    ambit_log_sample_t *last_periodic = NULL, *utcsource = NULL, *altisource = NULL;
+    ambit_date_time_t utcbase;
+    uint32_t altisource_index = 0;
+    uint32_t last_base_lat = 0, last_base_long = 0;
+    uint32_t last_small_lat = 0, last_small_long = 0;
+    uint32_t last_ehpe = 0;
+    ambit_log_sample_t tmpsample;
+
+    for (sample_count = 0; sample_count < log_entry->header.samples_count; sample_count++) {
+        // Calculate times
+        if (log_entry->samples[sample_count].type == ambit_log_sample_type_periodic) {
+            last_periodic = &log_entry->samples[sample_count];
+        }
+        else if (last_periodic != NULL) {
+            log_entry->samples[sample_count].time += last_periodic->time;
+        }
+        else {
+            log_entry->samples[sample_count].time = 0;
+        }
+        // Correct with time_compensators
+        if (time_compensators[sample_count] < 0 && log_entry->samples[sample_count].time < (0 - time_compensators[sample_count])) {
+            // Avoid negative times, never set to less than 0
+            log_entry->samples[sample_count].time = 0;
+        }
+        else {
+            log_entry->samples[sample_count].time += time_compensators[sample_count];
+        }
+
+        if (utcsource == NULL && log_entry->samples[sample_count].type == ambit_log_sample_type_gps_base) {
+            utcsource = &log_entry->samples[sample_count];
+            // Calculate UTC base time
+            add_time(&utcsource->u.gps_base.utc_base_time, 0-utcsource->time, &utcbase);
+        }
+
+        // Calculate positions
+        if (log_entry->samples[sample_count].type == ambit_log_sample_type_gps_base) {
+            last_base_lat = log_entry->samples[sample_count].u.gps_base.latitude;
+            last_base_long = log_entry->samples[sample_count].u.gps_base.longitude;
+            last_small_lat = log_entry->samples[sample_count].u.gps_base.latitude;
+            last_small_long = log_entry->samples[sample_count].u.gps_base.longitude;
+            last_ehpe = log_entry->samples[sample_count].u.gps_base.ehpe;
+        }
+        else if (log_entry->samples[sample_count].type == ambit_log_sample_type_gps_small) {
+            log_entry->samples[sample_count].u.gps_small.latitude = last_base_lat + log_entry->samples[sample_count].u.gps_small.latitude*10;
+            log_entry->samples[sample_count].u.gps_small.longitude = last_base_long + log_entry->samples[sample_count].u.gps_small.longitude*10;
+            last_small_lat = log_entry->samples[sample_count].u.gps_small.latitude;
+            last_small_long = log_entry->samples[sample_count].u.gps_small.longitude;
+            last_ehpe = log_entry->samples[sample_count].u.gps_small.ehpe;
+        }
+        else if (log_entry->samples[sample_count].type == ambit_log_sample_type_gps_tiny) {
+            log_entry->samples[sample_count].u.gps_tiny.latitude = last_small_lat + log_entry->samples[sample_count].u.gps_tiny.latitude*10;
+            log_entry->samples[sample_count].u.gps_tiny.longitude = last_small_long + log_entry->samples[sample_count].u.gps_tiny.longitude*10;
+            log_entry->samples[sample_count].u.gps_tiny.ehpe = (last_ehpe > 700 ? 700 : last_ehpe);
+            last_small_lat = log_entry->samples[sample_count].u.gps_tiny.latitude;
+            last_small_long = log_entry->samples[sample_count].u.gps_tiny.longitude;
+        }
+
+        if (altisource == NULL && log_entry->samples[sample_count].type == ambit_log_sample_type_altitude_source) {
+            altisource = &log_entry->samples[sample_count];
+            altisource_index = sample_count;
+        }
+    }
+
+    // Loop through samples again and correct times etc
+    for (sample_count = 0; sample_count < log_entry->header.samples_count; sample_count++) {
+        // Set UTC times (if UTC source found)
+        if (utcsource != NULL) {
+            add_time(&utcbase, log_entry->samples[sample_count].time, &log_entry->samples[sample_count].utc_time);
+        }
+        // Correct altitude based on altitude offset in altitude source
+        if (altisource != NULL && log_entry->samples[sample_count].type == ambit_log_sample_type_periodic && sample_count < altisource_index) {
+            for (i=0; i<log_entry->samples[sample_count].u.periodic.value_count; i++) {
+                if (log_entry->samples[sample_count].u.periodic.values[i].type == ambit_log_sample_periodic_type_sealevelpressure) {
+                    log_entry->samples[sample_count].u.periodic.values[i].u.sealevelpressure += altisource->u.altitude_source.pressure_offset;
+                }
+                if (log_entry->samples[sample_count].u.periodic.values[i].type == ambit_log_sample_periodic_type_altitude) {
+                    log_entry->samples[sample_count].u.periodic.values[i].u.altitude += altisource->u.altitude_source.altitude_offset;
+                }
+            }
+        }
+    }
+
+    // Rearrange samples in respect to time values
+    for (sample_count = 1; sample_count < log_entry->header.samples_count; sample_count++) {
+        // Look for bad sorted samples
+        if (log_entry->samples[sample_count].time < log_entry->samples[sample_count-1].time) {
+            // Find out new position of sample
+            for (i = sample_count - 1; i > 0; i--) {
+                if (log_entry->samples[sample_count].time >= log_entry->samples[i-1].time) {
+                    break;
+                }
+            }
+            memcpy(&tmpsample, &log_entry->samples[sample_count], sizeof(ambit_log_sample_t));
+            memmove(&log_entry->samples[i+1], &log_entry->samples[i], sizeof(ambit_log_sample_t)*(sample_count-i));
+            memcpy(&log_entry->samples[i], &tmpsample, sizeof(ambit_log_sample_t));
+        }
+    }
+}
+
+static int read_upto(libambit_pmem20_t *object, uint32_t address, uint32_t length)
 {
-    uint32_t start_address = address - ((address - PMEM20_LOG_START) % object->pmem20.chunk_size);
+    uint32_t start_address = address - ((address - object->log.mem_start) % object->chunk_size);
 
     while (start_address < address + length) {
-        if (object->pmem20.log.chunks_read[(start_address - PMEM20_LOG_START)/object->pmem20.chunk_size] == 0) {
-            if (read_log_chunk(object, start_address) != 0) {
+        if (object->log.chunks_read[(start_address - object->log.mem_start)/object->chunk_size] == 0) {
+            if (read_log_chunk(object, start_address, object->chunk_size, object->log.buffer + (start_address - object->log.mem_start)) != 0) {
                 return -1;
             }
-            object->pmem20.log.chunks_read[(start_address - PMEM20_LOG_START)/object->pmem20.chunk_size] = 1;
+            object->log.chunks_read[(start_address - object->log.mem_start)/object->chunk_size] = 1;
         }
-        start_address += object->pmem20.chunk_size;
+        start_address += object->chunk_size;
     }
 
     return 0;
 }
 
-static int read_log_chunk(ambit_object_t *object, uint32_t address)
+static int read_log_chunk(libambit_pmem20_t *object, uint32_t address, uint32_t length, uint8_t *buffer)
 {
     int ret = -1;
 
-    uint8_t *buffer = object->pmem20.log.buffer + (address - PMEM20_LOG_START);
-    uint32_t length = object->pmem20.chunk_size;
-
     uint8_t *reply = NULL;
     size_t replylen = 0;
 
@@ -794,14 +984,14 @@
     uint32_t *_address = (uint32_t*)&send_data[0];
     uint32_t *_length = (uint32_t*)&send_data[4];
 
-    if ((address + object->pmem20.chunk_size) > (PMEM20_LOG_START + PMEM20_LOG_SIZE)) {
-        length = PMEM20_LOG_START + PMEM20_LOG_SIZE - address;
+    if ((address + object->chunk_size) > (object->log.mem_start + object->log.mem_size)) {
+        length = object->log.mem_start + object->log.mem_size - address;
     }
 
     *_address = htole32(address);
     *_length = htole32(length);
 
-    if (libambit_protocol_command(object, ambit_command_log_read, send_data, sizeof(send_data), &reply, &replylen, 0) == 0 &&
+    if (libambit_protocol_command(object->ambit_object, ambit_command_log_read, send_data, sizeof(send_data), &reply, &replylen, 0) == 0 &&
         replylen == length + 8) {
         memcpy(buffer, reply + 8, length);
         ret = 0;
@@ -812,7 +1002,7 @@
     return ret;
 }
 
-static int write_data_chunk(ambit_object_t *object, uint32_t address, size_t buffer_count, uint8_t **buffers, size_t *buffer_sizes)
+static int write_data_chunk(ambit_object_t *object, uint32_t address, size_t buffer_count, const uint8_t **buffers, const size_t *buffer_sizes)
 {
     int ret = -1;
 
diff -Nur -x debian -x .git -x .pc ./src/libambit/pmem20.h ../openambit.git/src/libambit/pmem20.h
--- ./src/libambit/pmem20.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/pmem20.h	2014-11-05 21:53:14.577132360 +0100
@@ -0,0 +1,60 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __PMEM20_H__
+#define __PMEM20_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include "libambit.h"
+
+typedef struct libambit_pmem20_s {
+    uint16_t chunk_size;
+    struct {
+        bool initialized;
+        uint32_t mem_start;
+        uint32_t mem_size;
+        uint32_t first_entry;
+        uint32_t last_entry;
+        uint32_t entries;
+        uint32_t next_free_address;
+        struct {
+            uint32_t current;
+            uint32_t next;
+            uint32_t prev;
+        } current;
+        uint8_t *buffer;
+        uint8_t *chunks_read;
+    } log;
+    ambit_object_t *ambit_object;
+} libambit_pmem20_t;
+
+int libambit_pmem20_init(libambit_pmem20_t *object, ambit_object_t *ambit_object, uint16_t chunk_size);
+int libambit_pmem20_deinit(libambit_pmem20_t *object);
+int libambit_pmem20_log_init(libambit_pmem20_t *object, uint32_t mem_start, uint32_t mem_size);
+int libambit_pmem20_log_deinit(libambit_pmem20_t *object);
+int libambit_pmem20_log_next_header(libambit_pmem20_t *object, ambit_log_header_t *log_header);
+ambit_log_entry_t *libambit_pmem20_log_read_entry(libambit_pmem20_t *object);
+ambit_log_entry_t *libambit_pmem20_log_read_entry_address(libambit_pmem20_t *object, uint32_t address, uint32_t length);
+int libambit_pmem20_log_parse_header(uint8_t *data, size_t datalen, ambit_log_header_t *log_header);
+int libambit_pmem20_gps_orbit_write(libambit_pmem20_t *object, const uint8_t *data, size_t datalen, bool include_sha256_hash);
+
+#endif /* __PMEM20_H__ */
diff -Nur -x debian -x .git -x .pc ./src/libambit/protocol.c ../openambit.git/src/libambit/protocol.c
--- ./src/libambit/protocol.c	2014-09-17 21:24:42.978329427 +0200
+++ ../openambit.git/src/libambit/protocol.c	2014-11-05 21:53:14.577132360 +0100
@@ -19,8 +19,10 @@
  * Contributors:
  *
  */
-#include "libambit.h"
+#include "protocol.h"
 #include "libambit_int.h"
+#include "crc16.h"
+
 #include "hidapi/hidapi.h"
 
 #include <stdlib.h>
@@ -104,8 +106,8 @@
     msg->MP = 0x5d;
     msg->parts_seq = htole16(packet_count);
     msg->command = htobe16(command);
-    msg->send_recv = htole16(legacy_format ? 1 : 5);
-    msg->format = htole16(legacy_format ? 0 : 9); // TODO!!!
+    msg->send_recv = htole16(legacy_format == 1 ? 1 : legacy_format == 2 ? 0x15 : 5);
+    msg->format = htole16(legacy_format == 1 ? 0 : 9);
     msg->sequence = htole16(object->sequence_no);
     msg->payload_len = htole32(datalen);
     packet_payload_len = fmin(42, datalen);
diff -Nur -x debian -x .git -x .pc ./src/libambit/protocol.h ../openambit.git/src/libambit/protocol.h
--- ./src/libambit/protocol.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/protocol.h	2014-11-05 21:53:14.577132360 +0100
@@ -0,0 +1,57 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __PROTOCOL_H__
+#define __PROTOCOL_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include "libambit.h"
+
+enum ambit_commands_e {
+    ambit_command_device_info        = 0x0000,
+    ambit_command_time               = 0x0300,
+    ambit_command_date               = 0x0302,
+    ambit_command_status             = 0x0306,
+    ambit_command_personal_settings  = 0x0b00,
+    ambit_command_unknown1           = 0x0b04,
+    ambit_command_log_count          = 0x0b06,
+    ambit_command_log_head_first     = 0x0b07,
+    ambit_command_log_head_peek      = 0x0b08,
+    ambit_command_log_head_step      = 0x0b0a,
+    ambit_command_log_head           = 0x0b0b,
+    ambit_command_gps_orbit_head     = 0x0b15,
+    ambit_command_data_write         = 0x0b16,
+    ambit_command_log_read           = 0x0b17,
+    ambit_command_data_tail_len      = 0x0b18,
+    ambit_command_lock_check         = 0x0b19,
+    ambit_command_lock_set           = 0x0b1a,
+    ambit_command_write_start        = 0x0b1b // Really!? Just a guess...
+};
+
+/**
+ * Write command to device
+ * \param legacy_format 0=normal, 1=legacy, 2=version 2
+ */
+int libambit_protocol_command(ambit_object_t *object, uint16_t command, uint8_t *data, size_t datalen, uint8_t **reply_data, size_t *replylen, uint8_t legacy_format);
+void libambit_protocol_free(uint8_t *data);
+
+#endif /* __PROTOCOL_H__ */
diff -Nur -x debian -x .git -x .pc ./src/libambit/sha256.c ../openambit.git/src/libambit/sha256.c
--- ./src/libambit/sha256.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/sha256.c	2014-11-05 21:53:14.577132360 +0100
@@ -0,0 +1,176 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include <string.h>
+
+#include "sha256.h"
+
+/*
+ * Local definitions
+ */
+#define ROTLEFT(a,b)  (((a) << (b)) | ((a) >> (32-(b))))
+#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))
+#define CH(x,y,z)     (((x) & (y)) ^ (~(x) & (z)))
+#define MAJ(x,y,z)    (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
+#define EP0(x)        (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
+#define EP1(x)        (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
+#define SIG0(x)       (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
+#define SIG1(x)       (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))
+
+
+/*
+ * Static functions
+ */
+static void sha256_transform(sha256_ctx *ctx, const uint8_t *data);
+
+/*
+ * Static variables
+ */
+static const uint32_t h[8] = {
+    0x6a09e667,
+    0xbb67ae85,
+    0x3c6ef372,
+    0xa54ff53a,
+    0x510e527f,
+    0x9b05688c,
+    0x1f83d9ab,
+    0x5be0cd19
+};
+
+static const uint32_t k[SHA256_BLOCK_SIZE] = {
+    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
+    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
+    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
+    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
+    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
+    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
+    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
+    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
+};
+
+/*
+ * Public functions
+ */
+void sha256(const uint8_t *data, size_t len, uint8_t *hash)
+{
+    sha256_ctx ctx;
+
+    sha256_init(&ctx);
+    sha256_update(&ctx, data, len);
+    sha256_final(&ctx, hash);
+}
+
+void sha256_init(sha256_ctx *ctx)
+{
+    size_t i;
+    ctx->datalen = 0;
+    ctx->bitlen = 0;
+    for (i=0; i<8; i++) {
+        ctx->h[i] = h[i];
+    }
+}
+
+void sha256_update(sha256_ctx *ctx, const uint8_t *data, size_t len)
+{
+    size_t i;
+
+    for (i=0; i<len; i++) {
+        ctx->data[ctx->datalen++] = data[i];
+        if (ctx->datalen == SHA256_BLOCK_SIZE) {
+            sha256_transform(ctx, ctx->data);
+            ctx->bitlen += 512;
+            ctx->datalen = 0;
+        }
+    }
+}
+
+void sha256_final(sha256_ctx *ctx, uint8_t *hash)
+{
+    uint32_t i;
+
+    i = ctx->datalen;
+
+    // Pad data left in buffer
+    if (i < 56) {
+        // There is room for the appending length in this chunk, pad up until 56 byte
+        ctx->data[i++] = 0x80;
+        while (i < 56) {
+            ctx->data[i++] = 0x00;
+        }
+    }
+    else {
+        // No room for length, transform this chunk and use an empty one for length
+        ctx->data[i++] = 0x80;
+        while (i < 64) {
+            ctx->data[i++] = 0x00;
+        }
+        sha256_transform(ctx, ctx->data);
+        memset(ctx->data, 0, 56);
+    }
+
+    // Append total length to last buffer
+    ctx->bitlen += ctx->datalen << 3;
+    for (i=0; i<8; i++) {
+        ctx->data[63-i] = ctx->bitlen >> (8*i);
+    }
+    sha256_transform(ctx, ctx->data);
+
+    // Get hash (stored as 8 (4-byte) words)
+    for (i=0; i<8; i++) {
+        hash[(i<<2)]   = ctx->h[i] >> 24;
+        hash[(i<<2)+1] = ctx->h[i] >> 16;
+        hash[(i<<2)+2] = ctx->h[i] >> 8;
+        hash[(i<<2)+3] = ctx->h[i];
+    }
+}
+
+static void sha256_transform(sha256_ctx *ctx, const uint8_t *data)
+{
+    size_t i;
+    uint32_t m[64];
+    uint32_t th[8];
+    uint32_t t1, t2;
+
+    for (i=0; i<16; i++) {
+        m[i] = (data[(i<<2)] << 24) | (data[(i<<2)+1] << 16) | (data[(i<<2)+2] << 8) | (data[(i<<2)+3]);
+    }
+    for (i=16; i<64; i++) {
+        m[i] = SIG1(m[i-2]) + m[i-7] + SIG0(m[i-15]) + m[i-16];
+    }
+    for (i=0; i<8; i++) {
+        th[i] = ctx->h[i];
+    }
+    for (i=0; i<64; i++) {
+        t1 = th[7] + EP1(th[4]) + CH(th[4], th[5], th[6]) + k[i] + m[i];
+        t2 = EP0(th[0]) + MAJ(th[0], th[1], th[2]);
+        th[7] = th[6];
+        th[6] = th[5];
+        th[5] = th[4];
+        th[4] = th[3] + t1;
+        th[3] = th[2];
+        th[2] = th[1];
+        th[1] = th[0];
+        th[0] = t1 + t2;
+    }
+    for (i=0; i<8; i++) {
+        ctx->h[i] += th[i];
+    }
+}
diff -Nur -x debian -x .git -x .pc ./src/libambit/sha256.h ../openambit.git/src/libambit/sha256.h
--- ./src/libambit/sha256.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/sha256.h	2014-11-05 21:53:14.577132360 +0100
@@ -0,0 +1,42 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __SHA256_H__
+#define __SHA256_H__
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define SHA256_BLOCK_SIZE (512 / 8)
+
+typedef struct {
+    uint8_t  data[SHA256_BLOCK_SIZE];
+    uint32_t datalen;
+    uint64_t bitlen;
+    uint32_t h[8];
+} sha256_ctx;
+
+void sha256(const uint8_t *data, size_t len, uint8_t *hash);
+void sha256_init(sha256_ctx *ctx);
+void sha256_update(sha256_ctx *ctx, const uint8_t *data, size_t len);
+void sha256_final(sha256_ctx *ctx, uint8_t *hash);
+
+#endif /* __SHA256_H__ */
diff -Nur -x debian -x .git -x .pc ./src/libambit/utils.c ../openambit.git/src/libambit/utils.c
--- ./src/libambit/utils.c	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/utils.c	2014-11-05 21:53:14.577132360 +0100
@@ -0,0 +1,152 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include "utils.h"
+
+#include <stdint.h>
+#include <ctype.h>
+#include <limits.h>
+#include <time.h>
+#include <string.h>
+
+static int date_get_num(const char **pp, int n_min, int n_max, int len_max)
+{
+    int i, val, c;
+    const char *p;
+    p = *pp;
+    val = 0;
+    for(i = 0; i < len_max; i++) {
+        c = *p;
+        if (!isdigit(c))
+            break;
+        val = (val * 10) + c - '0';
+        p++;
+    }
+    /* no number read ? */
+    if (p == *pp)
+        return -1;
+    if (val < n_min || val > n_max)
+        return -1;
+    *pp = p;
+    return val;
+}
+char *libambit_strptime(const char *p, const char *fmt, struct tm *dt)
+{
+    int c, val;
+    for(;;) {
+        /* consume time string until a non whitespace char is found */
+        while (isspace(*fmt)) {
+            while (isspace(*p)) {
+                p++;
+            }
+            fmt++;
+        }
+        c = *fmt++;
+        if (c == '\0') {
+            return (char *)p;
+        } else if (c == '%') {
+            c = *fmt++;
+            switch(c) {
+              case 'H':
+              case 'J':
+                val = date_get_num(&p, 0, c == 'H' ? 23 : INT_MAX, 2);
+                if (val == -1)
+                    return NULL;
+                dt->tm_hour = val;
+                break;
+              case 'M':
+                val = date_get_num(&p, 0, 59, 2);
+                if (val == -1)
+                    return NULL;
+                dt->tm_min = val;
+                break;
+              case 'S':
+                val = date_get_num(&p, 0, 59, 2);
+                if (val == -1)
+                    return NULL;
+                dt->tm_sec = val;
+                break;
+              case 'Y':
+                val = date_get_num(&p, 0, 9999, 4);
+                if (val == -1)
+                    return NULL;
+                dt->tm_year = val - 1900;
+                break;
+              case 'm':
+                val = date_get_num(&p, 1, 12, 2);
+                if (val == -1)
+                    return NULL;
+                dt->tm_mon = val - 1;
+                break;
+              case 'd':
+                val = date_get_num(&p, 1, 31, 2);
+                if (val == -1)
+                    return NULL;
+                dt->tm_mday = val;
+                break;
+              case '%':
+                goto match;
+              default:
+                return NULL;
+            }
+        } else {
+          match:
+            if (c != *p)
+                return NULL;
+            p++;
+        }
+    }
+}
+
+/* return number representation of hex, or on error 0xff */
+static uint8_t hextob(char ch)
+{
+    if (ch >= '0' && ch <= '9')
+        return (ch - '0');
+    else if (ch >= 'A' && ch <= 'F')
+        return (ch - 'A' + 10);
+    else if (ch >= 'a' && ch <= 'f')
+        return (ch - 'a' + 10);
+    else
+        return 0xff;
+}
+int libambit_htob(const char *hex_string, uint8_t *binary, size_t binary_size)
+{
+    int i = 0;
+    uint8_t ch;
+    size_t bytes_written = 0;
+
+    if (hex_string[0] == '\0' || strlen(hex_string) % 2 != 0) {
+        return -1;
+    }
+
+    while (bytes_written < binary_size && *hex_string != '\0') {
+        if ((ch = hextob(*(hex_string++))) == 0xff)
+            return -1;
+        binary[i] = ch << 4;
+        if ((ch = hextob(*(hex_string++))) == 0xff)
+            return -1;
+        binary[i++] |= ch;
+    }
+
+    return i;
+}
+
diff -Nur -x debian -x .git -x .pc ./src/libambit/utils.h ../openambit.git/src/libambit/utils.h
--- ./src/libambit/utils.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/libambit/utils.h	2014-11-05 21:53:14.577132360 +0100
@@ -0,0 +1,77 @@
+/*
+ * (C) Copyright 2014 Emil Ljungdahl
+ *
+ * This file is part of libambit.
+ *
+ * libambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#ifndef __UTILS_H__
+#define __UTILS_H__
+
+#include <stddef.h>
+#include <stdint.h>
+#include <time.h>
+
+/**
+ * Reduced implementation of the Unix specific strptime
+ */
+char *libambit_strptime(const char *p, const char *fmt, struct tm *dt);
+
+/**
+ * Hex string to binary conversion
+ * \param Hex string to parse
+ * \param binary Buffer to store parsed hex data
+ * \param binary_size Length of buffer
+ * \return Number of converted bytes, or -1 if error occured
+ */
+int libambit_htob(const char *hex_string, uint8_t *binary, size_t binary_size);
+
+// static helpers
+static inline uint8_t read8(uint8_t *buf, size_t offset)
+{
+    return buf[offset];
+}
+
+static inline uint16_t read16(uint8_t *buf, size_t offset)
+{
+    return (buf[offset] | (buf[offset+1] << 8));
+}
+
+static inline uint32_t read32(uint8_t *buf, size_t offset)
+{
+    return (buf[offset] | (buf[offset+1] << 8) | (buf[offset+2] << 16) | (buf[offset+3] << 24));
+}
+
+static inline uint8_t read8inc(uint8_t *buf, size_t *offset)
+{
+    *offset += 1;
+    return buf[(*offset)-1];
+}
+
+static inline uint16_t read16inc(uint8_t *buf, size_t *offset)
+{
+    *offset += 2;
+    return (buf[(*offset)-2] | (buf[(*offset)-1] << 8));
+}
+
+static inline uint32_t read32inc(uint8_t *buf, size_t *offset)
+{
+    *offset += 4;
+    return (buf[(*offset)-4] | (buf[(*offset)-3] << 8) | (buf[(*offset)-2] << 16) | (buf[(*offset)-1] << 24));
+}
+
+#endif /* __UTILS_H__ */
diff -Nur -x debian -x .git -x .pc ./src/openambit/CMakeLists.txt ../openambit.git/src/openambit/CMakeLists.txt
--- ./src/openambit/CMakeLists.txt	2014-09-17 21:28:00.560501284 +0200
+++ ../openambit.git/src/openambit/CMakeLists.txt	2014-11-05 21:53:14.577132360 +0100
@@ -1,7 +1,7 @@
 cmake_minimum_required(VERSION 2.8.5)
 project (OPENAMBIT)
 
-set (OPENAMBIT_VERSION 0.3)
+set (OPENAMBIT_VERSION HEAD)
 
 # Where to lookup modules
 set(CMAKE_MODULE_PATH "${OPENAMBIT_SOURCE_DIR}/cmake")
@@ -34,22 +34,23 @@
 )
 
 set ( openambit_SRCS
+  confirmbetadialog.cpp
+  devicemanager.cpp
+  logentry.cpp
+  logstore.cpp
+  logview.cpp
   main.cpp
   mainwindow.cpp
-  devicemanager.cpp
-  settingsdialog.cpp
   settings.cpp
-  logstore.cpp
-  logentry.cpp
-  udevlistener.cpp
-  confirmbetadialog.cpp
+  settingsdialog.cpp
   single_application.cpp
+  udevlistener.cpp
 )
 
 set ( openambit_UIS
+  confirmbetadialog.ui
   mainwindow.ui
   settingsdialog.ui
-  confirmbetadialog.ui
 )
 
 set ( openambit_RSCS
@@ -57,16 +58,19 @@
 )
 
 set ( openambit_MOCS
-  mainwindow.h
+  confirmbetadialog.h
   devicemanager.h
-  settingsdialog.h
-  settings.h
   logstore.h
-  udevlistener.h
-  confirmbetadialog.h
+  logview.h
+  mainwindow.h
+  settings.h
+  settingsdialog.h
   single_application.h
+  udevlistener.h
 )
 
+set (FILES_TO_TRANSLATE ${openambit_SRCS} ${openambit_UIS} ${openambit_HDRS} ${openambit_MOCS})
+
 set ( APP_ICON ${PROJECT_SOURCE_DIR}/icons/icon_disconnected.png )
 
 set ( CMAKE_INSTALL_UDEVRULESDIR /lib/udev/rules.d
@@ -76,13 +80,38 @@
 
 add_subdirectory("${PROJECT_SOURCE_DIR}/movescount")
 
+######### Translations
+file (GLOB TRANSLATIONS_FILES translations/*.ts)
+
+option (UPDATE_TRANSLATIONS "Update source translation translations/*.ts")
+if (UPDATE_TRANSLATIONS)
+  qt4_create_translation(QM_FILES ${FILES_TO_TRANSLATE} ${TRANSLATIONS_FILES})
+else (UPDATE_TRANSLATIONS)
+  qt4_add_translation(QM_FILES ${TRANSLATIONS_FILES})
+endif (UPDATE_TRANSLATIONS)
+
+# Create translations QRC file - ts.qrc
+set(TRANSLATIONS_QRC "${CMAKE_CURRENT_BINARY_DIR}/ts.qrc")
+file(WRITE ${TRANSLATIONS_QRC} "<RCC>\n\t<qresource prefix=\"/translations\">")
+foreach(QM_FILE ${QM_FILES})
+    get_filename_component(QM_FILE_NAME ${QM_FILE} NAME)
+    file(APPEND ${TRANSLATIONS_QRC} "\n\t\t<file alias=\"${QM_FILE_NAME}\">${QM_FILE_NAME}</file>")
+endforeach()
+file(APPEND ${TRANSLATIONS_QRC} "\n\t</qresource>\n</RCC>")
+list(APPEND openambit_RSCS ${TRANSLATIONS_QRC})
+
+# prevent the generated files from being deleted during make clean
+set_directory_properties(PROPERTIES CLEAN_NO_CUSTOM true)
+
+######### Translations
+
 QT4_WRAP_UI(UIS ${openambit_UIS})
 QT4_ADD_RESOURCES(RSCS ${openambit_RSCS})
 QT4_WRAP_CPP(MOCS ${openambit_MOCS})
 
 add_definitions( -DAPP_VERSION="${OPENAMBIT_VERSION}" )
 
-add_executable ( openambit ${openambit_SRCS} ${UIS} ${RSCS} ${TRS} ${MOCS} )
+add_executable ( openambit ${openambit_SRCS} ${UIS} ${RSCS} ${MOCS} )
 
 target_link_libraries ( openambit  ${QT_QTCORE_LIBRARY} ${QT_QTGUI_LIBRARY} ${QT_QTNETWORK_LIBRARY} ${LIBAMBIT_LIBS} ${UDEV_LIBS} ${ZLIB_LIBRARY} ${QJSON_LIBRARIES} )
 
@@ -96,3 +125,4 @@
 install ( FILES ${APP_ICON}
           DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/icons/hicolor/64x64/apps
           RENAME openambit.png )
+
diff -Nur -x debian -x .git -x .pc ./src/openambit/deployment/openambit.desktop ../openambit.git/src/openambit/deployment/openambit.desktop
--- ./src/openambit/deployment/openambit.desktop	2014-09-17 21:28:00.560501284 +0200
+++ ../openambit.git/src/openambit/deployment/openambit.desktop	2014-08-23 12:29:25.039629266 +0200
@@ -1,5 +1,5 @@
 [Desktop Entry]
-Version=0.3
+Version=HEAD
 Type=Application
 Name=Openambit
 Comment=Open source synchronization for Suunto Ambit series
diff -Nur -x debian -x .git -x .pc ./src/openambit/devicemanager.cpp ../openambit.git/src/openambit/devicemanager.cpp
--- ./src/openambit/devicemanager.cpp	2014-09-17 21:24:43.010328871 +0200
+++ ../openambit.git/src/openambit/devicemanager.cpp	2014-11-05 21:53:14.601132858 +0100
@@ -59,15 +59,17 @@
     mutex.lock();
     if (this->deviceObject != NULL) {
         libambit_close(this->deviceObject);
+        this->deviceObject = NULL;
+        emit deviceRemoved();
     }
-    this->deviceObject = libambit_detect();
 
-    if (this->deviceObject != NULL && (res = libambit_device_info_get(this->deviceObject, &this->currentDeviceInfo)) == 0) {
-        emit deviceDetected(this->currentDeviceInfo, libambit_device_supported(this->deviceObject));
-    }
-    else {
-        emit deviceRemoved();
+    ambit_device_info_t *devinfo = libambit_enumerate();
+    if (devinfo) {
+        this->currentDeviceInfo = *devinfo;
+        emit deviceDetected(this->currentDeviceInfo, devinfo->is_supported);
+        this->deviceObject = libambit_new(devinfo);
     }
+    libambit_free_enumeration(devinfo);
     mutex.unlock();
 
     if (res == 0) {
diff -Nur -x debian -x .git -x .pc ./src/openambit/logentry.cpp ../openambit.git/src/openambit/logentry.cpp
--- ./src/openambit/logentry.cpp	2014-09-17 21:28:00.560501284 +0200
+++ ../openambit.git/src/openambit/logentry.cpp	2014-11-05 21:53:14.601132858 +0100
@@ -143,37 +143,3 @@
     }
     return true;
 }
-
-QString LogEntry::toHtml(){
-    QString log_html;
-
-    log_html += "<h1>" + QString::fromLatin1(this->logEntry->header.activity_name) + "</h1>";
-    if (this->isUploaded()){
-        log_html += "<a href='http://www.movescount.com/moves/move" + this->movescountId + "'>see on movescount.com</a>";
-    }
-    else {
-        log_html += "Not uploaded yet";
-    }
-    log_html += "<h2>Details</h2>";
-    log_html += "<h4>" + this->time.toString() + "</h4>";
-    log_html += "<h4>Duration: " + QTime(0, 0, 0,0 ).addMSecs(this->logEntry->header.duration).toString("HH:mm:ss") + "</h4>";
-    log_html += "<h4>Distance: " + QString::number(this->logEntry->header.distance) + " m</h4>";
-    log_html += "<h2>Training values</h2>";
-    log_html += "<h4>Avg HR: " + QString::number(this->logEntry->header.heartrate_avg) + " bpm</h4>";
-    log_html += "<h4>Max HR: " + QString::number(this->logEntry->header.heartrate_max) + " bpm</h4>";
-    log_html += "<h4>Min HR: " + QString::number(this->logEntry->header.heartrate_min) + " bpm</h4>";
-    log_html += "<h4>PTE: " + QString::number(this->logEntry->header.peak_training_effect/10.0) + "</h4>";
-    log_html += "<h2>Device</h2>";
-    log_html += "<h4>Name: " + QString(this->deviceInfo->name) + "</h4>";
-    log_html += "<h4>Variant: " + QString(this->deviceInfo->model) + "</h4>";
-    log_html += "<h4>Serial: " + QString(this->deviceInfo->serial) + "</h4>";
-    //log_string += "Device info: " + QString::number(this->deviceInfo->fw_version) + "\n";
-    //log_string += "Device info: " + QString::number(this->deviceInfo->hw_version) + "\n";
-
-    //log_string += "Personal Settings: " + this->personalSettings + "\n";
-
-
-    return log_html;
-}
-
-
diff -Nur -x debian -x .git -x .pc ./src/openambit/logentry.h ../openambit.git/src/openambit/logentry.h
--- ./src/openambit/logentry.h	2014-09-17 21:24:43.010328871 +0200
+++ ../openambit.git/src/openambit/logentry.h	2014-11-05 21:53:14.605132946 +0100
@@ -34,7 +34,6 @@
 
     LogEntry& operator=(const LogEntry &rhs);
 
-    QString toHtml();
     bool isUploaded();
 
     QString device;
diff -Nur -x debian -x .git -x .pc ./src/openambit/logstore.cpp ../openambit.git/src/openambit/logstore.cpp
--- ./src/openambit/logstore.cpp	2014-09-17 21:28:00.560501284 +0200
+++ ../openambit.git/src/openambit/logstore.cpp	2014-11-05 21:53:14.645133785 +0100
@@ -46,8 +46,12 @@
     { ambit_log_sample_type_gps_small, "gps-small" },
     { ambit_log_sample_type_gps_tiny, "gps-tiny" },
     { ambit_log_sample_type_time, "time" },
+    { ambit_log_sample_type_swimming_turn, "swimming-turn" },
+    { ambit_log_sample_type_swimming_stroke, "swimming-stroke" },
     { ambit_log_sample_type_activity, "activity" },
+    { ambit_log_sample_type_cadence_source, "cadence-source" },
     { ambit_log_sample_type_position, "position" },
+    { ambit_log_sample_type_fwinfo, "fwinfo" },
     { ambit_log_sample_type_unknown, "unknown" },
     { (ambit_log_sample_type_t)0, "" }
 };
@@ -58,8 +62,12 @@
 } sample_distance_source_name_t;
 
 static sample_distance_source_name_t sampleDistanceSourceNames[] = {
+    { 0x00, "Bikepod" },
+    { 0x01, "Footpod" },
     { 0x02, "GPS" },
     { 0x03, "Wrist" },
+    { 0x04, "Indoorswimming" },
+    { 0x05, "Outdoorswimming" },
     { 0, "" }
 };
 
@@ -89,6 +97,31 @@
     { 0, "" }
 };
 
+typedef struct sample_cadence_source_name_s {
+    u_int8_t source_id;
+    QString XMLName;
+} sample_cadence_source_name_t;
+
+static sample_cadence_source_name_t sampleCadenceSourceNames[] = {
+    { 0x40, "Wrist" },
+    { 0, "" }
+};
+
+typedef struct sample_swimming_style_name_s {
+    u_int8_t source_id;
+    QString XMLName;
+} sample_swimming_style_name_t;
+
+static sample_swimming_style_name_t sampleSwimmingStyleNames[] = {
+    { 0x00, "Other" },
+    { 0x01, "Butterfly" },
+    { 0x02, "Backstroke" },
+    { 0x03, "Breaststroke" },
+    { 0x04, "Freestyle" },
+    { 0x05, "Drill" },
+    { 0, "" }
+};
+
 LogStore::LogStore(QObject *parent) :
     QObject(parent)
 {
@@ -672,6 +705,19 @@
         else if (xml.name() == "DistanceBeforeCalibrationChange") {
             logEntry->logEntry->header.distance_before_calib = xml.readElementText().toUInt();
         }
+        else if (xml.name() == "Swimming") {
+            while (xml.readNextStartElement()) {
+                if (xml.name() == "PoolLengths") {
+                    logEntry->logEntry->header.swimming_pool_lengths = xml.readElementText().toUInt();
+                }
+                else if (xml.name() == "PoolLength") {
+                    logEntry->logEntry->header.swimming_pool_length = xml.readElementText().toUInt();
+                }
+                else {
+                    xml.skipCurrentElement();
+                }
+            }
+        }
         else if (xml.name() == "Unknown1") {
             QByteArray val = xml.readElementText().toLocal8Bit();
             const char *c_str = val.data();
@@ -695,7 +741,7 @@
                 sscanf(c_str, "%2hhx", &logEntry->logEntry->header.cadence_avg);
                 c_str += 2 * sizeof(char);
             }
-            for (int i=0; i<4 && i<val.length()/2; i++) {
+            for (int i=0; i<2 && i<val.length()/2; i++) {
                 sscanf(c_str, "%2hhx", &logEntry->logEntry->header.unknown3[i]);
                 c_str += 2 * sizeof(char);
             }
@@ -714,10 +760,6 @@
                 }
                 logEntry->logEntry->header.cadence_max_time = cadence_max_time;
             }
-            for (int i=0; i<4 && i<val.length()/2; i++) {
-                sscanf(c_str, "%2hhx", &logEntry->logEntry->header.unknown4[i]);
-                c_str += 2 * sizeof(char);
-            }
         }
         else if (xml.name() == "Unknown5") {
             QByteArray val = xml.readElementText().toLocal8Bit();
@@ -993,6 +1035,39 @@
                             xml.skipCurrentElement();
                         }
                         break;
+                    case ambit_log_sample_type_swimming_turn:
+                        if (xml.name() == "Distance") {
+                            logEntry->logEntry->samples[sampleCount].u.swimming_turn.distance = xml.readElementText().toInt();
+                        }
+                        else if (xml.name() == "Lengths") {
+                            logEntry->logEntry->samples[sampleCount].u.swimming_turn.lengths = xml.readElementText().toInt();
+                        }
+                        else if (xml.name() == "Classification") {
+                            int itemCount = 0;
+                            while(xml.readNextStartElement()) {
+                                if (xml.name() == "Item" && itemCount < (int)(sizeof(logEntry->logEntry->samples[sampleCount].u.swimming_turn.classification)/sizeof(logEntry->logEntry->samples[sampleCount].u.swimming_turn.classification[0]))) {
+                                    logEntry->logEntry->samples[sampleCount].u.swimming_turn.classification[itemCount++] = xml.readElementText().toInt();
+                                }
+                                else {
+                                    /* Should not get here! */
+                                    xml.skipCurrentElement();
+                                }
+                            }
+                        }
+                        else if (xml.name() == "Style") {
+                            int styleId = xml.attributes().value("id").toString().toUInt();
+                            logEntry->logEntry->samples[sampleCount].u.swimming_turn.style = styleId;
+                            xml.skipCurrentElement();
+                        }
+                        else {
+                            /* Should not get here! */
+                            xml.skipCurrentElement();
+                        }
+                        break;
+                    case ambit_log_sample_type_swimming_stroke:
+                        /* Should not get here! */
+                        xml.skipCurrentElement();
+                        break;
                     case ambit_log_sample_type_activity:
                         if (xml.name() == "ActivityType") {
                             logEntry->logEntry->samples[sampleCount].u.activity.activitytype = xml.readElementText().toUInt();
@@ -1005,6 +1080,17 @@
                             xml.skipCurrentElement();
                         }
                         break;
+                    case ambit_log_sample_type_cadence_source:
+                        if (xml.name() == "CadenceSource") {
+                            int cadenceId = xml.attributes().value("id").toString().toUInt();
+                            logEntry->logEntry->samples[sampleCount].u.cadence_source = cadenceId;
+                            xml.skipCurrentElement();
+                        }
+                        else {
+                            /* Should not get here! */
+                            xml.skipCurrentElement();
+                        }
+                        break;
                     case ambit_log_sample_type_position:
                         if (xml.name() == "Latitude") {
                             logEntry->logEntry->samples[sampleCount].u.position.latitude = xml.readElementText().toInt();
@@ -1017,6 +1103,33 @@
                             xml.skipCurrentElement();
                         }
                         break;
+                    case ambit_log_sample_type_fwinfo:
+                    {
+                        QRegExp versionRX("([0-9]+)\\.([0-9]+)\\.([0-9]+)");
+
+                        if (xml.name() == "Version") {
+                            if (versionRX.indexIn(xml.readElementText()) >= 0) {
+                                logEntry->logEntry->samples[sampleCount].u.fwinfo.version[0] = versionRX.cap(1).toInt();
+                                logEntry->logEntry->samples[sampleCount].u.fwinfo.version[1] = versionRX.cap(2).toInt();
+                                logEntry->logEntry->samples[sampleCount].u.fwinfo.version[2] = versionRX.cap(3).toInt() & 0xff;
+                                logEntry->logEntry->samples[sampleCount].u.fwinfo.version[3] = (versionRX.cap(3).toInt() >> 8) & 0xff;
+                            }
+                        }
+                        else if (xml.name() == "BuildDate") {
+                            QDateTime datetime = QDateTime::fromString(xml.readElementText(), Qt::ISODate);
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.year = datetime.date().year();
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.month = datetime.date().month();
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.day = datetime.date().day();
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.hour = datetime.time().hour();
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.minute = datetime.time().minute();
+                            logEntry->logEntry->samples[sampleCount].u.fwinfo.build_date.msec = datetime.time().second()*1000 + datetime.time().msec();
+                        }
+                        else {
+                            /* Should not get here! */
+                            xml.skipCurrentElement();
+                        }
+                        break;
+                    }
                     case ambit_log_sample_type_unknown:
                         if (xml.name() == "Data") {
                             QByteArray val = xml.readElementText().toLocal8Bit();
@@ -1386,6 +1499,10 @@
     xml.writeTextElement("BatteryChargeAtStart", QString("%1").arg(logEntry->header.battery_start));
     xml.writeTextElement("BatteryCharge", QString("%1").arg(logEntry->header.battery_end));
     xml.writeTextElement("DistanceBeforeCalibrationChange", QString("%1").arg(logEntry->header.distance_before_calib));
+    xml.writeStartElement("Swimming");
+    xml.writeTextElement("PoolLengths", QString("%1").arg(logEntry->header.swimming_pool_lengths));
+    xml.writeTextElement("PoolLength", QString("%1").arg(logEntry->header.swimming_pool_length));
+    xml.writeEndElement();
 
     QString hexstring;
     hexstring = hexstring.sprintf("%02x%02x%02x%02x%02x", logEntry->header.unknown1[0],
@@ -1396,16 +1513,9 @@
     xml.writeTextElement("Unknown1", hexstring);
     hexstring = hexstring.sprintf("%02x", logEntry->header.unknown2);
     xml.writeTextElement("Unknown2", hexstring);
-    hexstring = hexstring.sprintf("%02x%02x%02x%02x", logEntry->header.unknown3[0],
-                                                      logEntry->header.unknown3[1],
-                                                      logEntry->header.unknown3[2],
-                                                      logEntry->header.unknown3[3]);
+    hexstring = hexstring.sprintf("%02x%02x", logEntry->header.unknown3[0],
+                                              logEntry->header.unknown3[1]);
     xml.writeTextElement("Unknown3", hexstring);
-    hexstring = hexstring.sprintf("%02x%02x%02x%02x", logEntry->header.unknown4[0],
-                                                      logEntry->header.unknown4[1],
-                                                      logEntry->header.unknown4[2],
-                                                      logEntry->header.unknown4[3]);
-    xml.writeTextElement("Unknown4", hexstring);
     hexstring = hexstring.sprintf("%02x%02x%02x%02x", logEntry->header.unknown5[0],
                                                       logEntry->header.unknown5[1],
                                                       logEntry->header.unknown5[2],
@@ -1455,6 +1565,8 @@
     sample_distance_source_name_t *distance_source_name;
     sample_altitude_source_name_t *altitude_source_name;
     sample_lap_event_type_t *lap_type_name;
+    sample_cadence_source_name_t *cadence_source_name;
+    sample_swimming_style_name_t *swimming_style_name;
     int i;
 
     xml.writeStartElement("Sample");
@@ -1583,14 +1695,60 @@
         xml.writeTextElement("TimeRef", timeref.toString(Qt::ISODate));
         break;
     }
+    case ambit_log_sample_type_swimming_turn:
+    {
+        xml.writeTextElement("Distance", QString("%1").arg(sample->u.swimming_turn.distance));
+        xml.writeTextElement("Lengths", QString("%1").arg(sample->u.swimming_turn.lengths));
+        xml.writeStartElement("Classification");
+        for (size_t i=0; i<(sizeof(sample->u.swimming_turn.classification)/sizeof(sample->u.swimming_turn.classification[0])); i++) {
+            xml.writeTextElement("Item", QString("%1").arg(sample->u.swimming_turn.classification[i]));
+        }
+        xml.writeEndElement();
+        xml.writeStartElement("Style");
+        xml.writeAttribute("id", QString("%1").arg(sample->u.swimming_turn.style));
+        for (swimming_style_name = &sampleSwimmingStyleNames[0]; swimming_style_name->XMLName != ""; swimming_style_name++) {
+            if (swimming_style_name->source_id == sample->u.swimming_turn.style) {
+                xml.writeCharacters(QString(swimming_style_name->XMLName));
+                break;
+            }
+        }
+        xml.writeEndElement();
+        break;
+    }
+    case ambit_log_sample_type_swimming_stroke:
+        break;
     case ambit_log_sample_type_activity:
+    {
         xml.writeTextElement("ActivityType", QString("%1").arg(sample->u.activity.activitytype));
         xml.writeTextElement("CustomModeId", QString("%1").arg(sample->u.activity.custommode));
         break;
+    }
+    case ambit_log_sample_type_cadence_source:
+    {
+        xml.writeStartElement("CadenceSource");
+        xml.writeAttribute("id", QString("%1").arg(sample->u.cadence_source));
+        for (cadence_source_name = &sampleCadenceSourceNames[0]; cadence_source_name->XMLName != ""; cadence_source_name++) {
+            if (cadence_source_name->source_id == sample->u.cadence_source) {
+                xml.writeCharacters(QString(cadence_source_name->XMLName));
+                break;
+            }
+        }
+        xml.writeEndElement();
+        break;
+    }
     case ambit_log_sample_type_position:
+    {
         xml.writeTextElement("Latitude", QString("%1").arg(sample->u.position.latitude));
         xml.writeTextElement("Longitude", QString("%1").arg(sample->u.position.longitude));
         break;
+    }
+    case ambit_log_sample_type_fwinfo:
+    {
+        xml.writeTextElement("Version", QString("%1.%2.%3").arg((int)sample->u.fwinfo.version[0]).arg((int)sample->u.fwinfo.version[1]).arg((int)sample->u.fwinfo.version[2] | ((int)sample->u.fwinfo.version[3] << 8)));
+        QDateTime dateTime(QDate(sample->u.fwinfo.build_date.year, sample->u.fwinfo.build_date.month, sample->u.fwinfo.build_date.day), QTime(sample->u.fwinfo.build_date.hour, sample->u.fwinfo.build_date.minute, 0).addMSecs(sample->u.fwinfo.build_date.msec));
+        xml.writeTextElement("BuildDate", dateTime.toString(Qt::ISODate));
+        break;
+    }
     case ambit_log_sample_type_unknown:
     {
         QString data = "";
diff -Nur -x debian -x .git -x .pc ./src/openambit/logview.cpp ../openambit.git/src/openambit/logview.cpp
--- ./src/openambit/logview.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/logview.cpp	2014-11-05 21:53:14.645133785 +0100
@@ -0,0 +1,41 @@
+#include "logview.h"
+
+LogView::LogView(QWidget *parent):
+    QTextBrowser(parent)
+{
+}
+
+void LogView::showLog(LogEntry *entry)
+{
+    QString log_html;
+
+    if (entry != NULL && entry->logEntry != NULL && entry->deviceInfo != NULL) {
+        log_html += "<h1>" + QString::fromLatin1(entry->logEntry->header.activity_name) + "</h1>";
+        if (entry->isUploaded()){
+            log_html += "<a href='http://www.movescount.com/moves/move" + entry->movescountId + "'>" + tr("see on movescount.com") + "</a>";
+        }
+        else {
+            log_html += tr("Not uploaded yet");
+        }
+        log_html += "<h2>" + tr("Details") + "</h2>";
+        log_html += "<h4>" + entry->time.toString() + "</h4>";
+        log_html += "<h4>" + tr("Duration: %1").arg(QTime(0, 0, 0,0 ).addMSecs(entry->logEntry->header.duration).toString("HH:mm:ss")) + "</h4>";
+        log_html += "<h4>" + tr("Distance: %1 m").arg(QString::number(entry->logEntry->header.distance)) + "</h4>";
+        log_html += "<h2>" + tr("Training values") + "</h2>";
+        log_html += "<h4>" + tr("Avg HR: %1 bpm").arg(QString::number(entry->logEntry->header.heartrate_avg)) + "</h4>";
+        log_html += "<h4>" + tr("Max HR: %1 bpm").arg(QString::number(entry->logEntry->header.heartrate_max)) + "</h4>";
+        log_html += "<h4>" + tr("Min HR: %1 bpm").arg(QString::number(entry->logEntry->header.heartrate_min)) + "</h4>";
+        log_html += "<h4>" + tr("PTE: %1").arg(QString::number(entry->logEntry->header.peak_training_effect/10.0)) + "</h4>";
+        log_html += "<h2>" + tr("Device") + "</h2>";
+        log_html += "<h4>" + tr("Name: %1").arg(QString(entry->deviceInfo->name)) + "</h4>";
+        log_html += "<h4>" + tr("Variant: %1").arg(QString(entry->deviceInfo->model)) + "</h4>";
+        log_html += "<h4>" + tr("Serial: %1").arg(QString(entry->deviceInfo->serial)) + "</h4>";
+
+        this->setHtml(log_html);
+    }
+}
+
+void LogView::hideLog()
+{
+    this->setHtml("");
+}
diff -Nur -x debian -x .git -x .pc ./src/openambit/logview.h ../openambit.git/src/openambit/logview.h
--- ./src/openambit/logview.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/logview.h	2014-11-05 21:53:14.645133785 +0100
@@ -0,0 +1,23 @@
+#ifndef LOGVIEW_H
+#define LOGVIEW_H
+
+#include <QTextBrowser>
+
+#include "logentry.h"
+
+class LogView : public QTextBrowser
+{
+    Q_OBJECT
+public:
+    explicit LogView(QWidget *parent = 0);
+
+    void showLog(LogEntry *entry);
+    void hideLog();
+
+signals:
+
+public slots:
+
+};
+
+#endif // LOGVIEW_H
diff -Nur -x debian -x .git -x .pc ./src/openambit/main.cpp ../openambit.git/src/openambit/main.cpp
--- ./src/openambit/main.cpp	2014-09-17 21:24:43.010328871 +0200
+++ ../openambit.git/src/openambit/main.cpp	2014-11-05 21:53:14.645133785 +0100
@@ -19,13 +19,42 @@
  * Contributors:
  *
  */
+#include <unistd.h>
 #include "mainwindow.h"
 #include <QSettings>
+#include <QTranslator>
+#include <QLibraryInfo>
 
 #include "single_application.h"
 
+static void initTranslations(void);
+
 int main(int argc, char *argv[])
 {
+    // Handle foreground arguments
+    // NOTE: It would be preferable to handle all arguments at the same place,
+    // but fork needs to be done before Qt initialize it seems
+    bool background = true;
+    for (int i=0; i<argc; i++) {
+        if (strcmp(argv[i], "-f") == 0) {
+            background = false;
+            break;
+        }
+    }
+    if (background) {
+#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) && !defined(__CYGWIN__)
+        // Windows
+#else
+        // Fork for background running
+        if ( fork() > 0 ) {
+            // Exit the parent process
+            return 0;
+        }
+        // Set the child to the new process group leader
+        setsid();
+#endif
+    }
+
     SingleApplication a(argc, argv, "openambit_single_application_lock");
 
     if (a.isRunning()) {
@@ -38,6 +67,18 @@
     QCoreApplication::setOrganizationName("Openambit");
     QCoreApplication::setApplicationName("Openambit");
 
+    // Handle forced localisation / translation
+    Q_FOREACH(QString argu, a.arguments()) {
+        const static QString localeParam = "-locale:";
+        if (argu.startsWith(localeParam)) {
+           QLocale::setDefault(QLocale(argu.mid(sizeof(localeParam))));
+           break;
+        }
+    }
+
+    // Initialize translations
+    initTranslations();
+
     MainWindow w;
 
     // Connect single application message bus
@@ -47,3 +88,25 @@
     
     return a.exec();
 }
+
+static void initTranslations(void)
+{
+    QLocale locale;
+    QTranslator *qtTranslator = new QTranslator();
+    qtTranslator->load("qt_" + locale.name(), QLibraryInfo::location(QLibraryInfo::TranslationsPath));
+    if (qtTranslator->isEmpty()) {
+        delete qtTranslator;
+    }
+    else {
+        qApp->installTranslator(qtTranslator);
+    }
+
+    QTranslator *openambitTranslator = new QTranslator();
+    openambitTranslator->load(":/translations/openambit_" + locale.name());
+    if (openambitTranslator->isEmpty()) {
+        delete openambitTranslator;
+    }
+    else {
+        qApp->installTranslator(openambitTranslator);
+    }
+}
diff -Nur -x debian -x .git -x .pc ./src/openambit/mainwindow.cpp ../openambit.git/src/openambit/mainwindow.cpp
--- ./src/openambit/mainwindow.cpp	2014-09-17 21:28:00.560501284 +0200
+++ ../openambit.git/src/openambit/mainwindow.cpp	2014-11-05 21:53:14.649133868 +0100
@@ -171,7 +171,13 @@
 
 void MainWindow::closeEvent(QCloseEvent *event)
 {
-    if (!sysTraySupported() || forceClose) {
+    //check if there is a settings for running in background
+    settings.beginGroup("generalSettings");
+    bool RunInBg;
+    RunInBg = settings.value("runningBackground", true).toBool();
+    settings.endGroup();
+
+    if (!sysTraySupported() || forceClose || !RunInBg) {
         trayIcon->setVisible(false);
         event->accept();
     }
@@ -232,10 +238,17 @@
 
 void MainWindow::deviceDetected(ambit_device_info_t deviceInfo, bool supported)
 {
+    if (0 != deviceInfo.access_status) {
+        ui->labelNotSupported->setText(strerror(deviceInfo.access_status));
+    }
+    else {
+        // FIXME Should be gotten from the UI file, really
+        ui->labelNotSupported->setText(tr("Device not supported yet!"));
+    }
     ui->labelDeviceDetected->setText(deviceInfo.name);
     ui->labelSerial->setText(deviceInfo.serial);
     trayIcon->setIcon(QIcon(":/icon_connected"));
-    if (!supported) {
+    if (0 != deviceInfo.access_status || !supported) {
         ui->labelNotSupportedIcon->setHidden(false);
         ui->labelNotSupported->setHidden(false);
         ui->labelMovescountAuthIcon->setHidden(true);
@@ -386,7 +399,7 @@
     if (current != NULL) {
         logEntry = logStore.read(current->data(Qt::UserRole).toString());
         if (logEntry != NULL) {
-            ui->logDetail->setHtml(logEntry->toHtml());
+            ui->logDetail->showLog(logEntry);
         }
 
         delete logEntry;
diff -Nur -x debian -x .git -x .pc ./src/openambit/mainwindow.ui ../openambit.git/src/openambit/mainwindow.ui
--- ./src/openambit/mainwindow.ui	2014-09-17 21:24:43.010328871 +0200
+++ ../openambit.git/src/openambit/mainwindow.ui	2014-11-05 21:53:14.649133868 +0100
@@ -30,7 +30,7 @@
      </widget>
     </item>
     <item>
-     <widget class="QTextBrowser" name="logDetail">
+     <widget class="LogView" name="logDetail">
       <property name="openExternalLinks">
        <bool>true</bool>
       </property>
diff -Nur -x debian -x .git -x .pc ./src/openambit/movescount/CMakeLists.txt ../openambit.git/src/openambit/movescount/CMakeLists.txt
--- ./src/openambit/movescount/CMakeLists.txt	2014-09-17 21:28:00.560501284 +0200
+++ ../openambit.git/src/openambit/movescount/CMakeLists.txt	2014-11-05 21:53:14.649133868 +0100
@@ -2,9 +2,9 @@
   ${openambit_SRCS}
   ${CMAKE_CURRENT_SOURCE_DIR}/movescount.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountjson.cpp
+  ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogchecker.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogdirentry.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountxml.cpp
-  ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogchecker.cpp
   PARENT_SCOPE
 )
 
@@ -12,8 +12,10 @@
   ${openambit_MOCS}
   ${CMAKE_CURRENT_SOURCE_DIR}/movescount.h
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountjson.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogchecker.h
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogdirentry.h
   ${CMAKE_CURRENT_SOURCE_DIR}/movescountxml.h
-  ${CMAKE_CURRENT_SOURCE_DIR}/movescountlogchecker.h
   PARENT_SCOPE
 )
+
+set (FILES_TO_TRANSLATE ${FILES_TO_TRANSLATE} ${openambit_SRCS} ${openambit_MOCS} PARENT_SCOPE)
diff -Nur -x debian -x .git -x .pc ./src/openambit/movescount/movescountjson.cpp ../openambit.git/src/openambit/movescount/movescountjson.cpp
--- ./src/openambit/movescount/movescountjson.cpp	2014-09-17 21:28:00.560501284 +0200
+++ ../openambit.git/src/openambit/movescount/movescountjson.cpp	2014-11-05 21:53:14.649133868 +0100
@@ -103,10 +103,24 @@
     return -1;
 }
 
+/**
+ * @brief MovesCountJSON::generateLogData
+ * @param logEntry
+ * @param output
+ * @return
+ * @note Fucked up facts about movescount:
+ *  - The periodic samples timestamps are truncated to 10th of milliseconds by movescount
+ *  - That would be fine, if it wasn't for the swimming logs where the periodic entries
+ *    are matched to the time of entries in the marksContent list (which has ms precision).
+ *  - Some of the entries that should match in marksContent are virtual created entries,
+ *    generated here. This can lead to time collisions.
+ *  - To compensate for the collisions, samples might need to be shifted in time,
+ *    hence the fuzz with dateTimeCompensate
+ */
 int MovesCountJSON::generateLogData(LogEntry *logEntry, QByteArray &output)
 {
     QJson::Serializer serializer;
-    bool ok;
+    bool ok, inPause = false;
     QVariantMap content;
     QVariantList IBIContent;
     QVariantList marksContent;
@@ -114,6 +128,8 @@
     QVariantList GPSSamplesContent;
     QByteArray uncompressedData, compressedData;
     ambit_log_sample_t *sample;
+    QDateTime prevMarksDateTime;
+    QDateTime prevPeriodicSamplesDateTime;
 
     QDateTime localBaseTime(QDate(logEntry->logEntry->header.date_time.year,
                                   logEntry->logEntry->header.date_time.month,
@@ -123,14 +139,15 @@
 
     // Loop through content
     QList<int> order = rearrangeSamples(logEntry);
-    foreach(int index, order) {
-        sample = &logEntry->logEntry->samples[index];
+    for (int i=0; i<order.length(); i++) {
+        sample = &logEntry->logEntry->samples[order[i]];
 
         switch(sample->type) {
         case ambit_log_sample_type_periodic:
         {
             QVariantMap tmpMap;
-            tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
+            prevPeriodicSamplesDateTime = dateTimeRound(dateTimeCompensate(dateTimeRound(localBaseTime.addMSecs(sample->time), 10), prevPeriodicSamplesDateTime, 0), 10);
+            tmpMap.insert("LocalTime", dateTimeString(prevPeriodicSamplesDateTime));
             writePeriodicSample(sample, tmpMap);
             periodicSamplesContent.append(tmpMap);
             break;
@@ -178,7 +195,13 @@
             case 0x00: /* autolap = 5 */
             {
                 QVariantMap tmpMap;
-                tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
+                if (sample->time > 0) {
+                    prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+                }
+                else {
+                    prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+                }
+                tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
                 tmpMap.insert("Type", 5);
                 marksContent.append(tmpMap);
                 break;
@@ -186,45 +209,162 @@
             case 0x01: /* manual = 0 */
             case 0x16: /* interval = 0 */
             {
-                QVariantMap tmpMap;
-                tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
-                tmpMap.insert("Type", 0);
-                marksContent.append(tmpMap);
+                // Try to remove strange manual lap events at end after pause/stop
+                // A lap during a pause doesn't make sense anyway?
+                if (!inPause) {
+                    QVariantMap tmpMap;
+                    if (sample->time > 0) {
+                        prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+                    }
+                    else {
+                        prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+                    }
+                    tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
+                    tmpMap.insert("Type", 0);
+                    marksContent.append(tmpMap);
+                }
                 break;
             }
             case 0x1f: /* start = 1 */
             {
                 QVariantMap tmpMap;
-                tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
                 if (sample->time > 0) {
+                    prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+                    tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
                     tmpMap.insert("Type", 1);
                 }
+                else {
+                    prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+                    tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
+                }
                 marksContent.append(tmpMap);
+
+                inPause = false;
                 break;
             }
             case 0x1e: /* pause = 2 */
             {
                 QVariantMap tmpMap;
-                tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
+                if (sample->time > 0) {
+                    prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+                }
+                else {
+                    prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+                }
+                tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
                 tmpMap.insert("Type", 2);
                 marksContent.append(tmpMap);
+
+                inPause = true;
                 break;
             }
             case 0x14: /* high interval = 3 */
             case 0x15: /* low interval = 3 */
             {
                 QVariantMap tmpMap;
-                tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
+                if (sample->time > 0) {
+                    prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+                }
+                else {
+                    prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+                }
+                tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
                 tmpMap.insert("Type", 3);
                 marksContent.append(tmpMap);
                 break;
             }
             };
             break;
+        case ambit_log_sample_type_swimming_turn:
+        {
+            int nextIndex;
+            ambit_log_sample_t *next_swimming_turn = NULL;
+            uint8_t style = 0;
+            QDateTime sampleDateTime;
+            if (sample->time > 0) {
+                sampleDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+            }
+            else {
+                sampleDateTime = localBaseTime.addMSecs(sample->time);
+            }
+
+            // Find next swimming turn, to check what marks to generate
+            for (nextIndex=i+1; nextIndex<order.length(); nextIndex++) {
+                next_swimming_turn = &logEntry->logEntry->samples[order[nextIndex]];
+                if (next_swimming_turn->type == ambit_log_sample_type_swimming_turn) {
+                    break;
+                }
+            }
+            if (nextIndex == order.length()) {
+                next_swimming_turn = NULL;
+            }
+            if (next_swimming_turn == NULL || sample->u.swimming_turn.style != next_swimming_turn->u.swimming_turn.style) {
+                QVariantMap tmpMap;
+                QVariantList calibration;
+                tmpMap.insert("LocalTime", dateTimeString(sampleDateTime));
+                tmpMap.insert("Type", 7);
+                tmpMap.insert("SwimmingStyle", sample->u.swimming_turn.style);
+                for (size_t k=0; k<sizeof(sample->u.swimming_turn.classification)/sizeof(sample->u.swimming_turn.classification[0]); k++) {
+                    calibration.append(sample->u.swimming_turn.classification[k]);
+                }
+                tmpMap.insert("SwimmingStyleCalibration", calibration);
+                marksContent.append(tmpMap);
+
+                if (next_swimming_turn != NULL) {
+                    style = next_swimming_turn->u.swimming_turn.style;
+                }
+                else {
+                    style = 0;
+                }
+
+                // Add some time to timestamp
+                sampleDateTime = sampleDateTime.addMSecs(5);
+            }
+            else {
+                style = sample->u.swimming_turn.style;
+            }
+
+            sampleDateTime = dateTimeRound(dateTimeCompensate(dateTimeCompensate(dateTimeRound(sampleDateTime, 10), prevMarksDateTime, 0), prevPeriodicSamplesDateTime, 0), 10);
+
+            QVariantMap tmpMap, attribMap;
+            QVariantList attributes;
+            tmpMap.insert("LocalTime", dateTimeString(sampleDateTime));
+            tmpMap.insert("Type", 5);
+            tmpMap.insert("SwimmingStyle", style);
+            attribMap.insert("Name", "type");
+            attribMap.insert("Value", "swimmingturn");
+            attributes.append(attribMap);
+            tmpMap.insert("Attributes", attributes);
+            marksContent.append(tmpMap);
+
+            QVariantMap periodicMap;
+            periodicMap.insert("Distance", sample->u.swimming_turn.distance / 100);
+            periodicMap.insert("LocalTime", dateTimeString(sampleDateTime));
+            periodicSamplesContent.append(periodicMap);
+
+            prevPeriodicSamplesDateTime = prevMarksDateTime = sampleDateTime;
+
+            break;
+        }
+        case ambit_log_sample_type_swimming_stroke:
+        {
+            QVariantMap tmpMap;
+            prevPeriodicSamplesDateTime = dateTimeRound(dateTimeCompensate(dateTimeRound(localBaseTime.addMSecs(sample->time), 10), prevPeriodicSamplesDateTime, 0), 10);
+            tmpMap.insert("LocalTime", dateTimeString(prevPeriodicSamplesDateTime));
+            tmpMap.insert("SwimmingStrokeType", 0);
+            periodicSamplesContent.append(tmpMap);
+            break;
+        }
         case ambit_log_sample_type_activity:
         {
             QVariantMap tmpMap;
-            tmpMap.insert("LocalTime", dateTimeString(localBaseTime.addMSecs(sample->time)));
+            if (sample->time > 0) {
+                prevMarksDateTime = dateTimeCompensate(localBaseTime.addMSecs(sample->time), prevMarksDateTime, 1);
+            }
+            else {
+                prevMarksDateTime = localBaseTime.addMSecs(sample->time);
+            }
+            tmpMap.insert("LocalTime", dateTimeString(prevMarksDateTime));
             tmpMap.insert("NextActivityID", sample->u.activity.activitytype);
             tmpMap.insert("Type", 8);
             marksContent.append(tmpMap);
@@ -595,3 +735,21 @@
         return dateTime.toString("yyyy-MM-ddThh:mm:ss");
     }
 }
+
+QDateTime MovesCountJSON::dateTimeRound(QDateTime dateTime, int msecRoundFactor)
+{
+    if (msecRoundFactor != 1) {
+        return dateTime.addMSecs(qRound(1.0*dateTime.time().msec()/msecRoundFactor)*msecRoundFactor - dateTime.time().msec());
+    }
+    else {
+        return dateTime;
+    }
+}
+
+QDateTime MovesCountJSON::dateTimeCompensate(QDateTime dateTime, QDateTime prevDateTime, int minOffset)
+{
+    if (dateTime <= prevDateTime) {
+        return prevDateTime.addMSecs(minOffset);
+    }
+    return dateTime;
+}
diff -Nur -x debian -x .git -x .pc ./src/openambit/movescount/movescountjson.h ../openambit.git/src/openambit/movescount/movescountjson.h
--- ./src/openambit/movescount/movescountjson.h	2014-09-17 21:24:43.022328657 +0200
+++ ../openambit.git/src/openambit/movescount/movescountjson.h	2014-11-05 21:53:14.677134475 +0100
@@ -52,6 +52,8 @@
     int compressData(QByteArray &content, QByteArray &output);
     QList<int> rearrangeSamples(LogEntry *logEntry);
     QString dateTimeString(QDateTime dateTime);
+    QDateTime dateTimeRound(QDateTime dateTime, int msecRoundFactor);
+    QDateTime dateTimeCompensate(QDateTime dateTime, QDateTime prevDateTime, int minOffset);
 };
 
 #endif // MOVESCOUNTJSON_H
diff -Nur -x debian -x .git -x .pc ./src/openambit/settingsdialog.cpp ../openambit.git/src/openambit/settingsdialog.cpp
--- ./src/openambit/settingsdialog.cpp	2014-09-17 21:24:43.022328657 +0200
+++ ../openambit.git/src/openambit/settingsdialog.cpp	2014-11-05 21:53:14.677134475 +0100
@@ -69,6 +69,7 @@
 {
     settings.beginGroup("generalSettings");
     ui->checkBoxSkipBetaCheck->setChecked(settings.value("skipBetaCheck", false).toBool());
+    ui->checkBoxRunningBackground->setChecked(settings.value("runningBackground", true).toBool());
     settings.endGroup();
 
     settings.beginGroup("syncSettings");
@@ -89,6 +90,7 @@
 {
     settings.beginGroup("generalSettings");
     settings.setValue("skipBetaCheck", ui->checkBoxSkipBetaCheck->isChecked());
+    settings.setValue("runningBackground", ui->checkBoxRunningBackground->isChecked());
     settings.endGroup();
 
     settings.beginGroup("syncSettings");
diff -Nur -x debian -x .git -x .pc ./src/openambit/settingsdialog.ui ../openambit.git/src/openambit/settingsdialog.ui
--- ./src/openambit/settingsdialog.ui	2014-09-17 21:24:43.022328657 +0200
+++ ../openambit.git/src/openambit/settingsdialog.ui	2014-11-05 21:53:14.677134475 +0100
@@ -105,6 +105,13 @@
                 </property>
                </widget>
               </item>
+              <item row="1" column="0">
+               <widget class="QCheckBox" name="checkBoxRunningBackground">
+                <property name="text">
+                 <string>Continue running in background when OpenAmbit main window is closed</string>
+                </property>
+               </widget>
+              </item>
              </layout>
             </widget>
            </item>
diff -Nur -x debian -x .git -x .pc ./src/openambit/translations/openambit_de.ts ../openambit.git/src/openambit/translations/openambit_de.ts
--- ./src/openambit/translations/openambit_de.ts	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/translations/openambit_de.ts	2014-11-05 21:53:14.677134475 +0100
@@ -0,0 +1,328 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE TS>
+<TS version="2.0" language="de_DE" sourcelanguage="en">
+<context>
+    <name>ConfirmBetaDialog</name>
+    <message>
+        <source>Openambit: Disclaimer</source>
+        <translation>Openambit: Disclaimer</translation>
+    </message>
+    <message>
+        <source>Don&apos;t ask me again, I really want to use Openambit</source>
+        <translation>Nicht nochmal fragen, ich möchte Openambit wirklich benutzen</translation>
+    </message>
+    <message>
+        <source>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</source>
+        <translation>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;FRÜHE BETA-SOFTWARE: &lt;a href=&quot;http://de.wikipedia.org/wiki/Hic_sunt_dracones&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;hic sunt dracones&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Diese Software ist noch in einem frühen Beta-Stadium. Sie lädt möglicherweise ungültige Log-Dateien zu Movescount hoch, die nicht überschrieben werden können oder andere unerwartete Effekte hervorrufen.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit ist freie Software: Du kannst sie weitergeben und verändern &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;entsprechend den Bedingungen der GNU General Public License, veröffentlicht von der Free Software Foundation, in Version 3 oder (nach deiner Wahl) einer beliebigen späteren Version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Dieses Programm wird in der Hoffnung weitergegeben, nützlich zu sein, aber OHNE JEGLICHE GEWÄHRLEISTUNG, insbesondere OHNE MÄNGELHAFTUNG oder die ZUSICHERUNG, dass es FÜR EINEN BESTIMMTEN ZWECK GEEIGNET ist. Für weitere Details wird auf die GNU General Public License verwiesen.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Bitte benutze dieses Programm auf &lt;span style=&quot; text-decoration: underline;&quot;&gt;eigene Gefahr&lt;/span&gt; und nur, wenn du die damit verbundenen Risiken verstanden hast.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Wenn du dich entschlossen hast, Openambit zu benutzen, dann &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;melde bitte Fehler&lt;/span&gt;&lt;/a&gt;, damit wir das Programm weiter verbessern können.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Danke &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</translation>
+    </message>
+</context>
+<context>
+    <name>DeviceManager</name>
+    <message>
+        <source>Reading personal settings</source>
+        <translation>Lese persönliche Einstellungen</translation>
+    </message>
+    <message>
+        <source>Setting date/time</source>
+        <translation>Setze Datum und Zeit</translation>
+    </message>
+    <message>
+        <source>Reading log files</source>
+        <translation>Lese Log-Dateien</translation>
+    </message>
+    <message>
+        <source>Fetching orbital data</source>
+        <translation>Hole GPS-Bahndaten</translation>
+    </message>
+    <message>
+        <source>Writing orbital data</source>
+        <translation>Schreibe GPS-Bahndaten</translation>
+    </message>
+    <message>
+        <source>Failed to get orbital data</source>
+        <translation>Fehler beim Holen der GPS-Bahndaten</translation>
+    </message>
+    <message>
+        <source>Downloading log %1 of %2</source>
+        <translation>Lade Log %1 von %2 herunter</translation>
+    </message>
+</context>
+<context>
+    <name>LogView</name>
+    <message>
+        <source>see on movescount.com</source>
+        <translation>auf Movescount.com ansehen</translation>
+    </message>
+    <message>
+        <source>Not uploaded yet</source>
+        <translation>Noch nicht hochgeladen</translation>
+    </message>
+    <message>
+        <source>Details</source>
+        <translation>Details</translation>
+    </message>
+    <message>
+        <source>Duration: %1</source>
+        <translation>Dauer: %1</translation>
+    </message>
+    <message>
+        <source>Distance: %1 m</source>
+        <translation>Distanz: %1 m</translation>
+    </message>
+    <message>
+        <source>Training values</source>
+        <translation>Trainingswerte</translation>
+    </message>
+    <message>
+        <source>Avg HR: %1 bpm</source>
+        <translation>Durchschnittspuls: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Max HR: %1 bpm</source>
+        <translation>Maximalpuls: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Min HR: %1 bpm</source>
+        <translation>Mininmalpuls: %1 bpm</translation>
+    </message>
+    <message>
+        <source>PTE: %1</source>
+        <translation>PTE: %1</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Gerät</translation>
+    </message>
+    <message>
+        <source>Name: %1</source>
+        <translation>Name: %1</translation>
+    </message>
+    <message>
+        <source>Variant: %1</source>
+        <translation>Variante: %1</translation>
+    </message>
+    <message>
+        <source>Serial: %1</source>
+        <translation>Seriennummer: %1</translation>
+    </message>
+</context>
+<context>
+    <name>MainWindow</name>
+    <message>
+        <source>Openambit</source>
+        <translation>Openambit</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Gerät</translation>
+    </message>
+    <message>
+        <source>No device detected</source>
+        <translation>Kein Gerät gefunden</translation>
+    </message>
+    <message>
+        <source>Device not supported yet!</source>
+        <translation>Gerät noch nicht unterstützt!</translation>
+    </message>
+    <message>
+        <source>Auth on &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</source>
+        <translation>Authorisieren bei &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</translation>
+    </message>
+    <message>
+        <source>Charge:</source>
+        <translation>Ladestand:</translation>
+    </message>
+    <message>
+        <source>Resync all</source>
+        <translation>Alle nochmal synchronisieren</translation>
+    </message>
+    <message>
+        <source>Sync now</source>
+        <translation>Jetzt synchronisieren</translation>
+    </message>
+    <message>
+        <source>&amp;File</source>
+        <translation>&amp;Datei</translation>
+    </message>
+    <message>
+        <source>&amp;Help</source>
+        <translation>&amp;Hilfe</translation>
+    </message>
+    <message>
+        <source>About Openambit...</source>
+        <translation>Über Openambit...</translation>
+    </message>
+    <message>
+        <source>E&amp;xit</source>
+        <translation>B&amp;enden</translation>
+    </message>
+    <message>
+        <source>&amp;Settings</source>
+        <translation>&amp;Einstellungen</translation>
+    </message>
+    <message>
+        <source>Minimize</source>
+        <translation>Minimieren</translation>
+    </message>
+    <message>
+        <source>Restore</source>
+        <translation>Wiederherstellen</translation>
+    </message>
+    <message>
+        <source>About %1</source>
+        <translation>Über %1</translation>
+    </message>
+    <message>
+        <source>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Using Qt %3</source>
+        <translation>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Unter Verwendung von Qt %3</translation>
+    </message>
+    <message>
+        <source>Syncronization complete</source>
+        <translation>Synchronisierung fertig</translation>
+    </message>
+    <message>
+        <source>Syncronisation finished</source>
+        <translation>Synchronisierung beendet</translation>
+    </message>
+    <message>
+        <source>Syncronization failed</source>
+        <translation>Synchronisierung fehlgeschlagen</translation>
+    </message>
+    <message>
+        <source>Syncronisation failed</source>
+        <translation>Synchronisierung fehlgeschlagen</translation>
+    </message>
+    <message>
+        <source>Newer firmware exists (%1.%2.%3)</source>
+        <translation>Neuere Firmware verfügbar (%1.%2.%3)</translation>
+    </message>
+    <message>
+        <source>Context menu</source>
+        <translation>Kontextmenü</translation>
+    </message>
+    <message>
+        <source>Write Movescount file</source>
+        <translation>Schreibe Movescount-Datei</translation>
+    </message>
+    <message>
+        <source>Syncronisation started</source>
+        <translation>Synchronisierung gestartet</translation>
+    </message>
+</context>
+<context>
+    <name>QObject</name>
+    <message>
+        <source>The file is not an openambit version 1.0 file.</source>
+        <translation>Die Datei hat nicht die Openambit-Version 1.0.</translation>
+    </message>
+    <message>
+        <source>%1
+Line %2, column %3</source>
+        <translation>%1
+Zeile %2, Spalte %3</translation>
+    </message>
+</context>
+<context>
+    <name>SettingsDialog</name>
+    <message>
+        <source>Dialog</source>
+        <translation>Dialog</translation>
+    </message>
+    <message>
+        <source>General</source>
+        <translation>Allgemein</translation>
+    </message>
+    <message>
+        <source>Device sync</source>
+        <translation>Gerätesynchronisierung</translation>
+    </message>
+    <message>
+        <source>Movescount</source>
+        <translation>Movescount</translation>
+    </message>
+    <message>
+        <source>General settings</source>
+        <translation>Allgemeine Einstellungen</translation>
+    </message>
+    <message>
+        <source>Skip Beta check at startup</source>
+        <translation>Beta-Warnung beim Start nicht anzeigen </translation>
+    </message>
+    <message>
+        <source>Continue running in background when OpenAmbit main window is closed</source>
+        <translation>Im Hintergrund weiter ausführen wenn das Hauptfenster geschlossen wird</translation>
+    </message>
+    <message>
+        <source>Device syncronisation settings</source>
+        <translation>Einstellungen für die Gerätesynchronisierung</translation>
+    </message>
+    <message>
+        <source>Sync time from computer</source>
+        <translation>Zeit vom Computer synchronisieren</translation>
+    </message>
+    <message>
+        <source>Sync orbital data (from Movescount)</source>
+        <translation>GPS-Satellitenbahndaten (von Movescount) synchronisieren</translation>
+    </message>
+    <message>
+        <source>Start sync automatically when device connected</source>
+        <translation>Synchronisierung automatisch starten, wenn ein Gerät angeschlossen ist</translation>
+    </message>
+    <message>
+        <source>Movescount connectivity</source>
+        <translation>Verbindung zu Movescount</translation>
+    </message>
+    <message>
+        <source>Check Movescount for new versions</source>
+        <translation>Auf Movescount nach neuen Versionen suchen</translation>
+    </message>
+    <message>
+        <source>Generate debug files (XMLs stored in ~/.openambit/movescount)</source>
+        <translation>Debug-Dateien erzeugen (XML-Dateien in ~/.openambit/movescount)</translation>
+    </message>
+    <message>
+        <source>Sync logs with Movescount</source>
+        <translation>Logs zu Movescount synchronisieren</translation>
+    </message>
+    <message>
+        <source>Email (Movescount account)</source>
+        <translation>Email des Movescount-Accounts</translation>
+    </message>
+</context>
+</TS>
diff -Nur -x debian -x .git -x .pc ./src/openambit/translations/openambit_fr.ts ../openambit.git/src/openambit/translations/openambit_fr.ts
--- ./src/openambit/translations/openambit_fr.ts	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/translations/openambit_fr.ts	2014-11-05 21:53:14.677134475 +0100
@@ -0,0 +1,319 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE TS>
+<TS version="2.0" language="sv_SE">
+<context>
+    <name>ConfirmBetaDialog</name>
+    <message>
+        <source>Openambit: Disclaimer</source>
+        <translation>Openambit: Avertissement</translation>
+    </message>
+    <message>
+        <source>Don&apos;t ask me again, I really want to use Openambit</source>
+        <translation>Ne plus me poser cette question.</translation>
+    </message>
+    <message>
+        <source>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>DeviceManager</name>
+    <message>
+        <source>Reading personal settings</source>
+        <translation>Läser personliga inställningar</translation>
+    </message>
+    <message>
+        <source>Setting date/time</source>
+        <translation>Skriver datum &amp; tid</translation>
+    </message>
+    <message>
+        <source>Reading log files</source>
+        <translation>Läser logg-filer</translation>
+    </message>
+    <message>
+        <source>Fetching orbital data</source>
+        <translation>Hämtar GPS-data</translation>
+    </message>
+    <message>
+        <source>Writing orbital data</source>
+        <translation>Skriver GPS-data</translation>
+    </message>
+    <message>
+        <source>Failed to get orbital data</source>
+        <translation>GPS-data gick ej att hämta</translation>
+    </message>
+    <message>
+        <source>Downloading log %1 of %2</source>
+        <translation>Läser logg %1 av %2</translation>
+    </message>
+</context>
+<context>
+    <name>LogEntry</name>
+    <message>
+        <source>Device</source>
+        <translation type="obsolete">Périphérique</translation>
+    </message>
+</context>
+<context>
+    <name>LogView</name>
+    <message>
+        <source>see on movescount.com</source>
+        <translation>voir sur movescount.com</translation>
+    </message>
+    <message>
+        <source>Not uploaded yet</source>
+        <translation>Pas encore envoyé</translation>
+    </message>
+    <message>
+        <source>Details</source>
+        <translation>Détails</translation>
+    </message>
+    <message>
+        <source>Duration: %1</source>
+        <translation>Durée : %1</translation>
+    </message>
+    <message>
+        <source>Distance: %1 m</source>
+        <translation>Distance : %1 m</translation>
+    </message>
+    <message>
+        <source>Training values</source>
+        <translation>Paramètres physiologiques</translation>
+    </message>
+    <message>
+        <source>Avg HR: %1 bpm</source>
+        <translation>Fréq. cardiaque moy. : %1 puls/mn</translation>
+    </message>
+    <message>
+        <source>Max HR: %1 bpm</source>
+        <translation>Fréq. cardiaque maxi : %1 puls/mn
+</translation>
+    </message>
+    <message>
+        <source>Min HR: %1 bpm</source>
+        <translation>Fréq. cardiaque mini : %1 puls/mn
+</translation>
+    </message>
+    <message>
+        <source>PTE: %1</source>
+        <translation>PTE : %1</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Périphérique</translation>
+    </message>
+    <message>
+        <source>Name: %1</source>
+        <translation>Nom : %1</translation>
+    </message>
+    <message>
+        <source>Variant: %1</source>
+        <translation>Variante : %1</translation>
+    </message>
+    <message>
+        <source>Serial: %1</source>
+        <translation>N/S : %1</translation>
+    </message>
+</context>
+<context>
+    <name>MainWindow</name>
+    <message>
+        <source>Sync now</source>
+        <translation>Synchroniser maintenant</translation>
+    </message>
+    <message>
+        <source>Minimize</source>
+        <translation>Minimiser</translation>
+    </message>
+    <message>
+        <source>Restore</source>
+        <translation>Restaurer</translation>
+    </message>
+    <message>
+        <source>About %1</source>
+        <translation>À propos d&apos;%1</translation>
+    </message>
+    <message>
+        <source>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Using Qt %3</source>
+        <translation>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Qt %3</translation>
+    </message>
+    <message>
+        <source>No device detected</source>
+        <translation>Pas de périphérique détecté</translation>
+    </message>
+    <message>
+        <source>Syncronization complete</source>
+        <translation>Synchronisation complète</translation>
+    </message>
+    <message>
+        <source>Syncronisation finished</source>
+        <translation>Synchronisation terminée</translation>
+    </message>
+    <message>
+        <source>Syncronization failed</source>
+        <translation>Échec de synchronisation</translation>
+    </message>
+    <message>
+        <source>Syncronisation failed</source>
+        <translation>Échec de synchronisation</translation>
+    </message>
+    <message>
+        <source>Newer firmware exists (%1.%2.%3)</source>
+        <translation>Nouveau micrologiciel (firmware) disponible (%1.%2.%3)</translation>
+    </message>
+    <message>
+        <source>Context menu</source>
+        <translation>Menu contextuel</translation>
+    </message>
+    <message>
+        <source>Write Movescount file</source>
+        <translation>Écrire le fichier Movescount</translation>
+    </message>
+    <message>
+        <source>Syncronisation started</source>
+        <translation>Début de synchronisation</translation>
+    </message>
+    <message>
+        <source>Openambit</source>
+        <translation>Openambit</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Périphérique</translation>
+    </message>
+    <message>
+        <source>Device not supported yet!</source>
+        <translation>Périphérique non géré</translation>
+    </message>
+    <message>
+        <source>Auth on &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</source>
+        <translation>S&apos;authentifier sur &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</translation>
+    </message>
+    <message>
+        <source>Charge:</source>
+        <translation>Charge :</translation>
+    </message>
+    <message>
+        <source>Resync all</source>
+        <translation>Tout resynchroniser</translation>
+    </message>
+    <message>
+        <source>&amp;File</source>
+        <translation>&amp;Fichier</translation>
+    </message>
+    <message>
+        <source>&amp;Help</source>
+        <translation>&amp;Aide</translation>
+    </message>
+    <message>
+        <source>About Openambit...</source>
+        <translation>À propos d&apos;Openambit...</translation>
+    </message>
+    <message>
+        <source>E&amp;xit</source>
+        <translation>&amp;Quitter</translation>
+    </message>
+    <message>
+        <source>&amp;Settings</source>
+        <translation>&amp;Réglages</translation>
+    </message>
+</context>
+<context>
+    <name>QObject</name>
+    <message>
+        <source>The file is not an openambit version 1.0 file.</source>
+        <translation>Ce fichier n&apos;est pas un fichier OpenAmbit version 1.0</translation>
+    </message>
+    <message>
+        <source>%1
+Line %2, column %3</source>
+        <translation>%1
+Ligne %2, colonne %3</translation>
+    </message>
+</context>
+<context>
+    <name>SettingsDialog</name>
+    <message>
+        <source>Dialog</source>
+        <translation>Dialogue</translation>
+    </message>
+    <message>
+        <source>General</source>
+        <translation>Général</translation>
+    </message>
+    <message>
+        <source>Device sync</source>
+        <translation>Synchronisation du périphérique</translation>
+    </message>
+    <message>
+        <source>Movescount</source>
+        <translation>Movescount</translation>
+    </message>
+    <message>
+        <source>General settings</source>
+        <translation>Réglages généraux</translation>
+    </message>
+    <message>
+        <source>Skip Beta check at startup</source>
+        <translation>Ne pas signaler les versions beta au démarrage</translation>
+    </message>
+    <message>
+        <source>Continue running in background when OpenAmbit main window is closed</source>
+        <translation>Poursuivre le fonctionnement en tâche de fond lorsque la fenêtre principale d&apos;OpenAmbit est fermée</translation>
+    </message>
+    <message>
+        <source>Device syncronisation settings</source>
+        <translation>Réglages de synchronisation du périphérique</translation>
+    </message>
+    <message>
+        <source>Sync time from computer</source>
+        <translation>Synchroniser l&apos;heure avec l&apos;ordinateur</translation>
+    </message>
+    <message>
+        <source>Sync orbital data (from Movescount)</source>
+        <translation>Synchroniser les données orbitales des satellites (depuis Movescount)</translation>
+    </message>
+    <message>
+        <source>Start sync automatically when device connected</source>
+        <translation>Démarrer automatiquement la synchronisation à la connexion du périphérique</translation>
+    </message>
+    <message>
+        <source>Movescount connectivity</source>
+        <translation>Connexion à Movescount</translation>
+    </message>
+    <message>
+        <source>Check Movescount for new versions</source>
+        <translation>Vérifier les nouvelles versions sur Movescount</translation>
+    </message>
+    <message>
+        <source>Generate debug files (XMLs stored in ~/.openambit/movescount)</source>
+        <translation>Créer des fichiers de débogage (fichiers XML dans ~/.openambit/movescount)</translation>
+    </message>
+    <message>
+        <source>Sync logs with Movescount</source>
+        <translation>Synchroniser les informations avec Movescount</translation>
+    </message>
+    <message>
+        <source>Email (Movescount account)</source>
+        <translation>Adresse électronique (du compte Movescount)</translation>
+    </message>
+</context>
+</TS>
diff -Nur -x debian -x .git -x .pc ./src/openambit/translations/openambit_it.ts ../openambit.git/src/openambit/translations/openambit_it.ts
--- ./src/openambit/translations/openambit_it.ts	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/translations/openambit_it.ts	2014-11-05 21:53:14.677134475 +0100
@@ -0,0 +1,328 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE TS>
+<TS version="2.0" language="it" sourcelanguage="en">
+<context>
+    <name>ConfirmBetaDialog</name>
+    <message>
+        <source>Openambit: Disclaimer</source>
+        <translation>Openambit: Attenzione</translation>
+    </message>
+    <message>
+        <source>Don&apos;t ask me again, I really want to use Openambit</source>
+        <translation>Non mi chiedere piu, voglio veramente uasre Openambit</translation>
+    </message>
+    <message>
+        <source>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</source>
+        <translation>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;SOFTWARE BETA : &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;Si salvi chi puó&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Questo sogtware é molto giovane e potrebbe caricare dei log sbagliati, incancellabili, ecc su movescount&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Perfavore usa questo software &lt;span style=&quot; text-decoration: underline;&quot;&gt;a tuo&lt;/span&gt; rischio e pericolo solo se capisci i rischi implicati.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Se decidi di usare Openambit, perfavore &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;segnalaci eventuali bachi&lt;/span&gt;&lt;/a&gt; cosi da poterli riparare.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Grazie &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</translation>
+    </message>
+</context>
+<context>
+    <name>DeviceManager</name>
+    <message>
+        <source>Reading personal settings</source>
+        <translation>Leggendo impostazioni</translation>
+    </message>
+    <message>
+        <source>Setting date/time</source>
+        <translation>Impostando data/ora</translation>
+    </message>
+    <message>
+        <source>Reading log files</source>
+        <translation>Leggendo file di log</translation>
+    </message>
+    <message>
+        <source>Fetching orbital data</source>
+        <translation>Ottenendo dati orbitali</translation>
+    </message>
+    <message>
+        <source>Writing orbital data</source>
+        <translation>Scrivendo dati orbitali</translation>
+    </message>
+    <message>
+        <source>Failed to get orbital data</source>
+        <translation>Errore ottenendo dati orbitali</translation>
+    </message>
+    <message>
+        <source>Downloading log %1 of %2</source>
+        <translation>Sacricando log %1 di %2</translation>
+    </message>
+</context>
+<context>
+    <name>LogView</name>
+    <message>
+        <source>see on movescount.com</source>
+        <translation>Vedi su movescount.com</translation>
+    </message>
+    <message>
+        <source>Not uploaded yet</source>
+        <translation>Non ancora caricata</translation>
+    </message>
+    <message>
+        <source>Details</source>
+        <translation>Dettagli</translation>
+    </message>
+    <message>
+        <source>Duration: %1</source>
+        <translation>Durata: %1</translation>
+    </message>
+    <message>
+        <source>Distance: %1 m</source>
+        <translation>Distanza: %1</translation>
+    </message>
+    <message>
+        <source>Training values</source>
+        <translation>Valori d&apos;allenamento</translation>
+    </message>
+    <message>
+        <source>Avg HR: %1 bpm</source>
+        <translation>Frequenza cardicaca media: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Max HR: %1 bpm</source>
+        <translation>Frequenza cardicaca max: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Min HR: %1 bpm</source>
+        <translation>Frequenza cardicaca min: %1 bpm</translation>
+    </message>
+    <message>
+        <source>PTE: %1</source>
+        <translation>PTE: %1</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Orologio</translation>
+    </message>
+    <message>
+        <source>Name: %1</source>
+        <translation>Nome: %1</translation>
+    </message>
+    <message>
+        <source>Variant: %1</source>
+        <translation>Variante: %1</translation>
+    </message>
+    <message>
+        <source>Serial: %1</source>
+        <translation>Seriale: %1</translation>
+    </message>
+</context>
+<context>
+    <name>MainWindow</name>
+    <message>
+        <source>Openambit</source>
+        <translation>Openambit</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Orologio</translation>
+    </message>
+    <message>
+        <source>No device detected</source>
+        <translation>Nessun orologio trovato</translation>
+    </message>
+    <message>
+        <source>Device not supported yet!</source>
+        <translation>Orologio non ancora supportato!</translation>
+    </message>
+    <message>
+        <source>Auth on &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</source>
+        <translation>Autorizza su &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</translation>
+    </message>
+    <message>
+        <source>Charge:</source>
+        <translation>Carica:</translation>
+    </message>
+    <message>
+        <source>Resync all</source>
+        <translation>Resincronizza tutto</translation>
+    </message>
+    <message>
+        <source>Sync now</source>
+        <translation>Sincronizza ora</translation>
+    </message>
+    <message>
+        <source>&amp;File</source>
+        <translation>&amp;File</translation>
+    </message>
+    <message>
+        <source>&amp;Help</source>
+        <translation>&amp;Aiuto</translation>
+    </message>
+    <message>
+        <source>About Openambit...</source>
+        <translation>A proposito di Openambit...</translation>
+    </message>
+    <message>
+        <source>E&amp;xit</source>
+        <translation>E&amp;sci</translation>
+    </message>
+    <message>
+        <source>&amp;Settings</source>
+        <translation>&amp;Impostazioni</translation>
+    </message>
+    <message>
+        <source>Minimize</source>
+        <translation>Minimizza</translation>
+    </message>
+    <message>
+        <source>Restore</source>
+        <translation>Ripristina</translation>
+    </message>
+    <message>
+        <source>About %1</source>
+        <translation>A proposito %1</translation>
+    </message>
+    <message>
+        <source>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Using Qt %3</source>
+        <translation>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Versione %2&lt;/b&gt;&lt;br /&gt;Usando Qt %3</translation>
+    </message>
+    <message>
+        <source>Syncronization complete</source>
+        <translation>Sincronizzazione completa</translation>
+    </message>
+    <message>
+        <source>Syncronisation finished</source>
+        <translation>Sincronizzazione completa</translation>
+    </message>
+    <message>
+        <source>Syncronization failed</source>
+        <translation>Sincronizzazione fallita</translation>
+    </message>
+    <message>
+        <source>Syncronisation failed</source>
+        <translation>Sincronizzazione fallita</translation>
+    </message>
+    <message>
+        <source>Newer firmware exists (%1.%2.%3)</source>
+        <translation>Nuovo firmware disponibile (%1.%2.%3)</translation>
+    </message>
+    <message>
+        <source>Context menu</source>
+        <translation>Menu contestuale</translation>
+    </message>
+    <message>
+        <source>Write Movescount file</source>
+        <translation>Scrivi file Movescount</translation>
+    </message>
+    <message>
+        <source>Syncronisation started</source>
+        <translation>Sincronizzazione iniziata</translation>
+    </message>
+</context>
+<context>
+    <name>QObject</name>
+    <message>
+        <source>The file is not an openambit version 1.0 file.</source>
+        <translation>Il file non é un file openambit versione 1.0.</translation>
+    </message>
+    <message>
+        <source>%1
+Line %2, column %3</source>
+        <translation>%1
+riga %2, colonna %3</translation>
+    </message>
+</context>
+<context>
+    <name>SettingsDialog</name>
+    <message>
+        <source>Dialog</source>
+        <translation>Dialogo</translation>
+    </message>
+    <message>
+        <source>General</source>
+        <translation>Generale</translation>
+    </message>
+    <message>
+        <source>Device sync</source>
+        <translation>Sincronizzazione orologio</translation>
+    </message>
+    <message>
+        <source>Movescount</source>
+        <translation>Movescount</translation>
+    </message>
+    <message>
+        <source>General settings</source>
+        <translation>Impostazioni generali</translation>
+    </message>
+    <message>
+        <source>Skip Beta check at startup</source>
+        <translation>Salta il controllo beta all&apos;accensione</translation>
+    </message>
+    <message>
+        <source>Continue running in background when OpenAmbit main window is closed</source>
+        <translation>RImani in background anche chiudendo la finestra pincipale</translation>
+    </message>
+    <message>
+        <source>Device syncronisation settings</source>
+        <translation>Impostazioi sincronizzazione</translation>
+    </message>
+    <message>
+        <source>Sync time from computer</source>
+        <translation>Sincronizzazione completa</translation>
+    </message>
+    <message>
+        <source>Sync orbital data (from Movescount)</source>
+        <translation>Syicronizza dati orbitali (da movescount.com)</translation>
+    </message>
+    <message>
+        <source>Start sync automatically when device connected</source>
+        <translation>Sincronizza auomaticamente quando si connette un orologio</translation>
+    </message>
+    <message>
+        <source>Movescount connectivity</source>
+        <translation>Connessione Movescount</translation>
+    </message>
+    <message>
+        <source>Check Movescount for new versions</source>
+        <translation>Cerca nuove versioni su movescount</translation>
+    </message>
+    <message>
+        <source>Generate debug files (XMLs stored in ~/.openambit/movescount)</source>
+        <translation>Genera files di debug (XMLs stored in ~/.openambit/movescount)</translation>
+    </message>
+    <message>
+        <source>Sync logs with Movescount</source>
+        <translation>Syicronizza dati con movescount.com</translation>
+    </message>
+    <message>
+        <source>Email (Movescount account)</source>
+        <translation>Email (Account Movescount)</translation>
+    </message>
+</context>
+</TS>
diff -Nur -x debian -x .git -x .pc ./src/openambit/translations/openambit_pl.ts ../openambit.git/src/openambit/translations/openambit_pl.ts
--- ./src/openambit/translations/openambit_pl.ts	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/translations/openambit_pl.ts	2014-11-05 21:53:14.677134475 +0100
@@ -0,0 +1,328 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE TS>
+<TS version="2.0" language="pl_PL">
+<context>
+    <name>ConfirmBetaDialog</name>
+    <message>
+        <source>Openambit: Disclaimer</source>
+        <translation>Openambit: Zastrzeżenia</translation>
+    </message>
+    <message>
+        <source>Don&apos;t ask me again, I really want to use Openambit</source>
+        <translation>Nie pytaj ponownie, na prawdę chcę użyć Openambit</translation>
+    </message>
+    <message>
+        <source>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</source>
+        <translation>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</translation>
+    </message>
+</context>
+<context>
+    <name>DeviceManager</name>
+    <message>
+        <source>Reading personal settings</source>
+        <translation>Odczytywanie ustawień osobistych</translation>
+    </message>
+    <message>
+        <source>Setting date/time</source>
+        <translation>Ustawianie daty/czasu</translation>
+    </message>
+    <message>
+        <source>Reading log files</source>
+        <translation>Odczytywanie logów</translation>
+    </message>
+    <message>
+        <source>Fetching orbital data</source>
+        <translation>Pobieranie ustawień satelitów</translation>
+    </message>
+    <message>
+        <source>Writing orbital data</source>
+        <translation>Zapisywnie danych satelitów</translation>
+    </message>
+    <message>
+        <source>Failed to get orbital data</source>
+        <translation>Nieudane pobranie ustawień satelitów</translation>
+    </message>
+    <message>
+        <source>Downloading log %1 of %2</source>
+        <translation>Pobieranie logu %1 z %2</translation>
+    </message>
+</context>
+<context>
+    <name>LogView</name>
+    <message>
+        <source>see on movescount.com</source>
+        <translation>Zobacz na movescount.com</translation>
+    </message>
+    <message>
+        <source>Not uploaded yet</source>
+        <translation>Jeszcze nie przesłano</translation>
+    </message>
+    <message>
+        <source>Details</source>
+        <translation>Szczegóły</translation>
+    </message>
+    <message>
+        <source>Duration: %1</source>
+        <translation>Czas trwania: %1</translation>
+    </message>
+    <message>
+        <source>Distance: %1 m</source>
+        <translation>Dystans: %1 m</translation>
+    </message>
+    <message>
+        <source>Training values</source>
+        <translation>Czegóły treningu</translation>
+    </message>
+    <message>
+        <source>Avg HR: %1 bpm</source>
+        <translation>Średnie tętno: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Max HR: %1 bpm</source>
+        <translation>Maksymalne tętno: %1 bpm</translation>
+    </message>
+    <message>
+        <source>Min HR: %1 bpm</source>
+        <translation>Minimalne tętno: %1 bpm</translation>
+    </message>
+    <message>
+        <source>PTE: %1</source>
+        <translation>PTE: %1</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Urządzenie</translation>
+    </message>
+    <message>
+        <source>Name: %1</source>
+        <translation>Nazwa: %1</translation>
+    </message>
+    <message>
+        <source>Variant: %1</source>
+        <translation type="unfinished">Wariant: %1</translation>
+    </message>
+    <message>
+        <source>Serial: %1</source>
+        <translation type="unfinished">Seria: %1</translation>
+    </message>
+</context>
+<context>
+    <name>MainWindow</name>
+    <message>
+        <source>Openambit</source>
+        <translation>Openambit</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Urządzenie</translation>
+    </message>
+    <message>
+        <source>No device detected</source>
+        <translation>Nie znaleziono urządzenia</translation>
+    </message>
+    <message>
+        <source>Device not supported yet!</source>
+        <translation>Urządzenie jeszcze nie obsługiwane!</translation>
+    </message>
+    <message>
+        <source>Auth on &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</source>
+        <translation>Autentykacja na &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</translation>
+    </message>
+    <message>
+        <source>Charge:</source>
+        <translation>Ładowanie:</translation>
+    </message>
+    <message>
+        <source>Resync all</source>
+        <translation>Synchronizuj wszystko ponownie</translation>
+    </message>
+    <message>
+        <source>Sync now</source>
+        <translation>Synchronizuj teraz</translation>
+    </message>
+    <message>
+        <source>&amp;File</source>
+        <translation>&amp;Plik</translation>
+    </message>
+    <message>
+        <source>&amp;Help</source>
+        <translation>P&amp;omoc</translation>
+    </message>
+    <message>
+        <source>About Openambit...</source>
+        <translation>O Openambit...</translation>
+    </message>
+    <message>
+        <source>E&amp;xit</source>
+        <translation>&amp;Wyjście</translation>
+    </message>
+    <message>
+        <source>&amp;Settings</source>
+        <translation>&amp;Ustawienia</translation>
+    </message>
+    <message>
+        <source>Minimize</source>
+        <translation>Zminimalizuj</translation>
+    </message>
+    <message>
+        <source>Restore</source>
+        <translation>Przywróć</translation>
+    </message>
+    <message>
+        <source>About %1</source>
+        <translation>O %1</translation>
+    </message>
+    <message>
+        <source>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Using Qt %3</source>
+        <translation>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Wersja %2&lt;/b&gt;&lt;br /&gt;Używa Qt %3</translation>
+    </message>
+    <message>
+        <source>Syncronization complete</source>
+        <translation>Synchronizacja zakończona</translation>
+    </message>
+    <message>
+        <source>Syncronisation finished</source>
+        <translation>Synchronizacja zakończona</translation>
+    </message>
+    <message>
+        <source>Syncronization failed</source>
+        <translation>Synchronizacja nieudana</translation>
+    </message>
+    <message>
+        <source>Syncronisation failed</source>
+        <translation>Synchronizacja nieudana</translation>
+    </message>
+    <message>
+        <source>Newer firmware exists (%1.%2.%3)</source>
+        <translation>Istnieje nowa wersja oprogramowania (%1.%2.%3)</translation>
+    </message>
+    <message>
+        <source>Context menu</source>
+        <translation>Menu kontekstowe</translation>
+    </message>
+    <message>
+        <source>Write Movescount file</source>
+        <translation>Zapisz plik Movescount</translation>
+    </message>
+    <message>
+        <source>Syncronisation started</source>
+        <translation>Synchronizacja rozpoczęta</translation>
+    </message>
+</context>
+<context>
+    <name>QObject</name>
+    <message>
+        <source>The file is not an openambit version 1.0 file.</source>
+        <translation>To nie jest plik openambit w wersji 1.0.</translation>
+    </message>
+    <message>
+        <source>%1
+Line %2, column %3</source>
+        <translation>%1
+Linia %2, kolumna %3</translation>
+    </message>
+</context>
+<context>
+    <name>SettingsDialog</name>
+    <message>
+        <source>Dialog</source>
+        <translation type="unfinished">Dialog</translation>
+    </message>
+    <message>
+        <source>General</source>
+        <translation>Ogólne</translation>
+    </message>
+    <message>
+        <source>Device sync</source>
+        <translation>Synchronizacja urządzenia</translation>
+    </message>
+    <message>
+        <source>Movescount</source>
+        <translation>Movescount</translation>
+    </message>
+    <message>
+        <source>General settings</source>
+        <translation>Ustawienia ogólne</translation>
+    </message>
+    <message>
+        <source>Skip Beta check at startup</source>
+        <translation>Pomiń Beta sprawdzanie przy uruchomieniu</translation>
+    </message>
+    <message>
+        <source>Continue running in background when OpenAmbit main window is closed</source>
+        <translation>Kontynuuj działanie w tle, gdy główne okno OpenAmbit jest zamknięte</translation>
+    </message>
+    <message>
+        <source>Device syncronisation settings</source>
+        <translation>Synchronizacja ustawień urządzenia</translation>
+    </message>
+    <message>
+        <source>Sync time from computer</source>
+        <translation>Synchronizuj czas z komputera</translation>
+    </message>
+    <message>
+        <source>Sync orbital data (from Movescount)</source>
+        <translation>Synchronizuj dane satelitów (z Movescount)</translation>
+    </message>
+    <message>
+        <source>Start sync automatically when device connected</source>
+        <translation>Rozpoczynij automatyczną synchronizację, gdy urządzenie jest podłączone</translation>
+    </message>
+    <message>
+        <source>Movescount connectivity</source>
+        <translation>Połączenie z Movescount</translation>
+    </message>
+    <message>
+        <source>Check Movescount for new versions</source>
+        <translation>Sprawdź nową wersję w Movescount</translation>
+    </message>
+    <message>
+        <source>Generate debug files (XMLs stored in ~/.openambit/movescount)</source>
+        <translation>Generuj pliki debug (XMLe trzymane są w ~/.openambit/movescount)</translation>
+    </message>
+    <message>
+        <source>Sync logs with Movescount</source>
+        <translation>Synchronizuj treningi z Movescount</translation>
+    </message>
+    <message>
+        <source>Email (Movescount account)</source>
+        <translation>Email (konto Movescount)</translation>
+    </message>
+</context>
+</TS>
diff -Nur -x debian -x .git -x .pc ./src/openambit/translations/openambit_sv.ts ../openambit.git/src/openambit/translations/openambit_sv.ts
--- ./src/openambit/translations/openambit_sv.ts	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit/translations/openambit_sv.ts	2014-11-05 21:53:14.677134475 +0100
@@ -0,0 +1,317 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE TS>
+<TS version="2.0" language="sv_SE">
+<context>
+    <name>ConfirmBetaDialog</name>
+    <message>
+        <source>Openambit: Disclaimer</source>
+        <translation>Openambit: Varning</translation>
+    </message>
+    <message>
+        <source>Don&apos;t ask me again, I really want to use Openambit</source>
+        <translation>Fråga mig inte igen</translation>
+    </message>
+    <message>
+        <source>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+p, li { white-space: pre-wrap; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;Ubuntu&apos;; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;EARLY BETA SOFTWARE: &lt;a href=&quot;http://en.wikipedia.org/wiki/Here_be_dragons&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;here be dragons&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This software is in early beta stage, it might upload invalid logs to movescount that cannot be overwritten, and do other bizarre things.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; color:#008000;&quot;&gt;Openambit&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;free&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;software:&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;you&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;can&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;redistribute&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;and/or&lt;/span&gt;&lt;span style=&quot; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; color:#008000;&quot;&gt;modify &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;under&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;terms&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;as&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;published&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;by the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Free&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Software&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Foundation,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;either&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License,&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;(at&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;your&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;option)&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;any&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;later&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;version.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;This&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;program&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;is&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;distributed&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;hope&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;that&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;it&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;will&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;be&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;useful, but&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WITHOUT&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;ANY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;WARRANTY;&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;without&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;even&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;implied&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;warranty&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;of&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;MERCHANTABILITY&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;or&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FITNESS&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;FOR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PARTICULAR&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;PURPOSE.&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;See&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;the GNU&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;General&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;License&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;more&lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#c0c0c0;&quot;&gt; &lt;/span&gt;&lt;span style=&quot; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;details.&lt;/span&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Please use this software at &lt;span style=&quot; text-decoration: underline;&quot;&gt;your own&lt;/span&gt; risk and only if you understand the risks involved.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;If you decide to use Openambit please consider &lt;a href=&quot;https://github.com/openambitproject/openambit/issues/new&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0000ff;&quot;&gt;reporting bugs&lt;/span&gt;&lt;/a&gt; so we can make it better.&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Thanks &lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
+&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:&apos;Courier New,courier&apos;; color:#008000;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</source>
+        <translation type="unfinished"></translation>
+    </message>
+</context>
+<context>
+    <name>DeviceManager</name>
+    <message>
+        <source>Reading personal settings</source>
+        <translation>Läser personliga inställningar</translation>
+    </message>
+    <message>
+        <source>Setting date/time</source>
+        <translation>Skriver datum &amp; tid</translation>
+    </message>
+    <message>
+        <source>Reading log files</source>
+        <translation>Läser logg-filer</translation>
+    </message>
+    <message>
+        <source>Fetching orbital data</source>
+        <translation>Hämtar GPS-data</translation>
+    </message>
+    <message>
+        <source>Writing orbital data</source>
+        <translation>Skriver GPS-data</translation>
+    </message>
+    <message>
+        <source>Failed to get orbital data</source>
+        <translation>GPS-data gick ej att hämta</translation>
+    </message>
+    <message>
+        <source>Downloading log %1 of %2</source>
+        <translation>Läser logg %1 av %2</translation>
+    </message>
+</context>
+<context>
+    <name>LogEntry</name>
+    <message>
+        <source>Device</source>
+        <translation type="obsolete">Enhet</translation>
+    </message>
+</context>
+<context>
+    <name>LogView</name>
+    <message>
+        <source>see on movescount.com</source>
+        <translation>se på movescount.com</translation>
+    </message>
+    <message>
+        <source>Not uploaded yet</source>
+        <translation>Ej uppladdad</translation>
+    </message>
+    <message>
+        <source>Details</source>
+        <translation>Detaljer</translation>
+    </message>
+    <message>
+        <source>Duration: %1</source>
+        <translation>Tid: %1</translation>
+    </message>
+    <message>
+        <source>Distance: %1 m</source>
+        <translation>Sträcka: %1 m</translation>
+    </message>
+    <message>
+        <source>Training values</source>
+        <translation>Träningsdetaljer</translation>
+    </message>
+    <message>
+        <source>Avg HR: %1 bpm</source>
+        <translation>Snittpuls: %1 slag/min</translation>
+    </message>
+    <message>
+        <source>Max HR: %1 bpm</source>
+        <translation>Maxpuls: %1 slag/min</translation>
+    </message>
+    <message>
+        <source>Min HR: %1 bpm</source>
+        <translation>Minpuls: %1 slag/min</translation>
+    </message>
+    <message>
+        <source>PTE: %1</source>
+        <translation>PTE: %1</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Enhet</translation>
+    </message>
+    <message>
+        <source>Name: %1</source>
+        <translation>Modell: %1</translation>
+    </message>
+    <message>
+        <source>Variant: %1</source>
+        <translation>Variant: %1</translation>
+    </message>
+    <message>
+        <source>Serial: %1</source>
+        <translation>Serienummer: %1</translation>
+    </message>
+</context>
+<context>
+    <name>MainWindow</name>
+    <message>
+        <source>Sync now</source>
+        <translation>Synkronisera</translation>
+    </message>
+    <message>
+        <source>Minimize</source>
+        <translation>Minimera</translation>
+    </message>
+    <message>
+        <source>Restore</source>
+        <translation>Återställ</translation>
+    </message>
+    <message>
+        <source>About %1</source>
+        <translation>Om %1</translation>
+    </message>
+    <message>
+        <source>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Using Qt %3</source>
+        <translation>&lt;h2&gt;%1&lt;/h2&gt;&lt;b&gt;Version %2&lt;/b&gt;&lt;br /&gt;Qt %3</translation>
+    </message>
+    <message>
+        <source>No device detected</source>
+        <translation>Ingen enhet hittades</translation>
+    </message>
+    <message>
+        <source>Syncronization complete</source>
+        <translation>Synkroniseringen slutförd</translation>
+    </message>
+    <message>
+        <source>Syncronisation finished</source>
+        <translation>Synkroniseringen slutförd</translation>
+    </message>
+    <message>
+        <source>Syncronization failed</source>
+        <translation>Synkroniseringen misslyckades</translation>
+    </message>
+    <message>
+        <source>Syncronisation failed</source>
+        <translation>Synkroniseringen misslyckades</translation>
+    </message>
+    <message>
+        <source>Newer firmware exists (%1.%2.%3)</source>
+        <translation>Det finns en nyare firmware (%1.%2.%3)</translation>
+    </message>
+    <message>
+        <source>Context menu</source>
+        <translation>Snabbval</translation>
+    </message>
+    <message>
+        <source>Write Movescount file</source>
+        <translation>Skriv Movescount-fil</translation>
+    </message>
+    <message>
+        <source>Syncronisation started</source>
+        <translation>Synkronisering startad</translation>
+    </message>
+    <message>
+        <source>Openambit</source>
+        <translation>Openambit</translation>
+    </message>
+    <message>
+        <source>Device</source>
+        <translation>Enhet</translation>
+    </message>
+    <message>
+        <source>Device not supported yet!</source>
+        <translation>Enheten stöds inte än!</translation>
+    </message>
+    <message>
+        <source>Auth on &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</source>
+        <translation>Tillåt Openambit på &lt;a href=&quot;http://www.movescount.com&quot;&gt;&lt;span style=&quot; text-decoration: underline; color:#0057ae;&quot;&gt;movescount.com&lt;/span&gt;&lt;/a&gt;!</translation>
+    </message>
+    <message>
+        <source>Charge:</source>
+        <translation>Laddning:</translation>
+    </message>
+    <message>
+        <source>Resync all</source>
+        <translation>Omsynkronsiera allt</translation>
+    </message>
+    <message>
+        <source>&amp;File</source>
+        <translation>&amp;Arkiv</translation>
+    </message>
+    <message>
+        <source>&amp;Help</source>
+        <translation>&amp;Hjälp</translation>
+    </message>
+    <message>
+        <source>About Openambit...</source>
+        <translation>Om Openambit...</translation>
+    </message>
+    <message>
+        <source>E&amp;xit</source>
+        <translation>A&amp;vsluta</translation>
+    </message>
+    <message>
+        <source>&amp;Settings</source>
+        <translation>&amp;Inställningar</translation>
+    </message>
+</context>
+<context>
+    <name>QObject</name>
+    <message>
+        <source>The file is not an openambit version 1.0 file.</source>
+        <translation>Filen är inte i openambit version 1.0-format.</translation>
+    </message>
+    <message>
+        <source>%1
+Line %2, column %3</source>
+        <translation>%1
+Rad %2, kolumn %3</translation>
+    </message>
+</context>
+<context>
+    <name>SettingsDialog</name>
+    <message>
+        <source>Dialog</source>
+        <translation>Dialog</translation>
+    </message>
+    <message>
+        <source>General</source>
+        <translation>Generellt</translation>
+    </message>
+    <message>
+        <source>Device sync</source>
+        <translation>Synkronisering</translation>
+    </message>
+    <message>
+        <source>Movescount</source>
+        <translation>Movescount</translation>
+    </message>
+    <message>
+        <source>General settings</source>
+        <translation>Generella inställningar</translation>
+    </message>
+    <message>
+        <source>Skip Beta check at startup</source>
+        <translation>Visa inte beta-varning vid uppstart</translation>
+    </message>
+    <message>
+        <source>Continue running in background when OpenAmbit main window is closed</source>
+        <translation>Låt Openambit fortsätta köra i bakgrunden när fönstret stängs</translation>
+    </message>
+    <message>
+        <source>Device syncronisation settings</source>
+        <translation>Synkroniseringsinställningar</translation>
+    </message>
+    <message>
+        <source>Sync time from computer</source>
+        <translation>Synkronisera enhet med datorns tid</translation>
+    </message>
+    <message>
+        <source>Sync orbital data (from Movescount)</source>
+        <translation>Synkronisera GPS-data (från Movescount)</translation>
+    </message>
+    <message>
+        <source>Start sync automatically when device connected</source>
+        <translation>Starta synkroniseringen automatiskt när enhet ansluts</translation>
+    </message>
+    <message>
+        <source>Movescount connectivity</source>
+        <translation>Movescount-inställningar</translation>
+    </message>
+    <message>
+        <source>Check Movescount for new versions</source>
+        <translation>Leta efter firmware-uppdatering hos Movescount</translation>
+    </message>
+    <message>
+        <source>Generate debug files (XMLs stored in ~/.openambit/movescount)</source>
+        <translation>Generera felsökningsfiler (XML-filer som sparas i ~/.openambit/movescount)</translation>
+    </message>
+    <message>
+        <source>Sync logs with Movescount</source>
+        <translation>Ladda upp loggar till Movescount</translation>
+    </message>
+    <message>
+        <source>Email (Movescount account)</source>
+        <translation>E-post (till ditt Movescount-konto)</translation>
+    </message>
+</context>
+</TS>
diff -Nur -x debian -x .git -x .pc ./tools/movescountXmlDiff.pl ../openambit.git/tools/movescountXmlDiff.pl
--- ./tools/movescountXmlDiff.pl	2014-09-17 21:24:43.022328657 +0200
+++ ../openambit.git/tools/movescountXmlDiff.pl	2014-11-05 21:53:14.685134642 +0100
@@ -1,157 +1,140 @@
-#!/usr/bin/perl
+#!/usr/bin/perl -w
 
-#use strict;
-#use warnings;
+use strict;
+use warnings;
 
-my $diffText = `diff -w $ARGV[0] $ARGV[1]`;
-
-my @lines = split /\n/, $diffText;
+if ( $#ARGV != 1 ) {
+        die "$0 FILE1 FILE2\n";
+}
 
 my @records;
-my $currentRecordLine;
-my $currentRecordRemoveLines;
-my $currentRecordAddLines;
-my $currentRecordStarted = 0;
-
-foreach my $line (@lines) {
-    if ($line =~ m/[0-9,\-]+[c|d|a][0-9,\-]+/g) {
-        if ($currentRecordStarted == 1) {
-            my %currentRecord = ( "LinesText" => $currentRecordLine,
-                                  "RemoveLines" => $currentRecordRemoveLines,
-                                  "AddLines" => $currentRecordAddLines
-                );
-            push(@records, \%currentRecord);
-        }
-        $currentRecordLine = $line;
-        $currentRecordRemoveLines = [];
-        $currentRecordAddLines = [];
-        $currentRecordStarted = 1;
-    }
-    elsif ($line =~ m/^</g) {
-        push(@{$currentRecordRemoveLines}, $line);
-    }
-    elsif ($line =~ m/^>/g) {
-        push(@{$currentRecordAddLines}, $line);
-    }
+{
+        my @lines = `diff -w $ARGV[0] $ARGV[1]`;
+        chomp @lines;
+        my $currentRecordLine;
+        my $currentRecordRemoveLines;
+        my $currentRecordAddLines;
+        my $currentRecordStarted = 0;
+
+        foreach (@lines) {
+                if ( m/[0-9,\-]+[c|d|a][0-9,\-]+/g) {
+                        if ( $currentRecordStarted ) {
+                                push @records, { 'LinesText' => $currentRecordLine, 'RemoveLines' => $currentRecordRemoveLines, 'AddLines' => $currentRecordAddLines, };
+                        }
+                        $currentRecordLine = $_;
+                        $currentRecordRemoveLines = [];
+                        $currentRecordAddLines = [];
+                        $currentRecordStarted = 1;
+                } elsif ( m/^</g) {
+                        push(@{$currentRecordRemoveLines}, $_);
+                } elsif ( m/^>/g) {
+                        push(@{$currentRecordAddLines}, $_);
+                }
+        }
 }
 
-foreach my $entry (@records) {
+my @matchRemove;
+my @matchAdd;
+my $Epsilon = 0.00000000000005;
+foreach (@records) {
     my $printDiff = 1;
 
-    if (scalar @{$entry->{"RemoveLines"}} == scalar @{$entry->{"AddLines"}}) {
-        my $diffFound = scalar @{$entry->{"RemoveLines"}};
-        for ($i = 0; $i < scalar @{$entry->{"RemoveLines"}}; $i++) {
-            if ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<HR>([0-9\.]+)<\/HR>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<HR>([0-9\.]+)<\/HR>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+    if (scalar @{$_->{"RemoveLines"}} == scalar @{$_->{"AddLines"}}) {
+        my $diffFound = scalar @{$_->{"RemoveLines"}};
+        for (my $i = 0; $i < scalar @{$_->{"RemoveLines"}}; $i++) {
+            if ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<HR>([0-9\.]+)<\/HR>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<HR>([0-9\.]+)<\/HR>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Latitude>([\-0-9\.]+)<\/Latitude>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Latitude>([\-0-9\.]+)<\/Latitude>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.000000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.000000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Latitude>([\-0-9\.]+)<\/Latitude>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Latitude>([\-0-9\.]+)<\/Latitude>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Longitude>([\-0-9\.]+)<\/Longitude>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Longitude>([\-0-9\.]+)<\/Longitude>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.000000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.000000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Longitude>([\-0-9\.]+)<\/Longitude>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Longitude>([\-0-9\.]+)<\/Longitude>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Speed>([0-9\.]+)<\/Speed>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Speed>([0-9\.]+)<\/Speed>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Speed>([0-9\.]+)<\/Speed>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Speed>([0-9\.]+)<\/Speed>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<VerticalSpeed>([\-0-9\.]+)<\/VerticalSpeed>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<VerticalSpeed>([\-0-9\.]+)<\/VerticalSpeed>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<VerticalSpeed>([\-0-9\.]+)<\/VerticalSpeed>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<VerticalSpeed>([\-0-9\.]+)<\/VerticalSpeed>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<GPSHeading>([\-0-9\.]+)<\/GPSHeading>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<GPSHeading>([\-0-9\.]+)<\/GPSHeading>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<GPSHeading>([\-0-9\.]+)<\/GPSHeading>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<GPSHeading>([\-0-9\.]+)<\/GPSHeading>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<GPSSpeed>([0-9\.]+)<\/GPSSpeed>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<GPSSpeed>([0-9\.]+)<\/GPSSpeed>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<GPSSpeed>([0-9\.]+)<\/GPSSpeed>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<GPSSpeed>([0-9\.]+)<\/GPSSpeed>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<GPSAltitude>([0-9\.]+)<\/GPSAltitude>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<GPSAltitude>([0-9\.]+)<\/GPSAltitude>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<GPSAltitude>([0-9\.]+)<\/GPSAltitude>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<GPSAltitude>([0-9\.]+)<\/GPSAltitude>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<EHPE>([0-9\.]+)<\/EHPE>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<EHPE>([0-9\.]+)<\/EHPE>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<EHPE>([0-9\.]+)<\/EHPE>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<EHPE>([0-9\.]+)<\/EHPE>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Duration>([0-9\.]+)<\/Duration>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Duration>([0-9\.]+)<\/Duration>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Duration>([0-9\.]+)<\/Duration>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Duration>([0-9\.]+)<\/Duration>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Time>([0-9\.]+)<\/Time>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Time>([0-9\.]+)<\/Time>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Time>([0-9\.]+)<\/Time>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Time>([0-9\.]+)<\/Time>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<EnergyConsumption>([0-9\.]+)<\/EnergyConsumption>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<EnergyConsumption>([0-9\.]+)<\/EnergyConsumption>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<EnergyConsumption>([0-9\.]+)<\/EnergyConsumption>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<EnergyConsumption>([0-9\.]+)<\/EnergyConsumption>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<PeakTrainingEffect>([0-9\.]+)<\/PeakTrainingEffect>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<PeakTrainingEffect>([0-9\.]+)<\/PeakTrainingEffect>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<PeakTrainingEffect>([0-9\.]+)<\/PeakTrainingEffect>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<PeakTrainingEffect>([0-9\.]+)<\/PeakTrainingEffect>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<BatteryCharge>([0-9\.]+)<\/BatteryCharge>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<BatteryCharge>([0-9\.]+)<\/BatteryCharge>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<BatteryCharge>([0-9\.]+)<\/BatteryCharge>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<BatteryCharge>([0-9\.]+)<\/BatteryCharge>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<BatteryChargeAtStart>([0-9\.]+)<\/BatteryChargeAtStart>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<BatteryChargeAtStart>([0-9\.]+)<\/BatteryChargeAtStart>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<BatteryChargeAtStart>([0-9\.]+)<\/BatteryChargeAtStart>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<BatteryChargeAtStart>([0-9\.]+)<\/BatteryChargeAtStart>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Avg>([0-9\.]+)<\/Avg>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Avg>([0-9\.]+)<\/Avg>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Avg>([0-9\.]+)<\/Avg>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Avg>([0-9\.]+)<\/Avg>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<Max>([0-9\.]+)<\/Max>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<Max>([0-9\.]+)<\/Max>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.00000000000005 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.00000000000005) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<Max>([0-9\.]+)<\/Max>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<Max>([0-9\.]+)<\/Max>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  $Epsilon ) {
                     $diffFound--;
                 }
             }
-            #elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2})Z<\/UTC>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2})Z<\/UTC>/g))) {
-            #    if ((@matchRemove[0] - @matchAdd[0]) <= 1 &&
-            #        (@matchRemove[0] - @matchAdd[0]) >= -1) {
+            #elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2})Z<\/UTC>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2})Z<\/UTC>/g))) {
+            #    if (($matchRemove[0] - $matchAdd[0]) <= 1 &&
+            #        ($matchRemove[0] - $matchAdd[0]) >= -1) {
             #        $diffFound--;
             #    }
             #}
-            elsif ((@matchRemove = (@{$entry->{"RemoveLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2}\.[0-9]{3})Z<\/UTC>/g)) && (@matchAdd = (@{$entry->{"AddLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2}\.[0-9]{3})Z<\/UTC>/g))) {
-                if ((@matchRemove[0] - @matchAdd[0]) < 0.002 &&
-                    (@matchRemove[0] - @matchAdd[0]) > -0.002) {
+            elsif ((@matchRemove = (@{$_->{"RemoveLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2}\.[0-9]{3})Z<\/UTC>/g)) && (@matchAdd = (@{$_->{"AddLines"}}[$i] =~ m/<UTC>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:([0-9]{2}\.[0-9]{3})Z<\/UTC>/g))) {
+		if ( abs(($matchRemove[0] - $matchAdd[0])) <  0.002 ) {
                     $diffFound--;
                 }
             }
@@ -162,14 +145,14 @@
     }
 
     if ($printDiff == 1) {
-        print $entry->{"LinesText"}, "\n";
-        foreach my $remLine (@{$entry->{"RemoveLines"}}) {
+        print $_->{"LinesText"}, "\n";
+        foreach my $remLine (@{$_->{"RemoveLines"}}) {
             print $remLine, "\n";
         }
-        if (scalar @{$entry->{"RemoveLines"}} > 0 &&  scalar @{$entry->{"AddLines"}} > 0) {
+        if (scalar @{$_->{"RemoveLines"}} > 0 &&  scalar @{$_->{"AddLines"}} > 0) {
             print "---\n";
         }
-        foreach my $remLine (@{$entry->{"AddLines"}}) {
+        foreach my $remLine (@{$_->{"AddLines"}}) {
             print $remLine, "\n";
         }
     }
diff -Nur -x debian -x .git -x .pc ./wireshark_dissector/ambit-dissector.c ../openambit.git/wireshark_dissector/ambit-dissector.c
--- ./wireshark_dissector/ambit-dissector.c	2014-09-17 21:28:00.568501253 +0200
+++ ../openambit.git/wireshark_dissector/ambit-dissector.c	2014-11-05 21:53:14.705135065 +0100
@@ -61,6 +61,10 @@
 static gint dissect_ambit_lock_status_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
 static gint dissect_ambit_lock_set(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
 static gint dissect_ambit_lock_set_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
+static gint dissect_ambit_gps_data_peek_get(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
+static gint dissect_ambit_gps_data_peek_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
+static gint dissect_ambit_data_write(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
+static gint dissect_ambit_data_write_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
 
 static gint dissect_ambit3_settings_get(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
 static gint dissect_ambit3_settings_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_);
@@ -151,6 +155,7 @@
 static int hf_ambit_log_header_energy = -1;
 static int hf_ambit_log_header_cadence_max = -1;
 static int hf_ambit_log_header_cadence_avg = -1;
+static int hf_ambit_log_header_swimming_lengths = -1;
 static int hf_ambit_log_header_speed_max_time = -1;
 static int hf_ambit_log_header_alt_max_time = -1;
 static int hf_ambit_log_header_alt_min_time = -1;
@@ -159,6 +164,7 @@
 static int hf_ambit_log_header_temp_max_time = -1;
 static int hf_ambit_log_header_temp_min_time = -1;
 static int hf_ambit_log_header_cadence_max_time = -1;
+static int hf_ambit_log_header_swimming_pool_length = -1;
 static int hf_ambit_log_header_time_first_fix = -1;
 static int hf_ambit_log_header_battery_start = -1;
 static int hf_ambit_log_header_battery_stop = -1;
@@ -238,8 +244,25 @@
 static int hf_ambit_log_altitude_source_altitude_offset = -1;
 static int hf_ambit_log_altitude_source_pressure_offset = -1;
 
+static int hf_ambit_log_cadence_source_type = -1;
+
+static int hf_ambit_log_fwinfo_build_date = -1;
+
+static int hf_ambit_log_swimming_turn_distance = -1;
+static int hf_ambit_log_swimming_turn_lengths = -1;
+static int hf_ambit_log_swimming_turn_lengths_wo_change = -1;
+static int hf_ambit_log_swimming_turn_classification0 = -1;
+static int hf_ambit_log_swimming_turn_classification1 = -1;
+static int hf_ambit_log_swimming_turn_classification2 = -1;
+static int hf_ambit_log_swimming_turn_classification3 = -1;
+static int hf_ambit_log_swimming_turn_prev_style = -1;
+
+static int hf_ambit_log_delayed_store = -1;
+
 static int hf_ambit_log_ibi = -1;
 
+static int hf_ambit_gps_data_head = -1;
+
 static gint ett_ambit = -1;
 static gint ett_ambit_data = -1;
 static gint ett_ambit_log_data = -1;
@@ -296,8 +319,12 @@
 };
 
 static const value_string log_samples_distance_source_type_vals[] = {
+    { 0x00, "Bikepod" },
+    { 0x01, "Footpod" },
     { 0x02, "GPS" },
     { 0x03, "Wrist" },
+    { 0x04, "Indoorswimming" },
+    { 0x05, "Outdoorswimming" },
     { 0, NULL }
 };
 
@@ -306,6 +333,21 @@
     { 0, NULL }
 };
 
+static const value_string log_samples_cadence_source_type_vals[] = {
+    { 0x40, "Wrist" },
+    { 0, NULL }
+};
+
+static const value_string log_samples_swimming_style_vals[] = {
+    { 0x00, "Other" },
+    { 0x01, "Butterfly" },
+    { 0x02, "Backstroke" },
+    { 0x03, "Breaststroke" },
+    { 0x04, "Freestyle" },
+    { 0x05, "Drill" },
+    { 0, NULL }
+};
+
 static const ambit_protocol_type_t subdissectors[] = {
     { 0x03000500, "Set time", dissect_ambit_time_write },
     { 0x03000a00, "Time reply", dissect_ambit_time_reply },
@@ -329,6 +371,10 @@
     { 0x0b0a0a00, "Log header step reply", dissect_ambit_log_header_step_reply },
     { 0x0b0b0500, "Get log header", dissect_ambit_log_header_get },
     { 0x0b0b0a00, "Log header reply", dissect_ambit_log_header_reply },
+    { 0x0b150500, "GPS data peek request", dissect_ambit_gps_data_peek_get },
+    { 0x0b150a00, "GPS data peek reply", dissect_ambit_gps_data_peek_reply },
+    { 0x0b160500, "Data write", dissect_ambit_data_write },
+    { 0x0b160a00, "Data write reply", dissect_ambit_data_write_reply },
     { 0x0b170500, "Get log data", dissect_ambit_log_data_get },
     { 0x0b170a00, "Log data reply", dissect_ambit_log_data_reply },
     { 0x0b190500, "Get lock status", dissect_ambit_lock_status_get },
@@ -363,7 +409,11 @@
 {
     proto_item *unknown_item = NULL;
     unknown_item = proto_tree_add_item(tree, hf_ambit_unknown, tvb, offset, len, ENC_LITTLE_ENDIAN);
+#if VERSION_MAJOR >= 1 && VERSION_MINOR >= 11
+    /* TODO port to new expert info API */
+#else
     expert_add_info_format(pinfo, unknown_item, PI_UNDECODED, PI_WARN, "Not dissected yet");
+#endif
 }
 
 static gint dissect_ambit_date_write(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
@@ -640,8 +690,10 @@
         offset += 1;
         proto_tree_add_item(tree, hf_ambit_log_header_cadence_avg, tvb, offset, 1, ENC_LITTLE_ENDIAN);
         offset += 1;
-        dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 4);
-        offset += 4;
+        dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 2);
+        offset += 2;
+        proto_tree_add_item(tree, hf_ambit_log_header_swimming_lengths, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+        offset += 2;
         proto_tree_add_item(tree, hf_ambit_log_header_speed_max_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
         offset += 4;
         proto_tree_add_item(tree, hf_ambit_log_header_alt_max_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
@@ -658,7 +710,7 @@
         offset += 4;
         proto_tree_add_item(tree, hf_ambit_log_header_cadence_max_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
         offset += 4;
-        dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 4);
+        proto_tree_add_item(tree, hf_ambit_log_header_swimming_pool_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);
         offset += 4;
         proto_tree_add_item(tree, hf_ambit_log_header_time_first_fix, tvb, offset, 2, ENC_LITTLE_ENDIAN);
         offset += 2;
@@ -958,9 +1010,12 @@
     if (offset + 1 >= length) return offset;
     proto_tree_add_item(tree, hf_ambit_log_header_cadence_avg, tvb, offset, 1, ENC_LITTLE_ENDIAN);
     offset += 1;
-    if (offset + 4 >= length) return offset;
-    dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 4);
-    offset += 4;
+    if (offset + 2 >= length) return offset;
+    dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 2);
+    offset += 2;
+    if (offset + 2 >= length) return offset;
+    proto_tree_add_item(tree, hf_ambit_log_header_swimming_lengths, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+    offset += 2;
     if (offset + 4 >= length) return offset;
     proto_tree_add_item(tree, hf_ambit_log_header_speed_max_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
     offset += 4;
@@ -986,7 +1041,7 @@
     proto_tree_add_item(tree, hf_ambit_log_header_cadence_max_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);
     offset += 4;
     if (offset + 4 >= length) return offset;
-    dissect_ambit_add_unknown(tvb, pinfo, tree, offset, 4);
+    proto_tree_add_item(tree, hf_ambit_log_header_swimming_pool_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);
     offset += 4;
     if (offset + 2 >= length) return offset;
     proto_tree_add_item(tree, hf_ambit_log_header_time_first_fix, tvb, offset, 2, ENC_LITTLE_ENDIAN);
@@ -1448,6 +1503,64 @@
                 dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, sample_len - 9);
             }
             break;
+          case 0x14:
+            sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Swimming turn)", (*sampleno)++);
+            sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_time_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 1);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_delayed_store, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 1);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_distance, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_lengths, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 4);
+            offset += 4;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 2);
+            offset += 2;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 8);
+            offset += 8;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_lengths_wo_change, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_classification0, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_classification1, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_classification2, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_classification3, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_prev_style, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, 1);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_swimming_turn_distance, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            break;
+          case 0x15:
+            sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Swimming stroke)", (*sampleno)++);
+            sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_time_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_delayed_store, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            break;
           case 0x18:
             sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Activity)", (*sampleno)++);
             sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
@@ -1467,6 +1580,23 @@
                 dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, sample_len - 12);
             }
             break;
+          case 0x1a:
+            sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Cadence source)", (*sampleno)++);
+            sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_time_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_cadence_source_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            if (offset < sample_len - 2) {
+                dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, sample_len - 7);
+            }
+            break;
           case 0x1b:
             sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (lat-long)", (*sampleno)++);
             sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
@@ -1490,6 +1620,35 @@
                 dissect_ambit_add_unknown(tvb, pinfo, sample_tree, offset, sample_len - 14);
             }
             break;
+          case 0x1c:
+            sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Firmware info)", (*sampleno)++);
+            sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+            offset += 2;
+            proto_tree_add_item(sample_tree, hf_ambit_log_sample_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_time_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+            offset += 4;
+            proto_tree_add_item(sample_tree, hf_ambit_log_other_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+            offset += 1;
+            {
+                guint8 fw1,fw2;
+                guint16 fw3;
+                fw1 = tvb_get_guint8(tvb, offset);
+                fw2 = tvb_get_guint8(tvb, offset+1);
+                fw3 = tvb_get_letohs(tvb, offset+2);
+                proto_tree_add_string_format_value(sample_tree, hf_ambit_fw_version, tvb, offset, 4, "FW version", "%d.%d.%d", fw1, fw2, fw3);
+                offset += 4;
+                guint16 year = tvb_get_letohs(tvb, offset);
+                guint8 month = tvb_get_guint8(tvb, offset + 2);
+                guint8 day = tvb_get_guint8(tvb, offset + 3);
+                guint8 hour = tvb_get_guint8(tvb, offset + 4);
+                guint8 minute = tvb_get_guint8(tvb, offset + 5);
+                guint16 seconds = tvb_get_letohs(tvb, offset + 6);
+                proto_tree_add_string_format_value(sample_tree, hf_ambit_log_fwinfo_build_date, tvb, offset, 8, "Builddate", "%04d-%02d-%02d %02d:%02d:%2.3f", year, month, day, hour, minute, ((float)seconds/1000.0));
+                offset += 8;
+            }
+            break;
           default:
             sample_ti = proto_tree_add_text(tree, tvb, offset, sample_len + 2, "Sample #%u (Unknown)", (*sampleno)++);
             sample_tree = proto_item_add_subtree(sample_ti, ett_ambit_log_sample);
@@ -1528,6 +1687,29 @@
 {
 }
 
+static gint dissect_ambit_gps_data_peek_get(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
+{
+}
+
+static gint dissect_ambit_gps_data_peek_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
+{
+    proto_tree_add_item(tree, hf_ambit_gps_data_head, tvb, 0, 9, ENC_LITTLE_ENDIAN);
+}
+
+static gint dissect_ambit_data_write(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
+{
+    guint32 length = tvb_get_letohl(tvb, 4);
+
+    proto_tree_add_item(tree, hf_ambit_log_data_address, tvb, 0, 4, ENC_LITTLE_ENDIAN);
+    proto_tree_add_item(tree, hf_ambit_log_data_length, tvb, 4, 4, ENC_LITTLE_ENDIAN);
+
+    proto_tree_add_text(tree, tvb, 8, length, "Payload");
+}
+
+static gint dissect_ambit_data_write_reply(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
+{
+}
+
 static gint dissect_ambit3_settings_get(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
 {
 }
@@ -2114,6 +2296,8 @@
           { "Cadence max (rpm)", "ambit.log_header.cadence_max", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_cadence_avg,
           { "Cadence avg (rpm)", "ambit.log_header.cadence_avg", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_header_swimming_lengths,
+          { "Swimming pool lengths", "ambit.log_header.swimming_lengths", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_speed_max_time,
           { "Time max speed (ms)", "ambit.log_header.speed_maxtime", FT_UINT32, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_alt_max_time,
@@ -2130,6 +2314,8 @@
           { "Time min temperature (ms)", "ambit.log_header.temp_mintime", FT_UINT32, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_cadence_max_time,
           { "Time max cadence (ms)", "ambit.log_header.cadence_maxtime", FT_UINT32, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_header_swimming_pool_length,
+          { "Swimming pool length (m)", "ambit.log_header.swimming_pool_length", FT_UINT32, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_time_first_fix,
           { "Time of first fix", "ambit.log_header.time_first_fix", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_header_battery_start,
@@ -2277,9 +2463,37 @@
           { "Altitude offset", "ambit.log_sample.altitude_source.alt_offset", FT_INT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
         { &hf_ambit_log_altitude_source_pressure_offset,
           { "Pressure", "ambit.log_sample.altitude_source.pres_offset", FT_INT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_cadence_source_type,
+          { "Type", "ambit.log_sample.cadence_source.type", FT_UINT8, BASE_HEX, VALS(log_samples_cadence_source_type_vals), 0x0,NULL, HFILL } },
+
+        { &hf_ambit_log_fwinfo_build_date,
+          { "Build date", "ambit.log_sample.fwinfo.builddate", FT_STRING, BASE_NONE, NULL, 0x0,NULL, HFILL } },
+
+        { &hf_ambit_log_swimming_turn_distance,
+          { "Distance (cm)", "ambit.log_sample.swimming_turn.distance", FT_UINT32, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_lengths,
+          { "Total pool lengths", "ambit.log_sample.swimming_turn.lengths", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_lengths_wo_change,
+          { "Total pool lengths w/o style change(!?)", "ambit.log_sample.swimming_turn.lengths_wo_change", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_prev_style,
+          { "Style", "ambit.log_sample.swimming_turn.style", FT_UINT8, BASE_HEX, VALS(log_samples_swimming_style_vals), 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_classification0,
+          { "ClassificationVector[0]", "ambit.log_sample.swimming_turn.classification0", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_classification1,
+          { "ClassificationVector[1]", "ambit.log_sample.swimming_turn.classification1", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_classification2,
+          { "ClassificationVector[2]", "ambit.log_sample.swimming_turn.classification2", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+        { &hf_ambit_log_swimming_turn_classification3,
+          { "ClassificationVector[3]", "ambit.log_sample.swimming_turn.classification3", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+
+        { &hf_ambit_log_delayed_store,
+          { "Log write delay (1/10 s)", "ambit.log_sample.delayed_store", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
 
         { &hf_ambit_log_ibi,
           { "IBI entry", "ambit.log_sample.ibi", FT_UINT16, BASE_DEC, NULL, 0x0,NULL, HFILL } },
+
+        { &hf_ambit_gps_data_head,
+          { "Current GPS position data version", "ambit.gps.data.head", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } },
     };
 
     static gint *ett[] = {
diff -Nur -x debian -x .git -x .pc ./wireshark_dissector/cmake/FindWireshark.cmake ../openambit.git/wireshark_dissector/cmake/FindWireshark.cmake
--- ./wireshark_dissector/cmake/FindWireshark.cmake	2014-09-17 21:24:43.026328591 +0200
+++ ../openambit.git/wireshark_dissector/cmake/FindWireshark.cmake	2014-11-05 21:53:14.721135398 +0100
@@ -16,7 +16,7 @@
 # wireshark does not install its library with pkg-config information,
 # so we need to manually find the libraries and headers
 
-FIND_PATH( WIRESHARK_INCLUDE_DIRS epan/column_info.h PATH_SUFFIXES wireshark )
+FIND_PATH( WIRESHARK_INCLUDE_DIRS epan/packet.h PATH_SUFFIXES wireshark )
 FIND_LIBRARY( WIRESHARK_LIBRARIES wireshark PATH_SUFFIXES wireshark )
 
 # Report results
