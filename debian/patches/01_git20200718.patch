diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./build.sh ../openambit.git/build.sh
--- ./build.sh	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/build.sh	2020-07-18 10:07:31.040357883 +0200
@@ -1,6 +1,6 @@
-#!/bin/bash -eu
+#!/bin/bash
 
-set -e
+set -eu
 
 SOURCE_LOCATION="`dirname \"$0\"`"
 SOURCE_LOCATION="`( cd \"${SOURCE_LOCATION}\" && pwd )`"
@@ -10,7 +10,7 @@
    CORES=$(cat /proc/cpuinfo | grep processor | wc -l)
 fi
 
-for target in libambit movescount openambit
+for target in libambit movescount openambit openambit-cli
 do
     cd ${SOURCE_LOCATION}
     echo "------building $target------"
@@ -24,7 +24,7 @@
     fi
 done
 
-if [ "${BUILD_EXTRAS}" == "1" ]; then
+if [ "${BUILD_EXTRAS:-0}" == "1" ]; then
     cd ${SOURCE_LOCATION}
     echo "------building example------"
     mkdir -p example-build
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./CMakeLists.txt ../openambit.git/CMakeLists.txt
--- ./CMakeLists.txt	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/CMakeLists.txt	2020-07-18 10:07:31.036357663 +0200
@@ -27,13 +27,16 @@
 add_subdirectory(src/libambit)
 add_subdirectory(src/movescount)
 add_subdirectory(src/openambit)
+add_subdirectory(src/openambit-cli)
 
 if (NOT ${LIBAMBIT_FOUND})
   add_dependencies(movescount ambit)
   add_dependencies(openambit ambit)
+  add_dependencies(openambit-cli ambit)
 endif ()
 if (NOT ${MOVESCOUNT_FOUND})
   add_dependencies(openambit movescount)
+  add_dependencies(openambit-cli movescount)
 endif ()
 
 if (BUILD_EXTRAS)
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./install.sh ../openambit.git/install.sh
--- ./install.sh	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/install.sh	2020-03-26 18:05:02.316809718 +0100
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-set -e
+set -eu
 
 export DO_INSTALL=1
 
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./README.rst ../openambit.git/README.rst
--- ./README.rst	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/README.rst	2020-04-28 11:57:34.523767072 +0200
@@ -172,6 +172,17 @@
 link there pointing to the build result so your next ``wireshark`` run
 will use the latest and greatest(?) version.
 
+Device setup
+------------
+
+In order to allow access to the device, you may need to do the following.
+
+.. code-block:: sh
+
+    sudo cp ./src/libambit/libambit.rules /etc/udev/rules.d/
+    sudo udevadm control --reload-rules && udevadm trigger
+
+This configures access to the device via udev.
 
 .. _Movescount: http://www.movescount.com/
 .. _Moveslink2: http://www.movescount.com/connect/moveslink/Suunto_Ambit
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./run.sh ../openambit.git/run.sh
--- ./run.sh	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/run.sh	2020-07-18 10:07:31.040357883 +0200
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-set -e
+set -eu
 
 SOURCE_LOCATION="`dirname \"$0\"`"
 SOURCE_LOCATION="`( cd \"${SOURCE_LOCATION}\" && pwd )`"
@@ -8,13 +8,17 @@
 cd ${SOURCE_LOCATION}
 
 application=openambit
-if test -n "$1"; then
-     application=$1
-     shift
+
+if [ $# -gt 0 ];then
+    echo running $1
+    application=$1
+    shift
 fi
+
 case "$application" in
     openambit)          builddir=${application}-build;;
     ambitconsole)       builddir=example-build;;
+    openambit-cli)      builddir=${application}-build;;
     *)
 	echo "$application: not supported" >&2
 	exit 1
@@ -22,4 +26,4 @@
 esac
 
 echo "------running $application------"
-LD_LIBRARY_PATH=./libambit-build ./${builddir}/${application}
+LD_LIBRARY_PATH=./libambit-build ./${builddir}/${application} "$@"
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/libambit/CMakeLists.txt ../openambit.git/src/libambit/CMakeLists.txt
--- ./src/libambit/CMakeLists.txt	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/src/libambit/CMakeLists.txt	2020-03-14 09:46:08.331760537 +0100
@@ -47,7 +47,7 @@
   m
 )
 
-set_target_properties(ambit PROPERTIES VERSION 0.4.0 SOVERSION 0)
+set_target_properties(ambit PROPERTIES VERSION 0.5.0 SOVERSION 0)
 
 include_directories(
   ${HIDAPI_INCLUDE_DIR}
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/libambit/device_driver_ambit_navigation.h ../openambit.git/src/libambit/device_driver_ambit_navigation.h
--- ./src/libambit/device_driver_ambit_navigation.h	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/src/libambit/device_driver_ambit_navigation.h	2020-02-19 17:44:32.641370463 +0100
@@ -115,8 +115,8 @@
 #define NUM_WAYPOINTS_MOVESCOUNT 34
 #define NUM_WAYPOINTS_AMBIT 18
 
-const uint8_t ambit_waypoint_types_from_movescount[NUM_WAYPOINTS_MOVESCOUNT];
-const uint8_t ambit_waypoint_types_to_movescount[NUM_WAYPOINTS_AMBIT];
+extern const uint8_t ambit_waypoint_types_from_movescount[NUM_WAYPOINTS_MOVESCOUNT];
+extern const uint8_t ambit_waypoint_types_to_movescount[NUM_WAYPOINTS_AMBIT];
 
 int ambit_navigation_read(ambit_object_t *object, ambit_personal_settings_t *settings);
 int ambit_navigation_write(ambit_object_t *object, ambit_personal_settings_t *settings);
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/libambit/pmem20.c ../openambit.git/src/libambit/pmem20.c
--- ./src/libambit/pmem20.c	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/src/libambit/pmem20.c	2020-03-27 08:05:56.909522084 +0100
@@ -1162,12 +1162,11 @@
     outtime->minute = tm->tm_min;
     outtime->hour = tm->tm_hour;
     outtime->day = tm->tm_mday;
-    outtime->month = tm->tm_mon;
-    outtime->year = tm->tm_year;
+    outtime->month = tm->tm_mon + 1;
+    outtime->year = tm->tm_year + 1900;
 }
 
 static int is_leap(unsigned int y) {
-    y += 1900;
     return (y % 4) == 0 && ((y % 100) != 0 || (y % 400) == 0);
 }
 
@@ -1180,11 +1179,11 @@
     timeval->tv_usec = 0;
     int i;
 
-    for (i = 70; i < ambit_time->year; ++i) {
+    for (i = 1970; i < ambit_time->year; ++i) {
         timeval->tv_sec += is_leap(i) ? 366 : 365;
     }
 
-    for (i = 0; i < ambit_time->month; ++i) {
+    for (i = 0; i < ambit_time->month-1; ++i) {
         timeval->tv_sec += ndays[is_leap(ambit_time->year)][i];
     }
     timeval->tv_sec += ambit_time->day - 1;
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/movescount/logentry.cpp ../openambit.git/src/movescount/logentry.cpp
--- ./src/movescount/logentry.cpp	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/src/movescount/logentry.cpp	2020-03-06 12:44:08.070362528 +0100
@@ -19,6 +19,7 @@
  * Contributors:
  *
  */
+#include <libambit.h>
 #include "logentry.h"
 
 LogEntry::LogEntry() :
@@ -29,8 +30,6 @@
 
 LogEntry::LogEntry(const LogEntry &other)
 {
-    u_int32_t i;
-
     device = other.device;
     time = other.time;
     movescountId = other.movescountId;
@@ -39,6 +38,26 @@
     if (other.personalSettings != NULL) {
         personalSettings = (ambit_personal_settings_t*)malloc(sizeof(ambit_personal_settings_t));
         memcpy(personalSettings, other.personalSettings, sizeof(ambit_personal_settings_t));
+
+        // need to copy waypoints and routes to avoid re-using the same memory
+        if(other.personalSettings->waypoints.data != NULL) {
+            personalSettings->waypoints.count = 0;
+            libambit_waypoint_append(personalSettings, other.personalSettings->waypoints.data,
+                                     other.personalSettings->waypoints.count);
+        }
+        if(other.personalSettings->routes.data != NULL) {
+            ambit_route_t *routes = libambit_route_alloc(other.personalSettings->routes.count);
+            personalSettings->routes.data = routes;
+            personalSettings->routes.count = other.personalSettings->routes.count;
+            for(int r = 0; r < personalSettings->routes.count; r++) {
+                ambit_route_t *route = &personalSettings->routes.data[r];
+                ambit_route_t *otherRoute = &other.personalSettings->routes.data[r];
+                memcpy(route, otherRoute, sizeof(ambit_route_t));
+
+                route->points = (ambit_routepoint_t *) malloc(sizeof(ambit_routepoint_t) * otherRoute->points_count);
+                memcpy(route->points, otherRoute->points, sizeof(ambit_routepoint_t) * otherRoute->points_count);
+            }
+        }
     }
     else {
         personalSettings = NULL;
@@ -53,7 +72,7 @@
         if (other.logEntry->samples != NULL) {
             logEntry->samples = (ambit_log_sample_t*)malloc(sizeof(ambit_log_sample_t)*other.logEntry->samples_count);
             memcpy(logEntry->samples, other.logEntry->samples, sizeof(ambit_log_sample_t)*other.logEntry->samples_count);
-            for (i=0; i<other.logEntry->samples_count; i++) {
+            for (unsigned int i=0; i<other.logEntry->samples_count; i++) {
                 if (other.logEntry->samples[i].type == ambit_log_sample_type_periodic) {
                     if (other.logEntry->samples[i].u.periodic.values != NULL) {
                         logEntry->samples[i].u.periodic.values = (ambit_log_sample_periodic_value_t*)malloc(sizeof(ambit_log_sample_periodic_value_t)*other.logEntry->samples[i].u.periodic.value_count);
@@ -94,7 +113,7 @@
 LogEntry::~LogEntry()
 {
     if (personalSettings != NULL) {
-        free(personalSettings);
+        libambit_personal_settings_free(personalSettings);
         personalSettings = NULL;
     }
 
@@ -103,9 +122,7 @@
     logEntry = NULL;
 }
 
-bool LogEntry::isUploaded(){
-    if (this->movescountId == NULL){
-        return false;
-    }
-    return true;
+bool LogEntry::isUploaded()
+{
+    return this->movescountId != NULL;
 }
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/openambit/CMakeLists.txt ../openambit.git/src/openambit/CMakeLists.txt
--- ./src/openambit/CMakeLists.txt	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/src/openambit/CMakeLists.txt	2019-12-30 13:33:08.350774537 +0100
@@ -1,7 +1,7 @@
 cmake_minimum_required(VERSION 2.8.5)
 project (OPENAMBIT CXX)
 
-set (OPENAMBIT_VERSION 0.4)
+set (OPENAMBIT_VERSION 0.5)
 
 # Where to lookup modules
 set(CMAKE_MODULE_PATH "${OPENAMBIT_SOURCE_DIR}/cmake")
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/openambit-cli/cmake/Findlibambit.cmake ../openambit.git/src/openambit-cli/cmake/Findlibambit.cmake
--- ./src/openambit-cli/cmake/Findlibambit.cmake	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit-cli/cmake/Findlibambit.cmake	2019-12-30 13:38:36.242913528 +0100
@@ -0,0 +1,29 @@
+# - Find libambit
+# If found, this will define
+#
+# LIBAMBIT_FOUND - system has libambit
+# LIBAMBIT_INCLUDE_DIR - the libambit include directory
+# LIBAMBIT_LIBS - the libambit libraries
+
+find_path(LIBAMBIT_INCLUDE_DIR NAMES libambit.h
+  PATHS ${CMAKE_CURRENT_SOURCE_DIR}/../libambit NO_DEFAULT_PATH
+)
+find_path(LIBAMBIT_INCLUDE_DIR NAMES libambit.h)
+
+find_library(LIBAMBIT_LIBS NAMES ambit
+  PATHS ${CMAKE_CURRENT_BINARY_DIR}/../libambit-build NO_DEFAULT_PATH
+)
+find_library(LIBAMBIT_LIBS NAMES ambit)
+
+if(LIBAMBIT_INCLUDE_DIR AND LIBAMBIT_LIBS)
+  set(LIBAMBIT_FOUND TRUE CACHE INTERNAL "libambit found")
+  message(STATUS "Found libambit: ${LIBAMBIT_INCLUDE_DIR}, ${LIBAMBIT_LIBS}")
+else(LIBAMBIT_INCLUDE_DIR AND LIBAMBIT_LIBS)
+  set(LIBAMBIT_FOUND FALSE CACHE INTERNAL "libambit found")
+  set(LIBAMBIT_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../libambit/)
+  set(LIBAMBIT_LIBS ${CMAKE_CURRENT_BINARY_DIR}/../libambit/libambit.so.0)
+  message(STATUS
+    "libambit not found, building from source in ${LIBAMBIT_INCLUDE_DIR}")
+endif(LIBAMBIT_INCLUDE_DIR AND LIBAMBIT_LIBS)
+
+mark_as_advanced(LIBAMBIT_INCLUDE_DIR LIBAMBIT_LIBS)
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/openambit-cli/cmake/FindMovescount.cmake ../openambit.git/src/openambit-cli/cmake/FindMovescount.cmake
--- ./src/openambit-cli/cmake/FindMovescount.cmake	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit-cli/cmake/FindMovescount.cmake	2019-12-30 13:38:36.242913528 +0100
@@ -0,0 +1,29 @@
+# - Find Movescount
+# If found, this will define
+#
+# MOVESCOUNT_FOUND - system has the movescount library
+# MOVESCOUNT_INCLUDE_DIR - the movescount include directory
+# MOVESCOUNT_LIBS - the movescount libraries
+
+find_path(MOVESCOUNT_INCLUDE_DIR NAMES movescount.h
+  PATHS ${CMAKE_CURRENT_SOURCE_DIR}/../movescount NO_DEFAULT_PATH
+)
+find_path(MOVESCOUNT_INCLUDE_DIR NAMES movescount.h)
+
+find_library(MOVESCOUNT_LIBS NAMES movescount
+  PATHS ${CMAKE_CURRENT_BINARY_DIR}/../movescount-build NO_DEFAULT_PATH
+)
+find_library(MOVESCOUNT_LIBS NAMES movescount)
+
+if(MOVESCOUNT_INCLUDE_DIR AND MOVESCOUNT_LIBS)
+  set(MOVESCOUNT_FOUND TRUE CACHE INTERNAL "Movescount found")
+  message(STATUS "Found Movescount: ${MOVESCOUNT_INCLUDE_DIR}, ${MOVESCOUNT_LIBS}")
+else(MOVESCOUNT_INCLUDE_DIR AND LIBMOVESCOUNT_LIBS)
+  set(MOVESCOUNT_FOUND FALSE CACHE INTERNAL "Movescount found")
+  set(MOVESCOUNT_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../)
+  set(MOVESCOUNT_LIBS ${CMAKE_CURRENT_BINARY_DIR}/../movescount/libmovescount.so.0)
+  message(STATUS
+    "Movescount not found, building from source in ${MOVESCOUNT_INCLUDE_DIR}")
+endif(MOVESCOUNT_INCLUDE_DIR AND MOVESCOUNT_LIBS)
+
+mark_as_advanced(MOVESCOUNT_INCLUDE_DIR MOVESCOUNT_LIBS)
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/openambit-cli/cmake/FindUDev.cmake ../openambit.git/src/openambit-cli/cmake/FindUDev.cmake
--- ./src/openambit-cli/cmake/FindUDev.cmake	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit-cli/cmake/FindUDev.cmake	2019-12-30 13:38:36.242913528 +0100
@@ -0,0 +1,24 @@
+# - Try to find UDev
+# Once done this will define
+#
+# UDEV_FOUND - system has UDev
+# UDEV_INCLUDE_DIR - the libudev include directory
+# UDEV_LIBS - The libudev libraries
+
+# Copyright (c) 2010, Rafael Fernández López, <ereslibre@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+find_path(UDEV_INCLUDE_DIR libudev.h)
+find_library(UDEV_LIBS udev)
+find_path(UDEV_RULES_PATH udev/rules.d
+          PATHS
+          /lib
+          /usr/lib
+)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(UDev DEFAULT_MSG UDEV_INCLUDE_DIR UDEV_LIBS UDEV_RULES_PATH)
+
+mark_as_advanced(UDEV_INCLUDE_DIR UDEV_LIBS UDEV_RULES_PATH)
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/openambit-cli/CMakeLists.txt ../openambit.git/src/openambit-cli/CMakeLists.txt
--- ./src/openambit-cli/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit-cli/CMakeLists.txt	2019-12-30 13:45:24.706615623 +0100
@@ -0,0 +1,42 @@
+cmake_minimum_required(VERSION 2.8.5)
+project (OPENAMBITCLI CXX)
+
+set (OPENAMBIT_VERSION 0.5)
+
+# Where to lookup modules
+set(CMAKE_MODULE_PATH "${OPENAMBITCLI_SOURCE_DIR}/cmake")
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")
+
+find_package(libambit REQUIRED)
+find_package(Movescount REQUIRED)
+find_package(UDev REQUIRED)
+find_package(Qt5Core REQUIRED)
+
+include(GNUInstallDirs)
+
+include_directories(
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  ${CMAKE_CURRENT_BINARY_DIR}
+  ${LIBAMBIT_INCLUDE_DIR}
+  ..
+)
+
+link_directories(
+  ${LIBAMBIT_LIBS_DIR}
+  ${MOVESCOUNT_LIBS_DIR}
+)
+
+set(openambitcli_HDRS Task.h)
+
+set(openambitcli_SRCS main.cpp Task.cpp)
+
+set(CMAKE_AUTOMOC ON)
+
+add_definitions(-DAPP_VERSION="${OPENAMBIT_VERSION}")
+
+add_executable(openambit-cli ${openambitcli_HDRS} ${openambitcli_SRCS})
+
+target_link_libraries(openambit-cli ${LIBAMBIT_LIBS} ${MOVESCOUNT_LIBS} ${UDEV_LIBS} Qt5::Core )
+
+install(TARGETS openambit-cli DESTINATION ${CMAKE_INSTALL_BINDIR})
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/openambit-cli/main.cpp ../openambit.git/src/openambit-cli/main.cpp
--- ./src/openambit-cli/main.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit-cli/main.cpp	2020-07-18 10:07:31.040357883 +0200
@@ -0,0 +1,107 @@
+/*
+ * (C) Copyright 2013 Emil Ljungdahl
+ *
+ * This file is part of Openambit.
+ *
+ * Openambit is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contributors:
+ *
+ */
+#include <QString>
+#include <QtCore/QCoreApplication>
+#include <QtCore/QCommandLineParser>
+#include "Task.h"
+
+int main(int argc, char *argv[]) {
+    // Set application settings
+    QCoreApplication::setApplicationVersion(APP_VERSION);
+    QCoreApplication::setOrganizationName("Openambit");
+    QCoreApplication::setApplicationName("Openambit-cli");
+
+    QCoreApplication a(argc, argv);
+
+    QCommandLineParser parser;
+    parser.setApplicationDescription("\nCommandline application to perform sync between the watch and movescount.com.\n"
+                                     "\n"
+                                     "Certain features/syncs can be disabled via commandline options.\n"
+                                     "For syncing to movescount.com you need to provide the username and userkey as used by OpenAmbit GUI\n");
+    parser.addHelpOption();
+    parser.addVersionOption();
+
+    parser.addPositionalArgument("username", QCoreApplication::translate("main", "Username for connecting to Movescount."));
+    parser.addPositionalArgument("userkey", QCoreApplication::translate("main", "User-key for connecting to Movescount."));
+
+    QCommandLineOption noReadLogsOption(QStringList() << "r" << "no-read-logs",
+                                        QCoreApplication::translate("main", "Do not read logs from the watch."));
+    parser.addOption(noReadLogsOption);
+
+    QCommandLineOption noSyncTimeOption(QStringList() << "t" << "no-sync-time",
+                                        QCoreApplication::translate("main", "Do not sync the time on the watch."));
+    parser.addOption(noSyncTimeOption);
+
+    QCommandLineOption noSyncOrbitOption(QStringList() << "o" << "no-sync-orbit",
+                                         QCoreApplication::translate("main", "Do not sync GPS orbits on the watch."));
+    parser.addOption(noSyncOrbitOption);
+
+    QCommandLineOption noSyncSportModeOption(QStringList() << "s" << "no-sync-sport-mode",
+                                             QCoreApplication::translate("main", "Do not sync sport modes to the watch."));
+    parser.addOption(noSyncSportModeOption);
+
+    QCommandLineOption noSyncNavigationOption(QStringList() << "n" << "no-sync-navigation",
+                                             QCoreApplication::translate("main", "Do not sync navigation to the watch."));
+    parser.addOption(noSyncNavigationOption);
+
+    QCommandLineOption customConfigFileOption(QStringList() << "c" << "custom-config",
+                                              QCoreApplication::translate("main", "A custom JSON config file to load configuration for the watch."),
+                                              QCoreApplication::translate("main", "json-file"));
+    parser.addOption(customConfigFileOption);
+
+    // Process the actual command line arguments given by the user
+    parser.process(a);
+
+    const QStringList args = parser.positionalArguments();
+    // source is args.at(0), destination is args.at(1)
+
+    const QString customConfig = parser.value(customConfigFileOption);
+
+    std::string username;
+    if(args.length() >= 1) {
+        username = args.at(0).toStdString();
+    }
+
+    std::string userkey;
+    if(args.length() >= 2) {
+        userkey = args.at(1).toStdString();
+    }
+
+    // make the app parent of the task
+    Task *task = new Task(&a,
+            args.length() < 1 ? NULL : username.c_str(),
+            args.length() < 2 ? NULL : userkey.c_str(),
+            !parser.isSet(noReadLogsOption),
+            !parser.isSet(noSyncTimeOption),
+            !parser.isSet(noSyncOrbitOption),
+            !parser.isSet(noSyncSportModeOption),
+            !parser.isSet(noSyncNavigationOption),
+            customConfig.length() == 0 ? NULL : customConfig.toStdString().c_str());
+
+    // make application stop when the task is done
+    QObject::connect(task, SIGNAL(finished()), &a, SLOT(quit()));
+
+    // This will run the task from the application event loop.
+    QTimer::singleShot(0, task, SLOT(run()));
+
+    return QCoreApplication::exec();
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/openambit-cli/Task.cpp ../openambit.git/src/openambit-cli/Task.cpp
--- ./src/openambit-cli/Task.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit-cli/Task.cpp	2020-07-18 10:07:31.040357883 +0200
@@ -0,0 +1,333 @@
+//
+// Created by dstadler on 19.10.19.
+//
+
+#include "Task.h"
+#include <movescount/movescount.h>
+#include <movescount/logstore.h>
+#include <movescount/movescountxml.h>
+#include <libambit_int.h>
+
+#define APPKEY                 "HpF9f1qV5qrDJ1hY1QK1diThyPsX10Mh4JvCw9xVQSglJNLdcwr3540zFyLzIC3e"
+#define MOVESCOUNT_DEFAULT_URL "https://uiservices.movescount.com/"
+
+MovesCount *movesCountSetup(const char *username, const char *userkey);
+void startSync(ambit_object_t *deviceObject, ambit_personal_settings_t *currentPersonalSettings, MovesCount *movesCount,
+               bool readAllLogs, bool syncTime, bool syncOrbit, bool syncSportMode, bool syncNavigation,
+               const char *settingsInputFile);
+static int log_skip_cb(void *ambit_object, ambit_log_header_t *log_header);
+static void log_data_cb(void *object, ambit_log_entry_t *log_entry);
+
+int readSportModesFromFile(const char *file, ambit_sport_mode_device_settings_t *ambitDeviceSettings);
+
+LogStore logStore;
+MovesCountXML movesCountXML;
+
+typedef struct syncData_s {
+    ambit_object_t *deviceObject;
+    ambit_personal_settings_t *currentPersonalSettings;
+    bool syncMovescount;
+    MovesCount *movesCount;
+} syncData_t;
+
+void Task::run() {
+    printf("Running openambit-cli\n");
+
+    ambit_device_info_t *info = libambit_enumerate();
+    ambit_object_t *ambit_object;
+    ambit_device_status_t status;
+    ambit_personal_settings_t settings;
+    memset(&settings, 0, sizeof(ambit_personal_settings_t));
+
+    if (info) {
+        printf("Device: %s, serial: %s\n", info->name, info->serial);
+        if (0 == info->access_status) {
+            printf("F/W version: %d.%d.%d\n", info->fw_version[0], info->fw_version[1], (info->fw_version[2] << 0) | (info->fw_version[3] << 8));
+            if (!info->is_supported) {
+                printf("Device is not supported yet!\n");
+            }
+        }
+        else {
+            printf("%s: %s\n", info->path, strerror(info->access_status));
+        }
+
+        ambit_object = libambit_new(info);
+        if (ambit_object) {
+
+            if (libambit_device_status_get(ambit_object, &status) == 0) {
+                printf("Current charge: %d%%\n", status.charge);
+            }
+            else {
+                printf("Failed to read status\n");
+            }
+
+            if (libambit_personal_settings_get(ambit_object, &settings) == 0) {
+                printf("Personal settings: \n");
+                printf("sportmode_button_lock: %d\n", settings.sportmode_button_lock);
+                printf("weight: %d\n", settings.weight);
+                printf("birthyear: %d\n", settings.birthyear);
+            }
+            else {
+                printf("Failed to read personal settings\n");
+            }
+
+            if (0 != info->access_status || !info->is_supported) {
+                printf("Device not supported\n");
+            } else {
+                printf("Connecting to movescount\n");
+                MovesCount *movesCount = movesCountSetup(username, userkey);
+                if (movesCount != NULL) {
+                    printf("Connected\n");
+
+                    //connect(movesCount, SIGNAL(movesCountAuth(bool)), this, SLOT(movesCountAuth(bool)), Qt::QueuedConnection);
+
+                    DeviceInfo deviceInfo = DeviceInfo();
+
+                    deviceInfo = *info;
+
+                    movesCount->setDevice(deviceInfo);
+                    //movesCount->getDeviceSettings();
+
+                    printf("Having device: %s/%s/%s/%d.%d.%d/%d.%d.%d/%d/%d\n",
+                           deviceInfo.name.toStdString().c_str(),
+                           deviceInfo.model.toStdString().c_str(),
+                           deviceInfo.serial.toStdString().c_str(),
+                           deviceInfo.fw_version[0],
+                           deviceInfo.fw_version[1],
+                           deviceInfo.fw_version[2],
+                           deviceInfo.hw_version[0],
+                           deviceInfo.hw_version[1],
+                           deviceInfo.hw_version[2],
+                           deviceInfo.access_status,
+                           deviceInfo.is_supported);
+
+                    startSync(ambit_object, &settings, movesCount, readAllLogs, syncTime, syncOrbit, syncSportMode,
+                              syncNavigation, settingsInputFile);
+
+                    if(settings.waypoints.data != NULL) {
+                        free(settings.waypoints.data);
+                    }
+
+                    movesCount->exit();
+                }
+            }
+
+            libambit_close(ambit_object);
+        }
+    }
+    else {
+        printf("No clock found, exiting\n");
+    }
+
+    libambit_free_enumeration(info);
+
+    emit finished();
+}
+
+MovesCount *movesCountSetup(const char *username, const char *userkey)
+{
+    printf("movesCountSetup\n");
+    MovesCount *movesCount = MovesCount::instance();
+    movesCount->setAppkey(APPKEY);
+    movesCount->setBaseAddress(MOVESCOUNT_DEFAULT_URL);
+
+    if(userkey != NULL) {
+        movesCount->setUserkey(/*movesCount->generateUserkey()*/ userkey);
+    }
+
+    //connect(movesCount, SIGNAL(newerFirmwareExists(QByteArray)), this, SLOT(newerFirmwareExists(QByteArray)), Qt::QueuedConnection);
+
+    if(username != NULL) {
+        movesCount->setUsername(username);
+    }
+
+    // don't upload logs in the background for now
+    movesCount->setUploadLogs(false);
+
+    return movesCount;
+}
+
+void startSync(ambit_object_t *deviceObject, ambit_personal_settings_t *currentPersonalSettings, MovesCount *movesCount,
+               bool readAllLogs, bool syncTime, bool syncOrbit, bool syncSportMode, bool syncNavigation,
+               const char *settingsInputFile)
+{
+    time_t current_time;
+    struct tm *local_time;
+    ambit_personal_settings_t *movecountPersonalSettings = libambit_personal_settings_alloc();
+
+    if (deviceObject != NULL) {
+        // Reading personal settings + waypoints
+        int res = libambit_personal_settings_get(deviceObject, currentPersonalSettings);
+        int waypoint_sync_res = libambit_navigation_read(deviceObject, currentPersonalSettings);
+
+        libambit_sync_display_show(deviceObject);
+
+        if (syncTime && res != -1) {
+            qDebug() << "Start time sync...";
+
+            current_time = time(NULL);
+            local_time = localtime(&current_time);
+            res = libambit_date_time_set(deviceObject, local_time);
+            if (res == -1) {
+                qDebug() << "Failed to sync time";
+            }
+
+            qDebug() << "End time sync";
+        }
+
+        if (res != -1) {
+            if (!readAllLogs) {
+                qDebug() << "Not reading log for now...";
+            } else {
+                qDebug() << "Start reading log...";
+
+                syncData_t syncData;
+                syncData.deviceObject = deviceObject;
+                syncData.currentPersonalSettings = currentPersonalSettings;
+                syncData.syncMovescount = true;
+                syncData.movesCount = movesCount;
+
+                res = libambit_log_read(deviceObject, &log_skip_cb, &log_data_cb, NULL, &syncData);
+                if (res == -1) {
+                    qDebug() << "Failed to read logs";
+                }
+
+                qDebug() << "End reading log...";
+            }
+        }
+
+        if (waypoint_sync_res != -1 && syncNavigation) {
+            qDebug() << "Start reading navigation...";
+
+            qDebug() << "Get Personal Settings";
+            if((movesCount->getPersonalSettings(movecountPersonalSettings, true)) != -1) {
+                movesCount->applyPersonalSettingsFromDevice(movecountPersonalSettings, currentPersonalSettings);
+                movesCount->writePersonalSettings(movecountPersonalSettings);
+                libambit_navigation_write(deviceObject, movecountPersonalSettings);
+            } else {
+                qDebug() << "Failed to read navigation";
+            }
+            qDebug() << "End reading navigation...";
+        }
+
+        if (syncSportMode && res != -1) {
+            qDebug() << "Start sport mode";
+
+            ambit_app_rules_t* ambitApps = liblibambit_malloc_app_rules();
+            movesCount->getAppsData(ambitApps);
+
+            ambit_sport_mode_device_settings_t *ambitDeviceSettings = libambit_malloc_sport_mode_device_settings();
+
+            if(settingsInputFile != NULL) {
+                res = readSportModesFromFile(settingsInputFile, ambitDeviceSettings);
+            } else {
+                res = movesCount->getCustomModeData(ambitDeviceSettings);
+            }
+
+            if (res != -1) {
+                qDebug() << "Writing " << ambitDeviceSettings->sport_modes_count << " sport modes and " <<
+                         ambitDeviceSettings->sport_mode_groups_count << " sport mode groups";
+
+                res = libambit_sport_mode_write(deviceObject, ambitDeviceSettings);
+                if (res == -1) {
+                    qDebug() << "Failed to write sport mode";
+                }
+
+                qDebug() << "Writing " << ambitApps->app_rules_count << " applications";
+                res = libambit_app_data_write(deviceObject, ambitDeviceSettings, ambitApps);
+                if (res == -1) {
+                    qDebug() << "Failed to write app data";
+                }
+            } else {
+                qDebug() << "Could not read custom mode data";
+            }
+
+            libambit_sport_mode_device_settings_free(ambitDeviceSettings);
+            libambit_app_rules_free(ambitApps);
+
+            qDebug() << "End reading/writing sport mode";
+        }
+
+        if (syncOrbit && res != -1) {
+            qDebug() << "Start sync orbit data";
+            uint8_t *orbitData = NULL;
+            int orbitDataLen;
+            if ((orbitDataLen = movesCount->getOrbitalData(&orbitData)) != -1) {
+                res = libambit_gps_orbit_write(deviceObject, orbitData, orbitDataLen);
+                if (res == -1) {
+                    qDebug() << "Failed to write orbit data";
+                }
+                free(orbitData);
+            }
+            else {
+                qDebug() << "Failed to sync orbit data";
+            }
+
+            qDebug() << "End orbit data sync";
+        }
+
+        libambit_sync_display_clear(deviceObject);
+    }
+
+    libambit_personal_settings_free(movecountPersonalSettings);
+}
+
+int readSportModesFromFile(const char *settingsInputFile, ambit_sport_mode_device_settings_t *ambitDeviceSettings) {
+    MovescountSettings settings = MovescountSettings();
+
+    MovesCountJSON jsonParser;
+
+    QFile jsonFile(settingsInputFile);
+    jsonFile.open(QFile::ReadOnly);
+    QByteArray data = jsonFile.read(9999999);
+
+    if (data.length() == 0) {
+        qDebug() << "Failed to read settings file from " << settingsInputFile;
+        return -1;
+    } else {
+        if(jsonParser.parseDeviceSettingsReply(data, settings) == -1) {
+            return -1;
+        }
+    }
+
+    settings.toAmbitData(ambitDeviceSettings);
+
+    return 0;
+}
+
+static int log_skip_cb(void *object, ambit_log_header_t *log_header)
+{
+    syncData_t *syncData = static_cast<syncData_t *>(object);
+
+    printf("Got log header \"%s\" %d-%02d-%02d %02d:%02d:%02d\n",
+            log_header->activity_name, log_header->date_time.year, log_header->date_time.month,
+            log_header->date_time.day, log_header->date_time.hour, log_header->date_time.minute,
+            log_header->date_time.msec/1000);
+
+    if (logStore.logExists(syncData->deviceObject->device_info.serial, log_header)) {
+        return 0;
+    }
+
+    return 1;
+}
+
+static void log_data_cb(void *object, ambit_log_entry_t *log_entry)
+{
+    syncData_t *syncData = static_cast<syncData_t *>(object);
+
+    printf("Got log entry \"%s\" %d-%02d-%02d %02d:%02d:%02d\n", log_entry->header.activity_name, log_entry->header.date_time.year, log_entry->header.date_time.month, log_entry->header.date_time.day, log_entry->header.date_time.hour, log_entry->header.date_time.minute, log_entry->header.date_time.msec/1000);
+
+    DeviceInfo deviceInfo;
+    deviceInfo = syncData->deviceObject->device_info;
+
+    LogEntry *entry = logStore.store(deviceInfo, syncData->currentPersonalSettings, log_entry);
+    if (entry != NULL) {
+        movesCountXML.writeLog(entry);
+
+        if (syncData->syncMovescount) {
+            syncData->movesCount->writeLog(entry);
+        }
+
+        delete entry;
+    }
+}
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./src/openambit-cli/Task.h ../openambit.git/src/openambit-cli/Task.h
--- ./src/openambit-cli/Task.h	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/src/openambit-cli/Task.h	2020-07-18 10:07:31.040357883 +0200
@@ -0,0 +1,40 @@
+#ifndef OPENAMBIT_TASK_H
+#define OPENAMBIT_TASK_H
+
+#include <QtCore>
+
+class Task : public QObject
+{
+    Q_OBJECT
+public:
+    Task(QObject *parent, const char *username, const char *userkey,
+         bool readAllLogs, bool syncTime, bool syncOrbit, bool syncSportMode, bool syncNavigation,
+         const char *settingsInputFile) : QObject(parent) {
+        this->username = username;
+        this->userkey = userkey;
+        this->readAllLogs = readAllLogs;
+        this->syncTime = syncTime;
+        this->syncOrbit = syncOrbit;
+        this->syncSportMode = syncSportMode;
+        this->syncNavigation = syncNavigation;
+        this->settingsInputFile = settingsInputFile;
+    }
+
+public slots:
+    void run();
+
+signals:
+    void finished();
+
+private:
+    const char* username;
+    const char* userkey;
+    bool readAllLogs;
+    bool syncTime;
+    bool syncOrbit;
+    bool syncSportMode;
+    bool syncNavigation;
+    const char* settingsInputFile;
+};
+
+#endif //OPENAMBIT_TASK_H
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./test.sh ../openambit.git/test.sh
--- ./test.sh	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/test.sh	2020-07-18 10:07:31.040357883 +0200
@@ -11,7 +11,9 @@
 # then build in various ways
 for b in Debug Release;do
   # not testable here: mac windows
-	for hid in libudev libusb pcapsimulate;do
+  for hid in libudev libusb pcapsimulate;do
+    echo
+	echo Building ${b} with hid: ${hid}
     rm -rf *-build
     BUILD_EXTRAS=1 HIDAPI_DRIVER=${hid} ./build.sh -DCMAKE_BUILD_TYPE=${b}
   done
@@ -19,6 +21,9 @@
 
 # ensure that openambit2gpx.py works
 
+echo 
+echo Testing openambit2gpx
+
 python2.7 tools/openambit2gpx.py test-data/testlog.log "${TMP:-/tmp}"/testlog.gpx
 
 diff --ignore-all-space test-data/testlog.gpx "${TMP:-/tmp}"/testlog.gpx
@@ -26,3 +31,6 @@
 python3 tools/openambit2gpx.py test-data/testlog.log "${TMP:-/tmp}"/testlog.gpx
 
 diff --ignore-all-space test-data/testlog.gpx "${TMP:-/tmp}"/testlog.gpx
+
+echo
+echo Done, all tests passed
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./tools/gpx.xsd ../openambit.git/tools/gpx.xsd
--- ./tools/gpx.xsd	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/tools/gpx.xsd	2020-03-26 18:05:02.656773997 +0100
@@ -0,0 +1,788 @@
+<?xml version="1.0" encoding="utf-8"?>
+<xsd:schema
+	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
+	xmlns="http://www.topografix.com/GPX/1/1"
+	targetNamespace="http://www.topografix.com/GPX/1/1"
+	elementFormDefault="qualified">
+
+<xsd:annotation>
+ <xsd:documentation>
+  GPX schema version 1.1 - For more information on GPX and this schema, visit http://www.topografix.com/gpx.asp
+
+  GPX uses the following conventions: all coordinates are relative to the WGS84 datum.  All measurements are in metric units.
+ </xsd:documentation>
+</xsd:annotation>
+
+  <xsd:element name="gpx"	type="gpxType">
+    <xsd:annotation>
+      <xsd:documentation>
+		GPX is the root element in the XML file.
+	  </xsd:documentation>
+	</xsd:annotation>
+  </xsd:element>
+
+  <xsd:complexType name="gpxType">
+    <xsd:annotation>
+      <xsd:documentation>
+		GPX documents contain a metadata header, followed by waypoints, routes, and tracks.  You can add your own elements
+		to the extensions section of the GPX document.
+	  </xsd:documentation>
+	</xsd:annotation>
+	<xsd:sequence>
+	 <xsd:element name="metadata"	type="metadataType"	minOccurs="0">
+	  <xsd:annotation>
+	   <xsd:documentation>
+		Metadata about the file.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+	 <xsd:element name="wpt"			type="wptType"	minOccurs="0" maxOccurs="unbounded">
+	  <xsd:annotation>
+	   <xsd:documentation>
+		A list of waypoints.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+	 <xsd:element name="rte"			type="rteType"	minOccurs="0" maxOccurs="unbounded">
+	  <xsd:annotation>
+	   <xsd:documentation>
+		A list of routes.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+	 <xsd:element name="trk"			type="trkType"	minOccurs="0" maxOccurs="unbounded">
+	  <xsd:annotation>
+	   <xsd:documentation>
+		A list of tracks.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+	 <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		You can add extend GPX by adding your own elements from another schema here.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+	</xsd:sequence>
+
+	<xsd:attribute name="version" type="xsd:string" use="required" fixed="1.1">
+     <xsd:annotation>
+      <xsd:documentation>
+		You must include the version number in your GPX document.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+	<xsd:attribute name="creator" type="xsd:string" use="required">
+     <xsd:annotation>
+      <xsd:documentation>
+		You must include the name or URL of the software that created your GPX document.  This allows others to
+		inform the creator of a GPX instance document that fails to validate.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+  </xsd:complexType>
+
+  <xsd:complexType name="metadataType">
+    <xsd:annotation>
+      <xsd:documentation>
+		Information about the GPX file, author, and copyright restrictions goes in the metadata section.  Providing rich,
+		meaningful information about your GPX files allows others to search for and use your GPS data.
+	  </xsd:documentation>
+	</xsd:annotation>
+    <xsd:sequence>	<!-- elements must appear in this order -->
+     <xsd:element name="name"		type="xsd:string"		minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		The name of the GPX file.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+     <xsd:element name="desc"		type="xsd:string"		minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		A description of the contents of the GPX file.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+     <xsd:element name="author"		type="personType"		minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		The person or organization who created the GPX file.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+     <xsd:element name="copyright"	type="copyrightType"	minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		Copyright and license information governing use of the file.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+     <xsd:element name="link"		type="linkType"			minOccurs="0" maxOccurs="unbounded">
+      <xsd:annotation>
+       <xsd:documentation>
+		URLs associated with the location described in the file.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+     <xsd:element name="time"		type="xsd:dateTime"		minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		The creation date of the file.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+     <xsd:element name="keywords"	type="xsd:string"		minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		Keywords associated with the file.  Search engines or databases can use this information to classify the data.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+     <xsd:element name="bounds"		type="boundsType"		minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		Minimum and maximum coordinates which describe the extent of the coordinates in the file.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+
+	 <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		You can add extend GPX by adding your own elements from another schema here.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+    </xsd:sequence>
+  </xsd:complexType>
+
+  <xsd:complexType name="wptType">
+    <xsd:annotation>
+      <xsd:documentation>
+		wpt represents a waypoint, point of interest, or named feature on a map.
+	  </xsd:documentation>
+	</xsd:annotation>
+    <xsd:sequence>	<!-- elements must appear in this order -->
+	  <!-- Position info -->
+      <xsd:element name="ele"			type="xsd:decimal"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Elevation (in meters) of the point.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+      <xsd:element name="time"			type="xsd:dateTime"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Creation/modification timestamp for element. Date and time in are in Univeral Coordinated Time (UTC), not local time! Conforms to ISO 8601 specification for date/time representation. Fractional seconds are allowed for millisecond timing in tracklogs. 
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="magvar"		type="degreesType"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Magnetic variation (in degrees) at the point
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="geoidheight"	type="xsd:decimal"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Height (in meters) of geoid (mean sea level) above WGS84 earth ellipsoid.  As defined in NMEA GGA message.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+
+	  <!-- Description info -->
+	  <xsd:element name="name"			type="xsd:string"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			The GPS name of the waypoint. This field will be transferred to and from the GPS. GPX does not place restrictions on the length of this field or the characters contained in it. It is up to the receiving application to validate the field before sending it to the GPS.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="cmt"			type="xsd:string"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			GPS waypoint comment. Sent to GPS as comment. 
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="desc"			type="xsd:string"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			A text description of the element. Holds additional information about the element intended for the user, not the GPS.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="src"			type="xsd:string"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Source of data. Included to give user some idea of reliability and accuracy of data.  "Garmin eTrex", "USGS quad Boston North", e.g.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+      <xsd:element name="link"			type="linkType"			minOccurs="0" maxOccurs="unbounded">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Link to additional information about the waypoint.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="sym"			type="xsd:string"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Text of GPS symbol name. For interchange with other programs, use the exact spelling of the symbol as displayed on the GPS.  If the GPS abbreviates words, spell them out.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="type"			type="xsd:string"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Type (classification) of the waypoint.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+
+	  <!-- Accuracy info -->
+	  <xsd:element name="fix"			type="fixType"			minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Type of GPX fix.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="sat"			type="xsd:nonNegativeInteger"	minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Number of satellites used to calculate the GPX fix.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="hdop"			type="xsd:decimal"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Horizontal dilution of precision.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="vdop"			type="xsd:decimal"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Vertical dilution of precision.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="pdop"			type="xsd:decimal"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Position dilution of precision.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="ageofdgpsdata"	type="xsd:decimal"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Number of seconds since last DGPS update.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="dgpsid"		type="dgpsStationType"	minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			ID of DGPS station used in differential correction.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+
+	 <xsd:element name="extensions"		type="extensionsType"	minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		You can add extend GPX by adding your own elements from another schema here.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+    </xsd:sequence>
+
+    <xsd:attribute name="lat"			type="latitudeType"		use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		The latitude of the point.  This is always in decimal degrees, and always in WGS84 datum.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+    <xsd:attribute name="lon"			type="longitudeType"	use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+      The longitude of the point.  This is always in decimal degrees, and always in WGS84 datum.
+    </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+  </xsd:complexType>
+
+  <xsd:complexType name="rteType">
+    <xsd:annotation>
+      <xsd:documentation>
+		rte represents route - an ordered list of waypoints representing a series of turn points leading to a destination.
+	  </xsd:documentation>
+	</xsd:annotation>
+    <xsd:sequence>
+      <xsd:element name="name"			type="xsd:string"	minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			GPS name of route.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="cmt"			type="xsd:string"	minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			GPS comment for route.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+      <xsd:element name="desc"			type="xsd:string"	minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Text description of route for user.  Not sent to GPS.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="src"			type="xsd:string"	minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Source of data. Included to give user some idea of reliability and accuracy of data.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+      <xsd:element name="link"			type="linkType"		minOccurs="0" maxOccurs="unbounded">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Links to external information about the route.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="number"		type="xsd:nonNegativeInteger"	minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			GPS route number.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="type"			type="xsd:string"	minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Type (classification) of route.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+
+	 <xsd:element name="extensions"		type="extensionsType"	minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		You can add extend GPX by adding your own elements from another schema here.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+ 
+      <xsd:element name="rtept"	type="wptType" minOccurs="0" maxOccurs="unbounded">
+	  <xsd:annotation>
+	   <xsd:documentation>
+		A list of route points.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+    </xsd:sequence>
+  </xsd:complexType>
+
+  <xsd:complexType name="trkType">
+    <xsd:annotation>
+      <xsd:documentation>
+		trk represents a track - an ordered list of points describing a path.
+	  </xsd:documentation>
+	</xsd:annotation>
+    <xsd:sequence>
+      <xsd:element name="name"			type="xsd:string"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			GPS name of track.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="cmt"			type="xsd:string"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			GPS comment for track.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+      <xsd:element name="desc"			type="xsd:string"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			User description of track.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="src"			type="xsd:string"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Source of data. Included to give user some idea of reliability and accuracy of data.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+      <xsd:element name="link"			type="linkType"			minOccurs="0" maxOccurs="unbounded">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Links to external information about track.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="number"		type="xsd:nonNegativeInteger"	minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			GPS track number.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+	  <xsd:element name="type"			type="xsd:string"		minOccurs="0">
+		<xsd:annotation>
+		  <xsd:documentation>
+			Type (classification) of track.
+		  </xsd:documentation>
+		</xsd:annotation>
+	  </xsd:element>
+
+	 <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		You can add extend GPX by adding your own elements from another schema here.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+  
+     <xsd:element name="trkseg"		type="trksegType"		minOccurs="0" maxOccurs="unbounded">
+      <xsd:annotation>
+       <xsd:documentation>
+		A Track Segment holds a list of Track Points which are logically connected in order. To represent a single GPS track where GPS reception was lost, or the GPS receiver was turned off, start a new Track Segment for each continuous span of track data.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+    </xsd:sequence>
+  </xsd:complexType>
+ 
+  <xsd:complexType name="extensionsType">
+   <xsd:annotation>
+    <xsd:documentation>
+	 You can add extend GPX by adding your own elements from another schema here.
+    </xsd:documentation>
+   </xsd:annotation>
+    <xsd:sequence>
+	 <xsd:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded">
+	   <xsd:annotation>
+		<xsd:documentation>
+		 You can add extend GPX by adding your own elements from another schema here.
+		</xsd:documentation>
+	   </xsd:annotation>
+	 </xsd:any>
+    </xsd:sequence>
+  </xsd:complexType>
+
+  <xsd:complexType name="trksegType">
+   <xsd:annotation>
+    <xsd:documentation>
+ 	 A Track Segment holds a list of Track Points which are logically connected in order. To represent a single GPS track where GPS reception was lost, or the GPS receiver was turned off, start a new Track Segment for each continuous span of track data.
+    </xsd:documentation>
+   </xsd:annotation>
+   <xsd:sequence>	<!-- elements must appear in this order -->
+	 <xsd:element name="trkpt"	type="wptType" minOccurs="0" maxOccurs="unbounded">
+      <xsd:annotation>
+       <xsd:documentation>
+		A Track Point holds the coordinates, elevation, timestamp, and metadata for a single point in a track.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+
+	 <xsd:element name="extensions"	type="extensionsType"	minOccurs="0">
+      <xsd:annotation>
+       <xsd:documentation>
+		You can add extend GPX by adding your own elements from another schema here.
+	   </xsd:documentation>
+	  </xsd:annotation>
+	 </xsd:element>
+    </xsd:sequence>
+  </xsd:complexType>
+
+  <xsd:complexType name="copyrightType">
+   <xsd:annotation>
+    <xsd:documentation>
+	 Information about the copyright holder and any license governing use of this file.  By linking to an appropriate license,
+	 you may place your data into the public domain or grant additional usage rights.
+    </xsd:documentation>
+   </xsd:annotation>
+   <xsd:sequence>	<!-- elements must appear in this order -->
+    <xsd:element name="year"		type="xsd:gYear"	minOccurs="0">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		Year of copyright.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:element>
+    <xsd:element name="license"		type="xsd:anyURI"	minOccurs="0">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		Link to external file containing license text.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:element>
+   </xsd:sequence>
+   <xsd:attribute name="author" type="xsd:string" use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		Copyright holder (TopoSoft, Inc.)
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+  </xsd:complexType>
+
+  <xsd:complexType name="linkType">
+   <xsd:annotation>
+    <xsd:documentation>
+	 A link to an external resource (Web page, digital photo, video clip, etc) with additional information.
+    </xsd:documentation>
+   </xsd:annotation>
+   <xsd:sequence>	<!-- elements must appear in this order -->
+    <xsd:element name="text"		type="xsd:string"		minOccurs="0">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		Text of hyperlink.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:element>
+    <xsd:element name="type"		type="xsd:string"		minOccurs="0">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		Mime type of content (image/jpeg)
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:element>
+   </xsd:sequence>
+   <xsd:attribute name="href" type="xsd:anyURI" use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		URL of hyperlink.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+  </xsd:complexType>
+
+  <xsd:complexType name="emailType">
+   <xsd:annotation>
+    <xsd:documentation>
+	 An email address.  Broken into two parts (id and domain) to help prevent email harvesting.
+    </xsd:documentation>
+   </xsd:annotation>
+   <xsd:attribute name="id"			type="xsd:string"		use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		id half of email address (billgates2004)
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+   <xsd:attribute name="domain"		type="xsd:string"		use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		domain half of email address (hotmail.com)
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+  </xsd:complexType>
+
+  <xsd:complexType name="personType">
+   <xsd:annotation>
+    <xsd:documentation>
+	 A person or organization.
+    </xsd:documentation>
+   </xsd:annotation>
+    <xsd:sequence>	<!-- elements must appear in this order -->
+      <xsd:element name="name"		type="xsd:string"		minOccurs="0">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		Name of person or organization.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:element>
+      <xsd:element name="email"		type="emailType"		minOccurs="0">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		Email address.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:element>
+      <xsd:element name="link"		type="linkType"			minOccurs="0">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		Link to Web site or other external information about person.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:element>
+	</xsd:sequence>
+  </xsd:complexType>
+
+  <xsd:complexType name="ptType">
+   <xsd:annotation>
+    <xsd:documentation>
+	 A geographic point with optional elevation and time.  Available for use by other schemas.
+    </xsd:documentation>
+   </xsd:annotation>
+   <xsd:sequence>	<!-- elements must appear in this order -->
+    <xsd:element name="ele"			type="xsd:decimal"		minOccurs="0">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		The elevation (in meters) of the point.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:element>
+    <xsd:element name="time"		type="xsd:dateTime"		minOccurs="0">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		The time that the point was recorded.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:element>
+   </xsd:sequence>
+    <xsd:attribute name="lat"			type="latitudeType"		use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		The latitude of the point.  Decimal degrees, WGS84 datum.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+    <xsd:attribute name="lon"			type="longitudeType"	use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		The latitude of the point.  Decimal degrees, WGS84 datum.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+  </xsd:complexType>
+
+  <xsd:complexType name="ptsegType">
+   <xsd:annotation>
+    <xsd:documentation>
+	 An ordered sequence of points.  (for polygons or polylines, e.g.)
+    </xsd:documentation>
+   </xsd:annotation>
+   <xsd:sequence>	<!-- elements must appear in this order -->
+	 <xsd:element name="pt"	type="ptType"	minOccurs="0" maxOccurs="unbounded">
+	   <xsd:annotation>
+		<xsd:documentation>
+		 Ordered list of geographic points.
+		</xsd:documentation>
+	   </xsd:annotation>
+	 </xsd:element>
+   </xsd:sequence>
+  </xsd:complexType>
+
+  <xsd:complexType name="boundsType">
+   <xsd:annotation>
+    <xsd:documentation>
+	 Two lat/lon pairs defining the extent of an element.
+    </xsd:documentation>
+   </xsd:annotation>
+    <xsd:attribute name="minlat"		type="latitudeType"		use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		The minimum latitude.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+    <xsd:attribute name="minlon"		type="longitudeType"	use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		The minimum longitude.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+    <xsd:attribute name="maxlat"		type="latitudeType"		use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		The maximum latitude.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+    <xsd:attribute name="maxlon"		type="longitudeType"	use="required">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		The maximum longitude.
+	  </xsd:documentation>
+	 </xsd:annotation>
+	</xsd:attribute>
+  </xsd:complexType>
+
+
+  <xsd:simpleType name="latitudeType">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		The latitude of the point.  Decimal degrees, WGS84 datum.
+	  </xsd:documentation>
+	 </xsd:annotation>
+    <xsd:restriction base="xsd:decimal">
+      <xsd:minInclusive value="-90.0"/>
+      <xsd:maxInclusive value="90.0"/>
+    </xsd:restriction>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="longitudeType">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		The longitude of the point.  Decimal degrees, WGS84 datum.
+	  </xsd:documentation>
+	 </xsd:annotation>
+    <xsd:restriction base="xsd:decimal">
+      <xsd:minInclusive value="-180.0"/>
+      <xsd:maxExclusive value="180.0"/>
+    </xsd:restriction>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="degreesType">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		Used for bearing, heading, course.  Units are decimal degrees, true (not magnetic).
+	  </xsd:documentation>
+	 </xsd:annotation>
+    <xsd:restriction base="xsd:decimal">
+      <xsd:minInclusive value="0.0"/>
+      <xsd:maxExclusive value="360.0"/>
+    </xsd:restriction>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="fixType">
+	 <xsd:annotation>
+	  <xsd:documentation>
+		Type of GPS fix.  none means GPS had no fix.  To signify "the fix info is unknown, leave out fixType entirely. pps = military signal used
+	  </xsd:documentation>
+	 </xsd:annotation>
+    <xsd:restriction base="xsd:string">
+      <xsd:enumeration value="none"/>
+      <xsd:enumeration value="2d"/>
+      <xsd:enumeration value="3d"/>
+      <xsd:enumeration value="dgps"/>
+      <xsd:enumeration value="pps"/>
+    </xsd:restriction>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="dgpsStationType">
+   <xsd:annotation>
+    <xsd:documentation>
+	 Represents a differential GPS station.
+    </xsd:documentation>
+   </xsd:annotation>
+    <xsd:restriction base="xsd:integer">
+      <xsd:minInclusive value="0"/>
+      <xsd:maxInclusive value="1023"/>
+    </xsd:restriction>
+  </xsd:simpleType>
+
+</xsd:schema>
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./tools/openambit2gpx.py ../openambit.git/tools/openambit2gpx.py
--- ./tools/openambit2gpx.py	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/tools/openambit2gpx.py	2020-07-18 10:07:31.040357883 +0200
@@ -9,6 +9,9 @@
 import math
 import sys
 
+# Look at http://www.topografix.com/GPX/1/1/gpx.xsd and https://www8.garmin.com/xmlschemas/TrackPointExtensionv2.xsd for XML Schemata for GPX files
+
+
 ##############################
 ## getting input parameters ##
 ##############################
@@ -95,7 +98,7 @@
     hr=element.findtext("HR") if element.findtext("HR")!=None else hrLast
     cadence=element.findtext("Cadence") if element.findtext("Cadence")!=None else cadenceLast
     power=element.findtext("BikePower") if element.findtext("BikePower")!=None else powerLast
-    speed=element.findtext("Speed") if element.findtext("Speed")!=None else speedLast
+    speed=str(float(element.findtext("Speed"))/100) if element.findtext("Speed")!=None else speedLast
     temp=str(float(element.findtext("Temperature"))/10) if element.findtext("Temperature")!=None else tempLast
     airpressure=element.findtext("SeaLevelPressure") if element.findtext("SeaLevelPressure")!=None else airpressureLast
 
@@ -141,9 +144,9 @@
         elif altitudeLast!=None:
             etree.SubElement(trk,"ele").text=altitudeLast
  
-        if time!=None:
+        if time!=None and len(time) > 0:
             etree.SubElement(trk,"time").text=time 
-        elif timeLast!=None:
+        elif timeLast!=None and len(timeLast) > 0:
             etree.SubElement(trk,"time").text=timeLast 
 
         if hr!=None or cadence!=None or power!=None or speed!=None or temp!=None or airpressure!=None:
@@ -192,6 +195,8 @@
 
 fOut.write(" <extensions>\n")
 
+previousLatEP=0
+previousLonEP=0
 for i in range(0,len(lapArray)):
     if lapArray[i][0]=='Manual':
         lap=etree.Element("gpxdata:lap")
@@ -214,18 +219,28 @@
             t=lapArray[i][4]
             t1=lapArray[i][7]
             t2=lapArray[i][10]
-            lat1=float(lapArray[i][5])
-            lat2=float(lapArray[i][8])
-            latInterPolEP=str( ((lat2-lat1)/timeDiff(t1,t2))*timeDiff(t1,t) + lat1 )
+            lat1=float(lapArray[i][5]) if lapArray[i][5]!=None else 0.0
+            lat2=float(lapArray[i][8]) if lapArray[i][8]!=None else 0.0
+            # only try to parse time difference if both times look like valid timestamps
+            if t1 != None and t2 != None and t1 != 0 and t2 != 0 and "T" in t1 and "Z" in t2 and "T" in t1 and "Z" in t2:
+                latInterPolEP=str( ((lat2-lat1)/timeDiff(t1,t2))*timeDiff(t1,t) + lat1 )
+            else:
+                latInterPolEP=0
+
         if i==maxLap:
             lonInterPolEP=lapArray[i][6]
         else:
             t=lapArray[i][4]
             t1=lapArray[i][7]
             t2=lapArray[i][10]
-            lon1=float(lapArray[i][6])
-            lon2=float(lapArray[i][9])
-            lonInterPolEP=str( ((lon2-lon1)/timeDiff(t1,t2))*timeDiff(t1,t) + lon1 )
+            lon1=float(lapArray[i][6]) if lapArray[i][6]!=None else 0.0
+            lon2=float(lapArray[i][9]) if lapArray[i][9]!=None else 0.0
+            # only try to parse time difference if both times look like valid timestamps
+            if t1 != None and t2 != None and t1 != 0 and t2 != 0 and "T" in t1 and "Z" in t2 and "T" in t1 and "Z" in t2:
+                lonInterPolEP=str( ((lon2-lon1)/timeDiff(t1,t2))*timeDiff(t1,t) + lon1 )
+            else:
+                lonInterPolEP=0
+
         previousLatEP=latInterPolEP
         previousLonEP=lonInterPolEP
         SP=etree.SubElement(lap,'startPoint')
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./tools/TrackPointExtensionv2.xsd ../openambit.git/tools/TrackPointExtensionv2.xsd
--- ./tools/TrackPointExtensionv2.xsd	1970-01-01 01:00:00.000000000 +0100
+++ ../openambit.git/tools/TrackPointExtensionv2.xsd	2020-03-26 18:05:02.656773997 +0100
@@ -0,0 +1,94 @@
+<?xml version="1.0"?>
+<xsd:schema targetNamespace="http://www.garmin.com/xmlschemas/TrackPointExtension/v2"
+  elementFormDefault="qualified"
+  xmlns="http://www.garmin.com/xmlschemas/TrackPointExtension/v2"
+  xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+
+  <xsd:annotation><xsd:documentation>
+  This schema defines Garmin extensions to be used with the GPX 1.1 schema.
+  The root element defined by this schema is intended to be used as a child
+  element of the "extensions" elements in the trkpt element in the GPX 1.1 schema. 
+  The GPX 1.1 schema is available at http://www.topografix.com/GPX/1/1/gpx.xsd.
+  This is a replacement for TrackPointExtension in 
+  http://www.garmin.com/xmlschemas/GpxExtensions/v3
+  </xsd:documentation></xsd:annotation>
+
+  <xsd:element name="TrackPointExtension" type="TrackPointExtension_t" />
+
+  <xsd:complexType name="TrackPointExtension_t">
+    <xsd:annotation><xsd:documentation>
+    This type contains data fields that cannot
+    be represented in track points in GPX 1.1 instances.
+    </xsd:documentation></xsd:annotation>
+    <xsd:sequence>
+      <xsd:element name="atemp" type="DegreesCelsius_t" minOccurs="0" />
+      <xsd:element name="wtemp" type="DegreesCelsius_t" minOccurs="0" />
+      <xsd:element name="depth" type="Meters_t" minOccurs="0" />
+      <xsd:element name="hr" type="BeatsPerMinute_t" minOccurs="0"/>
+      <xsd:element name="cad" type="RevolutionsPerMinute_t" minOccurs="0"/>
+      <xsd:element name="speed" type="MetersPerSecond_t" minOccurs="0"/>
+      <xsd:element name="course" type="DegreesTrue_t" minOccurs="0"/>
+      <xsd:element name="bearing" type="DegreesTrue_t" minOccurs="0"/>
+      <xsd:element name="Extensions" type="Extensions_t" minOccurs="0"/>
+    </xsd:sequence>
+  </xsd:complexType>
+
+  <xsd:simpleType name="DegreesCelsius_t">
+    <xsd:annotation><xsd:documentation>
+    This type contains a temperature value measured in degrees Celsius.
+    </xsd:documentation></xsd:annotation>
+    <xsd:restriction base="xsd:double"/>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="Meters_t">
+    <xsd:annotation><xsd:documentation>
+    This type contains a distance value measured in meters.
+    </xsd:documentation></xsd:annotation>
+    <xsd:restriction base="xsd:double"/>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="BeatsPerMinute_t">
+    <xsd:annotation><xsd:documentation>
+    This type contains a heart rate measured in beats per minute.
+    </xsd:documentation></xsd:annotation>
+    <xsd:restriction base="xsd:unsignedByte">
+      <xsd:minInclusive value="1"/>
+    </xsd:restriction>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="RevolutionsPerMinute_t">
+    <xsd:annotation><xsd:documentation>
+    This type contains a cadence measured in revolutions per minute.
+    </xsd:documentation></xsd:annotation>
+    <xsd:restriction base="xsd:unsignedByte">
+	<xsd:maxInclusive value="254"/>
+    </xsd:restriction>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="MetersPerSecond_t">
+    <xsd:annotation><xsd:documentation>
+      This type contains a speed measured in meters per second.
+    </xsd:documentation></xsd:annotation>
+    <xsd:restriction base="xsd:double"/>
+  </xsd:simpleType>
+
+  <xsd:simpleType name="DegreesTrue_t">
+    <xsd:annotation><xsd:documentation>
+      This type contains an angle measured in degrees in a clockwise direction from the true north line.
+    </xsd:documentation></xsd:annotation>
+    <xsd:restriction base="xsd:decimal">
+      <xsd:minInclusive value="0"/>
+      <xsd:maxInclusive value="360"/>
+    </xsd:restriction>
+  </xsd:simpleType>
+  
+  <xsd:complexType name="Extensions_t">
+    <xsd:annotation>
+    <xsd:documentation>This type provides the ability to extend any data type that includes it.</xsd:documentation>
+    </xsd:annotation>
+    <xsd:sequence>
+    <xsd:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+    </xsd:sequence>
+  </xsd:complexType>
+
+</xsd:schema>
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./wireshark_dissector/ambit-dissector.c ../openambit.git/wireshark_dissector/ambit-dissector.c
--- ./wireshark_dissector/ambit-dissector.c	2020-07-18 10:07:39.000000000 +0200
+++ ../openambit.git/wireshark_dissector/ambit-dissector.c	2020-02-19 17:44:32.717370614 +0100
@@ -2494,7 +2494,7 @@
             memset(reassembly_entries+reassembly_entries_alloc, 0, sizeof(ambit_reassembly_entry_t)*10000);
             reassembly_entries_alloc += 10000;
         }
-        if (!pinfo->fd->flags.visited) {
+        if (!PINFO_FD_VISITED(pinfo)) {
             if (msg_part == 0x5d && msg_count > 1) {
                 reassembly_entries[pinfo->fd->num].valid = 2;
                 reassembly_entries[pinfo->fd->num].command = command;
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./wireshark_dissector/cmake/UseMakeDissectorReg.cmake ../openambit.git/wireshark_dissector/cmake/UseMakeDissectorReg.cmake
--- ./wireshark_dissector/cmake/UseMakeDissectorReg.cmake	2017-04-26 20:42:26.273750058 +0200
+++ ../openambit.git/wireshark_dissector/cmake/UseMakeDissectorReg.cmake	2020-07-18 10:07:28.124196665 +0200
@@ -19,7 +19,7 @@
 	ADD_CUSTOM_COMMAND(
 	    OUTPUT 
 	      ${_outputfile}
-	    COMMAND ${PYTHON_EXECUTABLE}
+	    COMMAND ${Python_EXECUTABLE}
 	      ${CMAKE_CURRENT_SOURCE_DIR}/tools/make-dissector-reg.py
 	      ${CMAKE_CURRENT_SOURCE_DIR}
 	      ${_registertype}
diff -Nur -x debian -x .git -x .gitignore -x .pc -x build -x .travis.yml -x .kdev4 -x .idea -x cmake-build-debug -x _build -x '*.iml' -x '*-build' ./wireshark_dissector/CMakeLists.txt ../openambit.git/wireshark_dissector/CMakeLists.txt
--- ./wireshark_dissector/CMakeLists.txt	2017-04-27 22:38:21.000000000 +0200
+++ ../openambit.git/wireshark_dissector/CMakeLists.txt	2020-07-18 10:07:28.124196665 +0200
@@ -29,6 +29,7 @@
 set(CMAKE_INSTALL_WIRESHARKPLUGINSDIR ~/.wireshark
     CACHE PATH "Where to install wireshark plugins")
 
+find_package (Python COMPONENTS Interpreter)
 INCLUDE(UseMakeDissectorReg)
   
 set(GLIB2_MIN_VERSION 2.4.0)
